{"meta":{"title":"ytxytx的纸篓","subtitle":"","description":"","author":"ytxytx","url":"https://ytxytx.github.io","root":"/"},"pages":[{"title":"所有标签","date":"2019-11-21T05:27:55.417Z","updated":"2019-10-26T03:08:28.000Z","comments":true,"path":"tags/index.html","permalink":"https://ytxytx.github.io/tags/index.html","excerpt":"","text":""},{"title":"Friends","date":"2019-11-21T06:40:07.237Z","updated":"2019-11-21T06:40:07.237Z","comments":true,"path":"friends/index.html","permalink":"https://ytxytx.github.io/friends/index.html","excerpt":"","text":""},{"title":"模板","date":"2019-07-13T03:26:18.000Z","updated":"2019-10-26T03:08:41.000Z","comments":true,"path":"templates/index.html","permalink":"https://ytxytx.github.io/templates/index.html","excerpt":"","text":"字符串KMP求前缀最长Border123456fail[1]=0;for (int i=2;i&lt;=len;i++)&#123; fail[i]=fail[i-1]; while (fail[i]&amp;&amp;S[fail[i]+1]!=S[i]) fail[i]=fail[fail[i]]; if (S[fail[i]+1]==S[i]) fail[i]++;&#125; AC自动机12345678910111213141516171819202122232425262728293031323334353637struct ACautomaton&#123; struct node&#123; int son[26],fail,sum; node()&#123;memset(son,0,sizeof(son)),fail=0;&#125; &#125;T[2000000]; int tot; int insert(const std::string &amp;S)&#123; const int len=S.length(); int now=1; for (int i=0;i&lt;len;i++)&#123; int &amp;nxt=T[now].son[S[i]-'a']; if (!nxt) nxt=++tot; now=nxt; &#125; return now; &#125; void make()&#123; std::queue&lt;int&gt; Q; for (int i=0;i&lt;26;i++)&#123; if (T[1].son[i]) T[T[1].son[i]].fail=1,Q.push(T[1].son[i]); else T[1].son[i]=1; &#125; while (!Q.empty())&#123; int now=Q.front(); Q.pop(); for (int i=0;i&lt;26;i++)&#123; if (!T[now].son[i]) T[now].son[i]=T[T[now].fail].son[i]; else Q.push(T[now].son[i]),T[T[now].son[i]].fail=T[T[now].fail].son[i]; &#125; &#125; &#125; ACautomaton()&#123;tot=1;&#125;&#125;; 后缀自动机SAMSAM - oi-wiki 12345678910111213141516171819202122232425262728293031struct SAM&#123; struct node&#123; int son[26],len,link; node()&#123; memset(son,0xff,sizeof(int)*26); len=link=0; &#125; &#125;T[2000000]; int tot,lst; void insert(char C)&#123; C-='a'; int q=++tot,p=lst; lst=tot,T[q].len=T[p].len+1; while (~p&amp;&amp;!~T[p].son[C]) T[p].son[C]=q,p=T[p].link; if (!~p) return; int np=T[p].son[C]; if (T[np].len==T[p].len+1) T[q].link=np; else&#123; int nq=++tot; T[nq].len=T[p].len+1; memcpy(T[nq].son,T[np].son,sizeof(int)*26); T[nq].link=T[np].link; T[np].link=T[q].link=nq; while (~p&amp;&amp;T[p].son[C]==np) T[p].son[C]=nq,p=T[p].link; &#125; &#125; SAM()&#123;tot=lst=0,T[0].link=-1;&#125;&#125;G; 回文自动机PAMPAM - oi-wiki 1234567891011121314151617181920212223242526struct PAM&#123; struct node&#123; int son[26],len,link; node()&#123;memset(son,0,sizeof(son)),len=link=0;&#125; &#125;T[500050]; int tot; void insert(char *S)&#123; int L=strlen(S),now=1; for (int i=0;i&lt;L;i++)&#123; while (S[i]!=S[i-T[now].len-1]) now=T[now].link; int nxt=T[now].son[S[i]-'a']; if (!nxt)&#123; nxt=++tot; T[nxt].len=T[now].len+2; T[nxt].link=T[now].link; while (S[i]!=S[i-T[T[nxt].link].len-1]) T[nxt].link=T[T[nxt].link].link; T[nxt].link=T[T[nxt].link].son[S[i]-'a']; T[now].son[S[i]-'a']=nxt; &#125; now=nxt; &#125; &#125; PAM()&#123;T[1].len=-1,T[0].link=1,tot=1;&#125;&#125;; ManacherS=&quot;$#a#b#c#...&quot; 123456789void Manacher()&#123; pal[1]=0; int id=1; for (int i=2;i&lt;=n+n;i++)&#123; if (i&lt;=id+pal[id]) pal[i]=std::min(pal[id+id-i],id+pal[id]-i); while (T[i+pal[i]+1]==T[i-pal[i]-1]) pal[i]++; if (i+pal[i]&gt;id+pal[id]) id=i; &#125;&#125; 数论杜教筛令 $$ S(n)=\\sum_{i=1}^{n}F(i) $$ 其中$F$是某数论函数 构造函数$H=F*G$ \\begin{align}\\sum_{i=1}^{n}H(i)&amp;=\\sum_{i=1}^{n}\\sum_{d|i}G(d)F(\\frac{i}{d}) \\nonumber\\\\&amp;=\\sum_{d=1}^{n}\\sum_{d|i}G(d)F(\\frac{i}{d}) \\nonumber\\\\&amp;=\\sum_{d=1}^{n}G(d)\\sum_{i=1}^{\\lfloor \\frac{n}{d}\\rfloor}F(i) \\nonumber\\\\&amp;=\\sum_{d=1}^{n}G(d)S(\\lfloor \\frac{n}{d}\\rfloor) \\nonumber\\end{align} 可以得到 $$ S(n)=\\sum_{i=1}^{n}H(i)-\\sum_{d=1}^{n}G(d)S(\\lfloor \\frac{n}{d}\\rfloor) $$ 如果$H$和$G$的前缀和都可以快速计算，那么可以使用整除分块计算$S$ 先预处理较小的$S$，再使用$\\mathrm{map}$或$\\mathrm{unordered\\_map}$记忆化 Miller Rabin 素数测试123456789101112131415161718192021222324inline long long mul(long long a,long long b,long long mod)&#123;return (a*b-static_cast&lt;long long&gt;(static_cast&lt;long double&gt;(a)/mod*b)*mod+mod)%mod;&#125;const int P[10]=&#123;2,3,5,7,11,13,17,19,23,29&#125;;inline long long pow(long long a,long long b,long long mod)&#123; long long ret=1; for (;b;b&gt;&gt;=1,a=mul(a,a,mod)) if (b&amp;1) ret=mul(ret,a,mod); return ret;&#125;bool MillerRabin(long long Q)&#123; if (Q==1) return false; for (int i=0;i&lt;10;i++) if (P[i]==Q) return true; long long U=Q-1; int V=0; while (!(U&amp;1)) V++,U&gt;&gt;=1; for (int i=0;i&lt;10;i++)&#123; long long B=pow(P[i],U,Q); for (int j=0;j&lt;V;j++)&#123; long long nxt=mul(B,B,Q); if (nxt==1&amp;&amp;B!=1&amp;&amp;B!=Q-1) return false; B=nxt; &#125; if (B!=1) return false; &#125; return true;&#125; Pollard-Rho 大数质因数分解12345678910111213141516171819202122232425262728inline long long gene(long long x,long long c,long long P)&#123;return (mul(x,x,P)+c)%P;&#125;long long gcd(long long A,long long B)&#123;return B?gcd(B,A%B):A;&#125;long long Rho(long long S,int c)&#123; long long x=1,y=1,g,w=1,v; bool ext=false; int stp=1; while (1)&#123; long long x0=x; for (int i=0;i&lt;stp;i++)&#123; if (v=mul(w,std::abs(x0-x),S)) w=v; x=gene(x,c,S); if (v=mul(w,std::abs(x0-x),S)) w=v; x=gene(x,c,S); y=gene(y,c,S); if (ext|=(x==y)) break; &#125; if ((g=gcd(w,S))&gt;1) return g; if (ext) return -1; stp&lt;&lt;=1; &#125;&#125;long long PollardRho(long long S)&#123; if (S==1) return 1; if (MillerRabin(S)) return S; long long ret=0; for (int i=0;;i++) if (~(ret=Rho(S,i))) return std::max(PollardRho(ret),PollardRho(S/ret));&#125; Cipolla 二次剩余$$ x^2\\equiv n\\ (\\mathrm{mod}\\ P) $$ 首先利用欧拉判别准则（勒让德符号）判断$n$是否是模$P$意义下二次剩余 然后随机得到一个非二次剩余$\\omega=a^2-n$ 扩域计算 $$ x=(a+\\omega)^{\\frac{P+1}{2}} $$ 12345678910111213141516171819202122232425262728293031int P;std::mt19937 rd(time(0));int CipollaNumberOmega;struct CipollaNumber&#123; int A,B; CipollaNumber()&#123;A=B=0;&#125; CipollaNumber(int A_,int B_)&#123;A=A_,B=B_;&#125;&#125;;inline CipollaNumber operator * (const CipollaNumber &amp;A,const CipollaNumber &amp;B)&#123;return CipollaNumber((A.A*static_cast&lt;long long&gt;(B.A)+CipollaNumberOmega*static_cast&lt;long long&gt;(A.B)%P*static_cast&lt;long long&gt;(B.B))%P,(A.A*static_cast&lt;long long&gt;(B.B)+A.B*static_cast&lt;long long&gt;(B.A))%P);&#125;inline int pow(int a,int b,int mod)&#123; int ret=1; for (;b;b&gt;&gt;=1,a=a*static_cast&lt;long long&gt;(a)%mod) if (b&amp;1) ret=ret*static_cast&lt;long long&gt;(a)%mod; return ret;&#125;inline int pow(CipollaNumber a,int b)&#123; CipollaNumber ret(1,0); for (;b;b&gt;&gt;=1,a=a*a) if (b&amp;1) ret=ret*a; return ret.A;&#125;int sqrt(int x,int P)&#123; if (!x) return 0; if (pow(x,(P-1)/2,P)==P-1) return -1; int a; do&#123; a=rd()%(P-1)+1; CipollaNumberOmega=((a*static_cast&lt;long long&gt;(a)-x)%P+P)%P; &#125;while (pow(CipollaNumberOmega,(P-1)/2,P)!=P-1); return pow(CipollaNumber(a,1),(P+1)/2);&#125; 扩展欧几里得算法 exgcd当前要求 $$ a_0x+b_0y=\\gcd(a_0,b_0) $$ 的解$(x,y)$ 对于这个方程，考虑递归求解 $$ a_ix_i+b_iy_i=\\gcd(a_i,b_i)=\\gcd(a_0,b_0)\\ $$ 令$a_{i+1}=b_i,b_{i+1}=a_i\\%b_i$ $$ a_{i+1}x_{i+1}+b_{i+1}y_{i+1}=\\gcd(a_{i+1},b_{i+1})=\\gcd(a_0,b_0) $$ 假设已经得到了$(x_{i+1},y_{i+1})$，那么可以发现 $$ (x_i=y_{i+1},y_i=x_{i+1}-\\lfloor \\frac{a_{i}}{b_{i}}\\rfloor y_{i+1}) $$ 是符合上一个方程的解，因此可以递归求解 递归的尾部是$a_n=\\gcd(a_0,b_0),b_n=0$，此时解$(x_n=1,y_n=0)$是平凡的 1234void exgcd(int a,int b,int &amp;x,int &amp;y)&#123; if (!b) x=1,y=0; else exgcd(b,a%b,y,x),y-=a/b*x;&#125; 多项式相关FFT、NTT12345678910111213141516171819202122232425262728293031323334const int mod=998244353,MAXN=400000;inline void chkinc(int &amp;C)&#123;C+=C&gt;&gt;31&amp;mod;&#125;inline int pow(int a,int b,int mod=::mod)&#123; int ret=1; for (;b;b&gt;&gt;=1,a=static_cast&lt;long long&gt;(a)*a%mod) if (b&amp;1) ret=static_cast&lt;long long&gt;(ret)*a%mod; return ret;&#125;int wn[MAXN],w[MAXN],rev[MAXN],lim,lims;void FFTinit(int n)&#123; wn[0]=lim=1,lims=-1; while (lim&lt;n) lim&lt;&lt;=1,lims++; for (int i=1;i&lt;lim;i++) rev[i]=rev[i&gt;&gt;1]&gt;&gt;1|(i&amp;1)&lt;&lt;lims; for (int g=pow(3,mod/lim),i=1;i&lt;lim;i++) wn[i]=static_cast&lt;long long&gt;(wn[i-1])*g%mod;&#125;void FFT(int *V,int f)&#123; for (int i=0;i&lt;lim;i++) if (rev[i]&gt;i) std::swap(V[rev[i]],V[i]); for (int i=1;i&lt;lim;i&lt;&lt;=1)&#123; for (int j=0,t=lim/i/2;j&lt;i;j++) w[j]=wn[j*t]; for (int j=0;j&lt;lim;j+=i+i)&#123; for (int k=0;k&lt;i;k++)&#123; const int X=V[j+k],Y=static_cast&lt;long long&gt;(V[i+j+k])*w[k]%mod; chkinc(V[j+k]+=Y-mod),chkinc(V[i+j+k]=X-Y); &#125; &#125; &#125; if (!f)&#123; std::reverse(V+1,V+lim); const int invlim=pow(lim,mod-2); for (int i=0;i&lt;lim;i++) V[i]=static_cast&lt;long long&gt;(V[i])*invlim%mod; &#125;&#125; 杂项快速乘$$ ab \\% P=ab-\\lfloor \\frac{ab}{P} \\rfloor \\cdot P $$ 123long long mul(long long a,long long b)&#123; return (a*b-static_cast&lt;long long&gt;(static_cast&lt;long double&gt;(a)/P*b)%P+P)%P;&#125;"},{"title":"","date":"2019-11-21T05:27:17.081Z","updated":"2019-11-19T10:18:55.000Z","comments":true,"path":"assets/js/canvas-nest.js","permalink":"https://ytxytx.github.io/assets/js/canvas-nest.js","excerpt":"","text":"!function(){function o(w,v,i){return w.getAttribute(v)||i}function j(i){return document.getElementsByTagName(i)}function l(){var i=j(\"script\"),w=i.length,v=i[w-1];return{l:w,z:o(v,\"zIndex\",-1),o:o(v,\"opacity\",0.5),c:o(v,\"color\",\"0,0,0\"),n:o(v,\"count\",99)}}function k(){r=u.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,n=u.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight}function b(){e.clearRect(0,0,r,n);var w=[f].concat(t);var x,v,A,B,z,y;t.forEach(function(i){i.x+=i.xa,i.y+=i.ya,i.xa*=i.x>r||i.xn||i.y"}],"posts":[{"title":"CSP 2019 游记","slug":"CSP2019","date":"2019-11-19T12:46:33.000Z","updated":"2019-11-19T13:43:42.000Z","comments":true,"path":"2019/11/19/CSP2019/","link":"","permalink":"https://ytxytx.github.io/2019/11/19/CSP2019/","excerpt":"CSP-S 2019 游记","text":"CSP-S 2019 游记 Day 0最近的一个月，几乎每天都有模拟测试，或者在下午，或者在晚上。 今天上午就是喜闻乐见的“胜利模拟赛”，也是CSP前的最后一场模拟。教练从cf上选了三道2000上下的题组成一套： T1：“[CF24A]Ring road”T2：“[CF254C]Anagram”T3：“[CF852E]Casinos and travel” T1问题不大； T2真实降智题，想了好久才做出来，结果把一个数组开成char类型直接人没； T3问题不大，但是有一处static_cast&lt;long long&gt;(A)*B打成static_cast&lt;long long&gt;(A*B)又人没了。 信心赛表现成这样，大概正式比赛会好些？ 下午两点，一起坐校车出发前往杭州。 由于初中部受到诺如病毒的侵扰，这回初高中强制分成了两辆车。 车上听会儿歌，打会儿游戏（为什么又没人打雀了啊），聊会儿天，在车上颠簸两个小时就到了。 杭州给我的第一印象是：太挤。高楼密布的环境让我有些不适应，抬头望不尽天空，着实会让人喘不过气来。 下车状态有点糟，或许是水土不服，大概八点就睡下了，有些小紧张，但疲惫还是占了上风，这也与近阶段高压的训练状态脱不了干系。 也不得不感叹自己本身就不是那种能熬夜的人，每每看到同学深夜打cf第二天又能精力充沛地上课总是既羡慕又无奈。 Day 1睡到六点十五，是学校起床铃响的时间，早饭挺糟糕，草草吃完就上路了。那时候才真正感觉到，CSP就在眼前了。 进了考场，地下室挺空旷，挺干净。自己坐的那把凳子下刚好垫了一块木板，一侧高一侧低，不过也没有大影响。面前就是教学用的电子屏，各种通知都能第一时间看到。 很快就开始考试了，在已经响起的嘈杂的键盘声中，我尽量使自己冷静下来，先看完题。 按照惯例，T1应该是很简单的，但是题面稍微有点长，一开始脑子乱看不进去，就先看看T2。 T2树上括号序列，看起来不是难题，有了大方向，再回过头去看看T1，再看看T3。 看题加上T1码完，大概半个小时多过去了，开始刚T2。 大约刚了1h多，T2也码完加对拍过了。 看起来时间并不紧迫，开T3。 一开始毫无头绪，看看链，菊花，感觉还是没有思路。就这样迷茫了半个多小时，出去呼吸了一下新鲜空气（氨气），回来继续刚。 把轨迹画出来试试？嗯？是不是一个环路啊。感觉能贪心？理了理思路，大概又过去十几分钟，这时候只剩下一个半小时左右了。 码码码，码的差不多了，也有点担心自己的贪心是假的，又花了点时间写了阶乘的暴力，调试，样例过了！ 大屏幕上跳动的时间似乎也使内心的希望跳动起来。 和暴力拍上，假了，调试。调掉了一个锅，继续再拍。嗯？不对劲，手模一下假掉了？当场就开始慌了。大约只剩下10分钟了，前两题的文件输入输出还没加上，赶紧先加上，保住前两题再说。 “保住前两题”大概已经是我仅剩的一些理智了。接下来的十分钟，完完全全就慌掉了。看看自己T3还剩几分？链能过吗？菊花能过吗？都过不了。这样不行啊，赶紧把写的暴力拉进来，能拿几分是几分了。套进一个namespace，去掉几个变量，匆匆忙忙判了一下10分的部分分，完全没有管“删掉多余文件”的要求，可是最终再拿到自己的代码使才发现判成$n\\leq 8$了。 一考完状态非常差，人都要站不住了，两腿发软，对刚才的经历心有余悸。面包和水都没有动过。Day 1如果只有210，放在历年这并不是一个好的结果，况且在仅剩的理智快被耗尽的时候，我也没法确保前两题完全不出差错。 出了考场，想哭但是又不习惯于哭。也许本不该把这次比赛看得太重，也许只是因为紧张过后的余悸。耳边也传过一些谈论的话语，似乎大家对T3的看法分化严重，或者做出，或者只有10分，并且后者占了大多数。这多多少少给了我一些慰藉，使我糟糕的状态不至于持续太久。 中午吃完饭又在宾馆里躺了一个小时，爸爸给了我太多的鼓励和安慰。他不曾要求过我要有多优秀，他给我印象最深的一句话是：“只要不忘记自己学信息的初心，尽力完成比赛就好了。” 关于我与OI的缘分，和我学OI的初心，在此展开就显得有些不妥了，但这句话，确乎是给了我很大的启发。 下午爸爸带着我去钱塘江边散心。在江边可以清楚地看见对岸，仍然是高楼林立，这不禁令我有些失望。拍了些照片，和爸爸一起走了很远，又骑着共享单车慢慢骑回来，直到夕阳西下。我已记不清上次骑车是在何时，但这一定是我骑行最远的一次，也是我骑车上路的第一次。 钱塘江有涨潮与落潮，正如这条OI路上有喜悦，也有不尽人意。既然第一天结果无法改变，那就专心为Day 2准备吧。 Day 2早饭换了一处吃，不那么糟糕了，但胃口不好，吃不下太多。 还是那个座位，但我并不那么紧张了，反而更加有了信心。 比赛开始，按照习惯，我还是先花六七分钟通读了一遍题面，借此机会使自己冷静下来。 T1不像往年那么能切，而且又是中长题面；T2第一反应像是斜率优化；T3一眼大概是个数据结构题。 先按顺序开，T1想到容斥，只是第一反应有些不可思议，T1放个容斥不像往年的风格。很快就想到$O(n^3m)$的做法了，可是无奈被降智，止步于此了。 看看T2，再看看T3，对数据结构题没什么兴趣，也没什么感觉（虽然可能不是个数据结构题？），那就先做T2。 如果是斜率优化一定可以写出转移方程，但设计状态的时候总感觉第二维那么大，大概行不通？ 冒出一个贪心的念头，大力猜了波结论，写了发$O(n^2)$，一遍就把大小样例都过了，再拍一拍，过拍了。看起来走对路了！想想优化，好像单调队列就完事了？88分到手，高精先搁一搁，先做T3。 还剩一个半小时多，T3普遍的线段树合并做法我无力想下去了，本来数据结构基础就薄弱。部分分有75分，那就写吧。 暴力和链都很简单，完美二叉树想了一会儿，稍微花了点时间，多测了几遍，还剩半个小时左右。 写高精还得把解码方式读一遍实现一遍，而且没怎么写过高精风险还是有的，估了估时间，那就不写了，也就-12pts。 一直很担心Day 1会因为慌张写错文件等等，所以Day 2留足了时间检查。算了算如果写的分都拿到，还是挺可观的，所以一遍一遍地测，生怕自己挂分。 考完状态比Day 1好多了，比起Day 2，最担心的仍然是Day 1。 考完就坐上校车离开了，下午晚上都在家里躺着，没去学校，什么都不想做。 Day 3没有休息的时间，返校正常上课了。上完一、二两节课就来机房等估分。 估分出来前，总有一种进退两难的感觉，于是心不在焉，不想学文化课，也不想打代码，静不下心。 zgz咕咕咕，导致这天并没有公布选手源程序，白白荒废了一天。 Day 4终于公布选手源程序了，几乎发布三分钟内就把包下载了下来，赶紧测。 结果和预想的一样，除了D1T3提到的判成$n\\leq 8$的失误。 悬着的心终于可以放下，我的OI之路至少幸运的没有在这个关头终结。比起含着不舍写下“告别”的选手，可以继续走下去，这是多少选手可望而不可即，是莫大的幸运了。","categories":[],"tags":[]},{"title":"GCC 的 builtin 函数整理","slug":"builtins","date":"2019-11-10T12:34:46.000Z","updated":"2019-11-11T01:20:38.000Z","comments":true,"path":"2019/11/10/builtins/","link":"","permalink":"https://ytxytx.github.io/2019/11/10/builtins/","excerpt":"这篇文章主要用来记录常用的builtin函数，更详细的可以参阅文档","text":"这篇文章主要用来记录常用的builtin函数，更详细的可以参阅文档 $\\texttt{108=(01101100)}_\\texttt{2}$ 12345int __builtin_ffs(int x);int __builtin_ffsl(long x);int __builtin_ffsll(long long x);__builtin_ffs(108)=3 $x$最低$1$位置加一，如果$x=0$则值为$0$ 12345int __builtin_clz(unsigned int x);int __builtin_clzl(unsigned long x);int __builtin_clzll(unsigned long long x);__builtin_clz(108)=25 $x$最高位起连续$0$位数，如果$x=0$则未定义 12345int __builtin_ctz(unsigned int x);int __builtin_ctzl(unsigned long x);int __builtin_ctzll(unsigned long long x);__builtin_clz(108)=2 $x$最低位起连续$0$位数，如果$x=0$则未定义 123456int __builtin_clrsb(int x);int __builtin_clrsbl(long x);int __builtin_clrsbll(long long x);__builtin_clrsb(108)=24__builtin_clrsb(-1)=31 可以认为是$x$最高位开始连续相同位长度减一 12345int __builtin_popcount(unsigned int x);int __builtin_popcountl(unsigned long x);int __builtin_popcountll(unsigned long long x);__builtin_popcount(108)=4 $x$中$1$位个数 12345int __builtin_parity(unsigned int x);int __builtin_parityl(unsigned long x);int __builtin_parityll(unsigned long long x);__builtin_parity(108)=0 $x$中$1$位个数的奇偶性 12345uint16_t __builtin_bswap16(uint16_t x);uint32_t __builtin_bswap32(uint32_t x);uint64_t __builtin_bswap64(uint64_t x);__builtin_bswap32(108)=1811939328 高低位翻转$x$的二进制位","categories":[],"tags":[]},{"title":"Codeforces 585F Digits of Number Pi","slug":"cf585f","date":"2019-11-07T13:26:04.000Z","updated":"2019-11-07T23:55:24.000Z","comments":true,"path":"2019/11/07/cf585f/","link":"","permalink":"https://ytxytx.github.io/2019/11/07/cf585f/","excerpt":"题目描述给定字符集为数位（0-9）的字符串$S$ 给定相同位数$d$的上下界$L,R$，没有前导零 求所有$L\\leq x\\leq R$，满足$x$中存在至少$\\lfloor\\frac{d}{2}\\rfloor$的连续位在$S$中作为子串出现的个数 $1\\leq |S|\\leq 1000;2\\leq d\\leq 50$，对$10^9+7$取模","text":"题目描述给定字符集为数位（0-9）的字符串$S$ 给定相同位数$d$的上下界$L,R$，没有前导零 求所有$L\\leq x\\leq R$，满足$x$中存在至少$\\lfloor\\frac{d}{2}\\rfloor$的连续位在$S$中作为子串出现的个数 $1\\leq |S|\\leq 1000;2\\leq d\\leq 50$，对$10^9+7$取模 题解对$S$中所有长度为$\\lfloor\\frac{d}{2}\\rfloor$的子串建出AC自动机 如果单独考虑一个$x$，只要$x$在自动机上走到过尾节点，$x$就满足条件 在AC自动机上数位dp，定义状态$F_{now,pos,0/1,0/1,0/1}$为当前考虑到$now$位（从高到低），在自动机上走到$pos$，是否被上界$R$限制，是否被下界$L$限制，是否到达过尾节点 其边界状态为$F_{d,pos,0/1,0/1,vis}=vis$ Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;char S[1050],A[70],B[70];int len,D;const int mod=1000000007;struct ACautomaton&#123; struct node&#123; int son[10],dep,fail; bool ed; &#125;T[50000]; int tot; void insert(char *S,int len=-1)&#123; if (!~len) len=strlen(S); int now=1; for (int i=0;i&lt;len;i++)&#123; int &amp;nxt=T[now].son[S[i]-'0']; if (!nxt) nxt=++tot; T[nxt].dep=T[now].dep+1; now=nxt; &#125; T[now].ed=true; &#125; void make()&#123; std::queue&lt;int&gt; Q; for (int i=0;i&lt;10;i++)&#123; if (T[1].son[i]) Q.push(T[1].son[i]),T[T[1].son[i]].fail=1; else T[1].son[i]=1; &#125; while (!Q.empty())&#123; int now=Q.front(); Q.pop(); for (int i=0;i&lt;10;i++)&#123; if (T[now].son[i]) Q.push(T[now].son[i]),T[T[now].son[i]].fail=T[T[now].fail].son[i]; else T[now].son[i]=T[T[now].fail].son[i]; &#125; &#125; &#125; ACautomaton()&#123;tot=1;&#125;&#125;T;inline void chkinc(int &amp;A)&#123;A+=A&gt;&gt;31&amp;mod;&#125;int dp[55][50000][2][2][2];int DP(int now,int pos,bool upper=true,bool lower=true,bool vis=false)&#123; if (now==D) return vis; int &amp;nowdp=dp[now][pos][upper][lower][vis]; if (~nowdp) return nowdp; int L=lower?A[now]-'0':0,R=upper?B[now]-'0':9; nowdp=0; for (int i=L;i&lt;=R;i++) chkinc(nowdp+=DP(now+1,T.T[pos].son[i],upper&amp;&amp;i==R,lower&amp;&amp;i==L,vis||T.T[T.T[pos].son[i]].ed)-mod); return nowdp;&#125;int main()&#123; memset(dp,0xff,sizeof(dp)); scanf(\"%s%s%s\",S,A,B); len=strlen(S); D=strlen(A); if (D/2&gt;len) return puts(\"0\"),0; for (int i=0;i&lt;len-D/2+1;i++) T.insert(S+i,D/2); T.make(); printf(\"%d\\n\",DP(0,1));&#125;","categories":[],"tags":[{"name":"AC自动机","slug":"AC自动机","permalink":"https://ytxytx.github.io/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"数位dp","slug":"数位dp","permalink":"https://ytxytx.github.io/tags/%E6%95%B0%E4%BD%8Ddp/"},{"name":"Trie","slug":"Trie","permalink":"https://ytxytx.github.io/tags/Trie/"}]},{"title":"Kyoya and Train","slug":"cf553e","date":"2019-11-01T05:27:44.000Z","updated":"2019-11-01T06:07:07.000Z","comments":true,"path":"2019/11/01/cf553e/","link":"","permalink":"https://ytxytx.github.io/2019/11/01/cf553e/","excerpt":"题目描述给定一张$n$个点$m$条有向边的图， 对于每条边$e$，有$P_{e,t}$的概率花费$t$单位时间通过，代价为$c_e$ 从$1$走到$n$，如果超过时限$T$则额外付出代价$x$ 求期望代价最小值","text":"题目描述给定一张$n$个点$m$条有向边的图， 对于每条边$e$，有$P_{e,t}$的概率花费$t$单位时间通过，代价为$c_e$ 从$1$走到$n$，如果超过时限$T$则额外付出代价$x$ 求期望代价最小值 题解首先考虑一个dp： 令$F_{i,t}$表示走到$i$，已经用了$t$时间，余下路程的最小期望代价 令$\\operatorname{dis}(i,j)$表示从$i$走到$j$的最小代价（最短路） 对于$t&gt;T$，既然已经超时，不如直接走最短路花费最小 $$ F_{i,t}=\\operatorname{dis}(i,n)+x $$ 否则抱有一丝希望 $$ F_{i,j}=\\min_{e\\in E,x_e=i}\\left(c_e+\\sum_{k=1}^{T}F_{y_e,j+k}\\cdot P_{e,k}\\right) $$ 令 $$ S_{e,j}=\\sum_{k=1}^{T}F_{y_e,j+k}\\cdot P_{e,k} $$ 那么 $$ F_{i,j}=\\min_{e\\in E,x_e=i}(c_e+S_{e,j}) $$ 至此，可以使用分治FFT完成$F$和$S$的计算，对已经耗费的时间分治 具体的，对于分治区间$[L,R]$： 如果$L=R$，那么$F_{i,L}$可以用对应的$S$转移得到 否则，先分治右半边，然后用右半边的$F$更新左半边的$S$（FFT），再分治左半边 时间复杂度为$O(mT\\log^2T)$，注意实现的常数 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#pragma GCC optimize(2)#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;limits&gt;struct Complex&#123; double A,B; Complex():A(0),B(0)&#123;&#125; Complex(double A_):A(A_),B(0)&#123;&#125;; Complex(double A_,double B_):A(A_),B(B_)&#123;&#125;;&#125;;inline Complex operator + (const Complex &amp;A,const Complex &amp;B)&#123;return Complex(A.A+B.A,A.B+B.B);&#125;inline Complex operator - (const Complex &amp;A,const Complex &amp;B)&#123;return Complex(A.A-B.A,A.B-B.B);&#125;inline Complex operator * (const Complex &amp;A,const Complex &amp;B)&#123;return Complex(A.A*B.A-A.B*B.B,A.A*B.B+A.B*B.A);&#125;inline Complex &amp; operator /= (Complex &amp;A,const double B)&#123;return A.A/=B,A.B/=B,A;&#125;int dis[70][70];int n,m,t,x;int A[105],B[105],C[105];std::vector&lt;int&gt; son[105];double P[105][40050];double S[105][40050];double dp[105][40050];Complex tmp1[200000],tmp2[200000];const double pi=acosl(-1);Complex w[200000],wn[200000];int lim,lims,rev[200000];void FFTinit(int N)&#123; w[0]=1,lim=1,lims=-1; while (lim&lt;N) lim&lt;&lt;=1,lims++; Complex g(cosl(2*pi/lim),sinl(2*pi/lim)); for (int i=1;i&lt;lim;i++) w[i]=w[i-1]*g; for (int i=1;i&lt;lim;i++) rev[i]=rev[i&gt;&gt;1]&gt;&gt;1|(i&amp;1)&lt;&lt;lims;&#125;void FFT(Complex *V,int f)&#123; for (int i=0;i&lt;lim;i++) if (rev[i]&gt;i) std::swap(V[rev[i]],V[i]); for (int i=1;i&lt;lim;i&lt;&lt;=1)&#123; for (int j=0,t=lim/i/2;j&lt;i;j++) wn[j]=w[j*t]; for (int j=0;j&lt;lim;j+=i+i)&#123; for (int k=0;k&lt;i;k++)&#123; Complex X=V[j+k],Y=V[i+j+k]*wn[k]; V[j+k]=X+Y,V[i+j+k]=X-Y; &#125; &#125; &#125; if (!f)&#123; std::reverse(V+1,V+lim); for (int k=0;k&lt;lim;k++) V[k]/=lim; &#125;&#125;int sum=0;void solve(int L,int R)&#123; if (L==R)&#123; if (L&gt;t) for (int i=1;i&lt;=n;i++) dp[i][L]=dis[i][n]+x; else&#123; for (int i=1;i&lt;=n;i++)&#123; dp[i][L]=std::numeric_limits&lt;double&gt;::max(); for (std::vector&lt;int&gt;::iterator it=son[i].begin();it!=son[i].end();++it) dp[i][L]=std::min(dp[i][L],S[*it][L]+C[*it]); &#125; dp[n][L]=0; &#125; return; &#125; int mdl=(L+R)&gt;&gt;1; solve(mdl+1,R); for (int i=1;i&lt;=m;i++)&#123; FFTinit(R-L+2+R-mdl+2); sum+=lim; for (int j=0;j&lt;lim;j++) tmp1[j]=Complex(); for (int j=0;j&lt;lim;j++) tmp2[j]=Complex(); for (int j=mdl+1;j&lt;=R;j++) tmp1[j-mdl]=dp[B[i]][j]; for (int j=1;j&lt;=R-L+1;j++) tmp2[R-L-j+2]=P[i][j]; FFT(tmp1,1),FFT(tmp2,1); for (int j=0;j&lt;lim;j++) tmp1[j]=tmp1[j]*tmp2[j]; FFT(tmp1,0); for (int j=L;j&lt;=mdl;j++) S[i][j]+=tmp1[R-L+2-(mdl-j)].A; &#125; solve(L,mdl);&#125;int main()&#123; scanf(\"%d%d%d%d\",&amp;n,&amp;m,&amp;t,&amp;x); memset(dis,0x3f,sizeof(dis)); for (int i=1;i&lt;=n;i++) dis[i][i]=0; for (int i=1;i&lt;=m;i++)&#123; scanf(\"%d%d%d\",&amp;A[i],&amp;B[i],&amp;C[i]); son[A[i]].push_back(i); dis[A[i]][B[i]]=C[i]; for (int j=1;j&lt;=t;j++) scanf(\"%lf\",&amp;P[i][j]),P[i][j]/=100000; &#125; for (int k=1;k&lt;=n;k++) for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) dis[i][j]=std::min(dis[i][j],dis[i][k]+dis[k][j]); solve(0,t+t); printf(\"%.8lf\\n\",dp[1][0]);&#125;","categories":[],"tags":[{"name":"FFT 快速傅里叶变换","slug":"FFT-快速傅里叶变换","permalink":"https://ytxytx.github.io/tags/FFT-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"},{"name":"DP 动态规划","slug":"DP-动态规划","permalink":"https://ytxytx.github.io/tags/DP-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"lydsy 4231 回忆树","slug":"lydsy4231","date":"2019-10-28T11:40:49.000Z","updated":"2019-10-28T12:00:02.000Z","comments":true,"path":"2019/10/28/lydsy4231/","link":"","permalink":"https://ytxytx.github.io/2019/10/28/lydsy4231/","excerpt":"题目描述给定一棵无根树，每条树边上有单个小写字母 多次询问，给定$u,v,S$，表示询问$S$在$u$到$v$路径组成的字符串中出现了几次","text":"题目描述给定一棵无根树，每条树边上有单个小写字母 多次询问，给定$u,v,S$，表示询问$S$在$u$到$v$路径组成的字符串中出现了几次 题解$S$在$u$到$v$路径上出现，分两种情况讨论： $S$跨过$\\operatorname{LCA}(u,v)$ $S$不跨过$\\operatorname{LCA}(u,v)$ 对于第一种情况，将$\\operatorname{LCA}$附近一小段字符串取出来做kmp，其长度不超过$2|S|$ 重点讨论第二种情况，每一个询问右侧拆成到根的两个询问，左侧拆成其询问串反串的两个询问 做完以上转化，现在问题大体变成若干询问： $S$在$1$到$u$的路径上组成的字符串中出现几次 对于所有询问串（及其反串）建出AC自动机，并得到其fail树的dfs序 离线记录原树上每个节点的询问 dfs原树，同时记录其在AC自动机上走到的节点，将其权$+1$，回溯的时候$-1$ 处理每个节点的所有询问就是该询问串在fail树上的子树和，用树状数组维护 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;int n,Q;struct edge&#123; int to,nxt; char C;&#125;E[200050];int H[100050],tot;void add_edge(int a,int b,char v)&#123; E[++tot]=(edge)&#123;b,H[a],v&#125;;H[a]=tot; E[++tot]=(edge)&#123;a,H[b],v&#125;;H[b]=tot;&#125;int x,y;char o;int X[100050],Y[100050];std::string str[100050];int FenwickMax;struct Fenwick&#123; int F[600050]; void add(int x,int v)&#123;while (x&lt;=FenwickMax) F[x]+=v,x+=x&amp;-x;&#125; int query(int x)&#123;int ret=0;while (x) ret+=F[x],x&amp;=x-1;return ret;&#125;&#125;F;struct AC&#123; struct node&#123; int son[26],fail; node()&#123;memset(son,0,sizeof(son)),fail=0;&#125; &#125;T[600050]; int tot; int insert(std::string &amp;S)&#123; int now=1; for (std::string::iterator it=S.begin();it!=S.end();++it)&#123; int &amp;nxt=T[now].son[*it-'a']; if (!nxt) nxt=++tot; now=nxt; &#125; return now; &#125; void make()&#123; std::queue&lt;int&gt; Q; for (int i=0;i&lt;26;i++)&#123; if (T[1].son[i]) Q.push(T[1].son[i]),T[T[1].son[i]].fail=1; else T[1].son[i]=1; &#125; while (!Q.empty())&#123; int now=Q.front(); Q.pop(); for (int i=0;i&lt;26;i++)&#123; if (T[now].son[i]) Q.push(T[now].son[i]),T[T[now].son[i]].fail=T[T[now].fail].son[i]; else T[now].son[i]=T[T[now].fail].son[i]; &#125; &#125; &#125; AC()&#123;tot=1;&#125;&#125;A;std::vector&lt;int&gt; son[600050];std::vector&lt;int&gt; query[300050];int id[600050],dfn[600050],sz[600050],DFN;int Fa[600050][20],dep[600050];char Fach[600050];void dfs1(int now)&#123; dfn[now]=++DFN,sz[now]=1; for (std::vector&lt;int&gt;::iterator it=son[now].begin();it!=son[now].end();++it) Fa[*it][0]=now,dep[*it]=dep[now]+1,dfs1(*it),sz[now]+=sz[*it];&#125;void dfs2(int now,int fa)&#123; Fa[now][0]=fa; for (int i=1;i&lt;20;i++) Fa[now][i]=Fa[Fa[now][i-1]][i-1]; dep[now]=dep[fa]+1; for (int i=H[now];i;i=E[i].nxt)&#123; if (E[i].to!=fa) dfs2(E[i].to,now); Fach[E[i].to]=E[i].C; &#125;&#125;int LCA(int x,int y)&#123; if (dep[x]&lt;dep[y]) std::swap(x,y); int dx=dep[x]-dep[y]; for (int i=0;i&lt;20;i++) if (dx&gt;&gt;i&amp;1) x=Fa[x][i]; if (x==y) return x; for (int i=19;~i;i--) if (Fa[x][i]!=Fa[y][i]) x=Fa[x][i],y=Fa[y][i]; return Fa[x][0];&#125;int jump(int x,int d)&#123; if (d&gt;dep[x]) return x; int dx=dep[x]-d; for (int i=0;i&lt;20;i++) if (dx&gt;&gt;i&amp;1) x=Fa[x][i]; return x;&#125;char tmp[100050];int border[100050],ans[200050];void solve(int now,int fa,int dnow)&#123; F.add(dfn[dnow],1); for (std::vector&lt;int&gt;::iterator it=query[now].begin();it!=query[now].end();++it)&#123; if (*it&gt;0) ans[*it]+=F.query(dfn[id[*it]]+sz[id[*it]]-1)-F.query(dfn[id[*it]]-1); else ans[-*it]-=F.query(dfn[id[-*it]]+sz[id[-*it]]-1)-F.query(dfn[id[-*it]]-1); &#125; for (int i=H[now];i;i=E[i].nxt) if (E[i].to!=fa) solve(E[i].to,now,A.T[dnow].son[E[i].C-'a']); F.add(dfn[dnow],-1);&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;Q); for (int i=1;i&lt;n;i++)&#123; scanf(\"%d%d\",&amp;x,&amp;y); while (isspace(o=getchar())); add_edge(x,y,o); &#125; for (int i=1;i&lt;=Q;i++)&#123; scanf(\"%d%d\",&amp;X[i],&amp;Y[i]); std::cin&gt;&gt;str[i]; id[i]=A.insert(str[i]); std::reverse(str[i].begin(),str[i].end()); id[i+Q]=A.insert(str[i]); std::reverse(str[i].begin(),str[i].end()); &#125; A.make(); for (int i=2;i&lt;=A.tot;i++) son[A.T[i].fail].push_back(i); dfs1(1); dfs2(1,0); for (int i=1;i&lt;=Q;i++)&#123; int lca=LCA(X[i],Y[i]),jx=jump(X[i],dep[lca]+str[i].length()-1),jy=jump(Y[i],dep[lca]+str[i].length()-1); if (dep[X[i]]-dep[lca]&gt;=str[i].length()) query[X[i]].push_back(i+Q),query[jx].push_back(-i-Q); if (dep[Y[i]]-dep[lca]&gt;=str[i].length()) query[Y[i]].push_back(i),query[jy].push_back(-i); int len=dep[jx]+dep[jy]-2*dep[lca]; for (int now=jx,t=0;now!=lca;now=Fa[now][0],t++) tmp[t]=Fach[now]; for (int now=jy,t=len-1;now!=lca;now=Fa[now][0],t--) tmp[t]=Fach[now]; tmp[len]=0; border[0]=-1; for (int j=1,len=str[i].length();j&lt;=len;j++)&#123; border[j]=border[j-1]+1; while (border[j]&amp;&amp;str[i][j-1]!=str[i][border[j]-1]) border[j]=border[border[j]-1]+1; &#125; for (int j=0,t=0;j&lt;len;j++)&#123; t++; while (t&amp;&amp;str[i][t-1]!=tmp[j]) t=border[t-1]+1; if (t==str[i].length()) ans[i]++; &#125; &#125; FenwickMax=A.tot; solve(1,0,1); for (int i=1;i&lt;=Q;i++) printf(\"%d\\n\",ans[i]+ans[i+Q]);&#125;","categories":[],"tags":[{"name":"AC自动机","slug":"AC自动机","permalink":"https://ytxytx.github.io/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"倍增","slug":"倍增","permalink":"https://ytxytx.github.io/tags/%E5%80%8D%E5%A2%9E/"},{"name":"KMP","slug":"KMP","permalink":"https://ytxytx.github.io/tags/KMP/"}]},{"title":"Codeforces 587F Duff is Mad","slug":"cf587f","date":"2019-10-23T03:31:41.000Z","updated":"2019-10-26T03:07:15.000Z","comments":true,"path":"2019/10/23/cf587f/","link":"","permalink":"https://ytxytx.github.io/2019/10/23/cf587f/","excerpt":"题目描述给定若干字符串$S_i$ 多次询问编号在$[L,R]$区间中的字符串在$S_k$中出现次数总和","text":"题目描述给定若干字符串$S_i$ 多次询问编号在$[L,R]$区间中的字符串在$S_k$中出现次数总和 题解由于是多串匹配问题，先建出AC自动机 接下来要用到fail树的性质 询问$[L,R]$区间中的字符串在$S_k$中出现次数总和可以从两个方法考虑： 对于所有$[L,R]$中的$S_i$在Trie树中的对应节点，使其在fail树中的子树全部加一，然后询问$S_k$匹配路径上的权值和 将$S_k$匹配路径上的权值置为$1$，然后询问所有$[L,R]$中的$S_i$在Trie树中的对应节点，其在fail树中的子树和 令$T$为Trie树上节点个数（不会超过$\\sum S_i$） 将询问离线，将询问$[L,R]$转化为$[1,R]$和$[1,L-1]$的询问，并处理出fail树的dfs序 对于$|S_k|&gt;\\sqrt{T}$，这样的字符串不会超过$\\sqrt{T}$个 使用第二种方法，对于这$\\sqrt{T}$种字符串分别求解，路径上点置$1$，然后子树求和，时间复杂度$O(n\\sqrt{T}+Q)$ 而对于$|S_k|&lt;=\\sqrt{T}$，使用第一种方法 字符串逐个进行子树加，然后对于右端点为当前字符串的询问，暴力询问$S_k$匹配路径上的单点值进行求和 如果使用分块可以做到$O(\\sqrt{T})-O(1)$，复杂度达到$O(n\\sqrt{T}+Q)$ 综上，时间复杂度为$O(n\\sqrt{T}+Q)$ Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;int n,Q,len;std::vector&lt;int&gt; son[100050];struct ACautomaton&#123; struct node&#123; int son[26],fail; node()&#123;memset(son,0,sizeof(son)),fail=0;&#125; &#125;T[100005]; int tot; std::vector&lt;int&gt; insert(const std::string &amp;S)&#123; std::vector&lt;int&gt; path; path.push_back(1); const int len=S.length(); int now=1; for (int i=0;i&lt;len;i++)&#123; int &amp;nxt=T[now].son[S[i]-'a']; if (!nxt) nxt=++tot; now=nxt; path.push_back(now); &#125; return path; &#125; void make()&#123; std::queue&lt;int&gt; Q; for (int i=0;i&lt;26;i++)&#123; if (T[1].son[i]) Q.push(T[1].son[i]),T[T[1].son[i]].fail=1; else T[1].son[i]=1; &#125; while (!Q.empty())&#123; int now=Q.front(); son[T[now].fail].push_back(now); Q.pop(); for (int i=0;i&lt;26;i++)&#123; if (T[now].son[i]) Q.push(T[now].son[i]),T[T[now].son[i]].fail=T[T[now].fail].son[i]; else T[now].son[i]=T[T[now].fail].son[i]; &#125; &#125; &#125; ACautomaton()&#123;tot=1;&#125;&#125;T;std::vector&lt;int&gt; path[100050];std::string S[100050];int dfn[100050],DFN,sz[100050];void dfs(int now)&#123; dfn[now]=++DFN; for (std::vector&lt;int&gt;::iterator it=son[now].begin();it!=son[now].end();++it) dfs(*it),sz[now]+=sz[*it]; sz[now]++;&#125;struct tmp&#123;int t,s,flag,id;&#125;Y[200050];int tot,splitid,blo;bool cmp(tmp a,tmp b)&#123;return S[a.s].length()&lt;S[b.s].length();&#125;bool cmps(tmp a,tmp b)&#123;return a.s&lt;b.s;&#125;bool cmpt(tmp a,tmp b)&#123;return a.t&lt;b.t;&#125;int ttmp[100050];long long ans[100050];struct block&#123; int tag[1000],val[100050]; void add(int L,int R)&#123; int bl=L/blo,br=R/blo; if (bl==br) for (int i=L;i&lt;=R;i++) val[i]++; else&#123; for (int i=L;i&lt;(bl+1)*blo;i++) val[i]++; for (int i=br*blo;i&lt;=R;i++) val[i]++; for (int i=bl+1;i&lt;=br-1;i++) tag[i]++; &#125; &#125; inline int query(int k)&#123;return tag[k/blo]+val[k];&#125; block()&#123;memset(tag,0,sizeof(tag)),memset(val,0,sizeof(val));&#125;&#125;B;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;Q); for (int i=1;i&lt;=n;i++) std::cin&gt;&gt;S[i],path[i]=T.insert(S[i]); T.make(); blo=sqrt(T.tot)+1; dfs(1); for (int i=1,x,y,z;i&lt;=Q;i++)&#123; scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z); Y[i*2-1]=(tmp)&#123;y,z,1,i&#125;; Y[i*2]=(tmp)&#123;x-1,z,-1,i&#125;; &#125; tot=2*Q; std::sort(Y+1,Y+tot+1,cmp); splitid=1; while (splitid&lt;=tot&amp;&amp;S[Y[splitid].s].length()&lt;=blo) splitid++; std::sort(Y+1,Y+splitid,cmpt); std::sort(Y+splitid,Y+tot+1,cmps); for (int L=splitid,R;L&lt;=tot;L=R+1)&#123; R=L; while (R&lt;=tot&amp;&amp;Y[R+1].s==Y[L].s) R++; std::sort(Y+L,Y+R+1,cmpt); memset(ttmp,0,sizeof(int)*(T.tot+1)); for (std::vector&lt;int&gt;::iterator it=path[Y[L].s].begin();it!=path[Y[L].s].end();++it) ttmp[dfn[*it]]++; for (int i=1;i&lt;=T.tot;i++) ttmp[i]+=ttmp[i-1]; int it=L; long long addtmp=0; while (it&lt;=R&amp;&amp;!Y[it].t) it++; for (int i=1;i&lt;=n;i++)&#123; addtmp+=ttmp[dfn[path[i].back()]+sz[path[i].back()]-1]-ttmp[dfn[path[i].back()]-1]; while (it&lt;=R&amp;&amp;Y[it].t==i) ans[Y[it].id]+=Y[it].flag*addtmp,it++; &#125; &#125; int it=1; while (it&lt;splitid&amp;&amp;!Y[it].t) it++; for (int i=1;i&lt;=n;i++)&#123; B.add(dfn[path[i].back()],dfn[path[i].back()]+sz[path[i].back()]-1); while (it&lt;splitid&amp;&amp;Y[it].t==i)&#123; for (std::vector&lt;int&gt;::iterator dit=path[Y[it].s].begin();dit!=path[Y[it].s].end();++dit) ans[Y[it].id]+=Y[it].flag*B.query(dfn[*dit]); it++; &#125; &#125; for (int i=1;i&lt;=Q;i++) printf(\"%lld\\n\",ans[i]);&#125;","categories":[],"tags":[{"name":"AC自动机","slug":"AC自动机","permalink":"https://ytxytx.github.io/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"分块","slug":"分块","permalink":"https://ytxytx.github.io/tags/%E5%88%86%E5%9D%97/"}]},{"title":"UOJ 315 【NOI2017】蚯蚓排队","slug":"uoj315","date":"2019-10-21T07:49:44.000Z","updated":"2019-10-26T03:07:09.000Z","comments":true,"path":"2019/10/21/uoj315/","link":"","permalink":"https://ytxytx.github.io/2019/10/21/uoj315/","excerpt":"题目描述维护一个字符集大小为$6$的字符串集，支持： 将集合中一个字符串接到另一个后面 将某个字符串截成两个 给定另一个字符串$S’$和正整数$k$，求$S’$的所有长度为$k$的连续子串在字符串集中作为某个串子串的出现次数乘积 其中，$2$操作不超过$c=1000$次，$3$操作$k$不超过$50$","text":"题目描述维护一个字符集大小为$6$的字符串集，支持： 将集合中一个字符串接到另一个后面 将某个字符串截成两个 给定另一个字符串$S’$和正整数$k$，求$S’$的所有长度为$k$的连续子串在字符串集中作为某个串子串的出现次数乘积 其中，$2$操作不超过$c=1000$次，$3$操作$k$不超过$50$ 题解由于询问$k$很小，可以考虑直接维护所有长度不超过$50$的子串的哈希值 这样的子串只有不超过$50|S|$个 每次合并字符串，找到所有经过连接点的长度不超过$50$的子串加入哈希表 而分裂字符串就找到所有经过分裂点的长度不超过$50$的子串从哈希表中删去 乍一看，复杂度好像是$O(Qk^2)$的，其中$Q$是总询问次数 假如只有合并，每个字符串仅会被加入哈希表一次，这样分析复杂度是$O(Qk)$的 分裂字符串的次数很少，对上面的复杂度分析没有影响 对于询问，直接在哈希表中查找出现次数即可 时间复杂度$O(Qk+ck^2+\\sum|S’|)$ 注意哈希模数的选取，我直接使用了自然溢出 注意算法实现的常数 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;int n,m;int pre[200001],suf[200001],id[200001];char S[10000000];int opt,x,y;const int mul=19260817,MOD=998244353;unsigned long long powmul[60];class Hashtable&#123; private: static const int tablemod=(1&lt;&lt;24)-1; int tmp[tablemod+1],tot; struct edge&#123;int val;unsigned long long real;int nxt;&#125;E[tablemod+1]; public: inline int &amp; operator [] (const unsigned long long idx)&#123; const int r=idx&amp;tablemod; for (int i=tmp[r];i;i=E[i].nxt) if (E[i].real==idx) return E[i].val; E[++tot]=(edge)&#123;0,idx,tmp[r]&#125;;tmp[r]=tot; return E[tot].val; &#125;&#125;H;unsigned long long tmp[51];int top;int main()&#123; powmul[0]=1; for (int i=1;i&lt;=50;i++) powmul[i]=static_cast&lt;unsigned long long&gt;(powmul[i-1])*mul; scanf(\"%d%d\",&amp;n,&amp;m); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;id[i]),H[id[i]]++; while (m--)&#123; scanf(\"%d\",&amp;opt); switch (opt)&#123; case 1: scanf(\"%d%d\",&amp;x,&amp;y); top=0; for (int now=x,t=1;t&lt;=49&amp;&amp;now;t++,now=pre[now]) tmp[top+1]=tmp[top]+static_cast&lt;unsigned long long&gt;(id[now])*powmul[t-1],top++; for (int now=y,t=1;t&lt;=49&amp;&amp;now;t++,now=suf[now]) for (int i=1;i+t&lt;=50&amp;&amp;i&lt;=top;i++) tmp[i]=tmp[i]*static_cast&lt;unsigned long long&gt;(mul)+id[now],H[tmp[i]]++; suf[x]=y,pre[y]=x; break; case 2: scanf(\"%d\",&amp;x); top=0; for (int now=x,t=1;t&lt;=49&amp;&amp;now;t++,now=pre[now]) tmp[top+1]=tmp[top]+static_cast&lt;unsigned long long&gt;(id[now])*powmul[t-1],top++; for (int now=suf[x],t=1;t&lt;=49&amp;&amp;now;t++,now=suf[now]) for (int i=1;i+t&lt;=50&amp;&amp;i&lt;=top;i++) tmp[i]=tmp[i]*static_cast&lt;unsigned long long&gt;(mul)+id[now],H[tmp[i]]--; pre[suf[x]]=0,suf[x]=0; break; case 3: scanf(\"%s%d\",S,&amp;x); y=strlen(S); unsigned long long hashval=0; for (int i=0;i&lt;x;i++) hashval=hashval*static_cast&lt;unsigned long long&gt;(mul)+(S[i]&amp;7); int ans=H[hashval]; for (int i=x;i&lt;y;i++)&#123; hashval=hashval*static_cast&lt;unsigned long long&gt;(mul)+(S[i]&amp;7)-static_cast&lt;unsigned long long&gt;(S[i-x]&amp;7)*powmul[x]; ans=static_cast&lt;long long&gt;(ans)*H[hashval]%MOD; &#125; printf(\"%d\\n\",ans); break; &#125; &#125;&#125;","categories":[],"tags":[{"name":"哈希","slug":"哈希","permalink":"https://ytxytx.github.io/tags/%E5%93%88%E5%B8%8C/"},{"name":"链表","slug":"链表","permalink":"https://ytxytx.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"UOJ 119 【UR #8】决战圆锥曲线","slug":"uoj119","date":"2019-10-19T12:59:18.000Z","updated":"2019-10-26T03:07:12.000Z","comments":true,"path":"2019/10/19/uoj119/","link":"","permalink":"https://ytxytx.github.io/2019/10/19/uoj119/","excerpt":"题目描述维护一个序列，支持： 单点修改 区间变成$100000-v$ 区间询问所有$i\\in[L,R]$，$ai+bv_i+civ_i$的最大值 保证初始序列、修改询问区间随机 时刻保证权值在$[0,100000]$中","text":"题目描述维护一个序列，支持： 单点修改 区间变成$100000-v$ 区间询问所有$i\\in[L,R]$，$ai+bv_i+civ_i$的最大值 保证初始序列、修改询问区间随机 时刻保证权值在$[0,100000]$中 题解这题并不需要深入挖掘$a_i+bv_i+civ_i$的性质，只需要发现一点： 当$i_1&lt;i_2$且$v_{i_1}&lt;v_{i_2}$时，$i_1$位置不对答案造成贡献 由这个基础而美妙的性质，可以证明随机序列中造成贡献的位置是$O(\\log n)$级别的 具体证明可以考虑一个位置$i$造成贡献，当且仅当后面所有的$j&gt;i$，都有$v_j&lt;v_i$，其概率为$\\frac{1}{n-i+1}$ 因此总和为调和级数，与$O(\\log n)$同阶 如果可以快速的定位到这$O(\\log n)$个位置，这题就做完了 现在考虑如何快速定位： 递归时记录当前区间要求至少要$w$才能产生贡献 如果$w$不小于当前区间最大值，则这个区间不会产生贡献，返回 否则先遍历右儿子，在得到右侧最大答案的同时也得到右侧$v_i$最大值$w_R$ 那么对于左侧的要求就是至少$\\max(w,w_R)$，递归左侧 如果当前节点是叶子结点，就说明定位到一个可能产生贡献的位置 这样定位$O(\\log n)$个位置的时间复杂度是$O(\\log^2 n)$ 总时间复杂度为$O((n+m)\\log n+Q\\log^2 n)$ 其中$Q$表示询问个数（非修改），不超过$100000$ Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;cstdio&gt;int n,m,x0;const int mod=998244353;inline int gene()&#123;return (x0=static_cast&lt;int&gt;((100000005LL*x0+20150609)%998244353))/100;&#125;struct SegmentTree&#123; int max[400000],min[400000]; bool tag[400000]; inline void puttag(int o)&#123;std::swap(max[o]=100000-max[o],min[o]=100000-min[o]),tag[o]^=1;&#125; inline void pushdown(int o)&#123;if (tag[o]) puttag(o&lt;&lt;1),puttag(o&lt;&lt;1|1),tag[o]^=1;&#125; inline void update(int o)&#123; max[o]=std::max(max[o&lt;&lt;1],max[o&lt;&lt;1|1]); min[o]=std::min(min[o&lt;&lt;1],min[o&lt;&lt;1|1]); &#125; void init(int o,int l,int r)&#123; if (l==r) max[o]=min[o]=gene()%100001; else&#123; int mdl=(l+r)&gt;&gt;1; init(o&lt;&lt;1,l,mdl),init(o&lt;&lt;1|1,mdl+1,r); update(o); &#125; &#125; std::pair&lt;long long,int&gt; query(int o,int l,int r,int L,int R,int a,int b,int c,int lim)&#123; if (l&gt;R||r&lt;L||max[o]&lt;=lim) return std::make_pair(0LL,0); if (l==r) return std::make_pair(static_cast&lt;long long&gt;(a)*l+static_cast&lt;long long&gt;(b)*max[o]+static_cast&lt;long long&gt;(c)*l*max[o],max[o]); pushdown(o); int mdl=(l+r)&gt;&gt;1; std::pair&lt;long long,int&gt; resR=query(o&lt;&lt;1|1,mdl+1,r,L,R,a,b,c,lim); std::pair&lt;long long,int&gt; resL=query(o&lt;&lt;1,l,mdl,L,R,a,b,c,std::max(lim,resR.second)); return std::make_pair(std::max(resR.first,resL.first),std::max(resR.second,resL.second)); &#125; void flip(int o,int l,int r,int L,int R)&#123; if (l&gt;R||r&lt;L) return; if (L&lt;=l&amp;&amp;r&lt;=R)&#123;puttag(o);return;&#125; pushdown(o); int mdl=(l+r)&gt;&gt;1; flip(o&lt;&lt;1,l,mdl,L,R); flip(o&lt;&lt;1|1,mdl+1,r,L,R); update(o); &#125; void modify(int o,int l,int r,int k,int v)&#123; if (l==r) max[o]=min[o]=v; else&#123; pushdown(o); int mdl=(l+r)&gt;&gt;1; if (k&lt;=mdl) modify(o&lt;&lt;1,l,mdl,k,v); else modify(o&lt;&lt;1|1,mdl+1,r,k,v); update(o); &#125; &#125;&#125;T;char opt;int main()&#123; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;x0); T.init(1,1,n); while (m--)&#123; while (isspace(opt=getchar())); if (opt=='C')&#123; int p=gene()%n+1,y=gene()%100001; T.modify(1,1,n,p,y); &#125; else if (opt=='R')&#123; int p=gene()%n+1,q=gene()%n+1; if (p&gt;q) std::swap(p,q); T.flip(1,1,n,p,q); &#125; else&#123; int a,b,c,p=gene()%n+1,q=gene()%n+1; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); if (p&gt;q) std::swap(p,q); printf(\"%lld\\n\",T.query(1,1,n,p,q,a,b,c,0).first); &#125; &#125;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://ytxytx.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"UOJ 46 【清华集训2014】玄学","slug":"uoj46","date":"2019-10-17T02:05:17.000Z","updated":"2019-10-26T03:07:06.000Z","comments":true,"path":"2019/10/17/uoj46/","link":"","permalink":"https://ytxytx.github.io/2019/10/17/uoj46/","excerpt":"题目描述给定初始长度为$n$的序列$A_i$ 支持追加一个操作：将$[L,R]$的区间变为$ax+b$ 支持询问：如果按顺序执行编号在$[L,R]$的操作，那么$k$位置上的数变为多少 强制在线","text":"题目描述给定初始长度为$n$的序列$A_i$ 支持追加一个操作：将$[L,R]$的区间变为$ax+b$ 支持询问：如果按顺序执行编号在$[L,R]$的操作，那么$k$位置上的数变为多少 强制在线 题解对时间建出线段树，每个节点储存“进行完这个节点对应时间区间的操作后，序列每一个位置变化为$ax+b$（合并tag）” 但是记录整个序列的变化太浪费了，因为序列可能有很长一段的操作是完全相同的 那么改进一下，每个节点储存“进行完这个节点对应时间区间的操作后，序列相同操作的每一段变化为$ax+b$” 这样，对于一个时刻的操作（线段树的叶子节点），至多被分为$3$段 而对于非叶子节点，可以由左右子节点的信息归并得到 这题加上的强制在线的限制，那么就将操作逐个加入时间线段树，如果一个非叶子节点的左右儿子都满了，就将左右儿子的信息归并 询问就在时间线段树上询问，对于完整包含的节点，二分确定查询的位置在哪个段，然后返回那段区间的tag即可 时间复杂度$O(Q\\log Q\\log n)$ Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;int n,Q,mod,A[200000];struct SegmentTree&#123; std::vector&lt;std::pair&lt;int,std::pair&lt;int,int&gt; &gt; &gt; V[2400000]; inline std::pair&lt;int,int&gt; Merge(const std::pair&lt;int,int&gt; &amp;A,const std::pair&lt;int,int&gt; &amp;B)&#123;return std::make_pair(static_cast&lt;long long&gt;(A.first)*B.first%mod,(static_cast&lt;long long&gt;(A.second)*B.first+B.second)%mod);&#125; void update(int o)&#123; int L=0,R=0; while (L&lt;V[o&lt;&lt;1].size()&amp;&amp;R&lt;V[o&lt;&lt;1|1].size())&#123; if (V[o&lt;&lt;1][L].first==V[o&lt;&lt;1|1][R].first) V[o].push_back(std::make_pair(V[o&lt;&lt;1][L].first,Merge(V[o&lt;&lt;1][L].second,V[o&lt;&lt;1|1][R].second))),L++,R++; else if (V[o&lt;&lt;1][L].first&lt;V[o&lt;&lt;1|1][R].first) V[o].push_back(std::make_pair(V[o&lt;&lt;1][L].first,Merge(V[o&lt;&lt;1][L].second,V[o&lt;&lt;1|1][R-1].second))),L++; else V[o].push_back(std::make_pair(V[o&lt;&lt;1|1][R].first,Merge(V[o&lt;&lt;1][L-1].second,V[o&lt;&lt;1|1][R].second))),R++; &#125; while (L&lt;V[o&lt;&lt;1].size()) V[o].push_back(std::make_pair(V[o&lt;&lt;1][L].first,Merge(V[o&lt;&lt;1][L].second,V[o&lt;&lt;1|1][R-1].second))),L++; while (R&lt;V[o&lt;&lt;1|1].size()) V[o].push_back(std::make_pair(V[o&lt;&lt;1|1][R].first,Merge(V[o&lt;&lt;1][L-1].second,V[o&lt;&lt;1|1][R].second))),R++; &#125; void append(int o,int l,int r,int z,int L,int R,int a,int b)&#123; if (l==r)&#123; if (L!=1) V[o].push_back(std::make_pair(1,std::make_pair(1,0))); V[o].push_back(std::make_pair(L,std::make_pair(a,b))); if (R!=n) V[o].push_back(std::make_pair(R+1,std::make_pair(1,0))); return; &#125; int mdl=(l+r)&gt;&gt;1; if (z&lt;=mdl) append(o&lt;&lt;1,l,mdl,z,L,R,a,b); else append(o&lt;&lt;1|1,mdl+1,r,z,L,R,a,b); if (z==r) update(o); &#125; std::pair&lt;int,int&gt; query(int o,int l,int r,int L,int R,int k)&#123; if (l&gt;R||r&lt;L) return std::make_pair(1,0); if (L&lt;=l&amp;&amp;r&lt;=R) return std::prev(std::lower_bound(V[o].begin(),V[o].end(),std::make_pair(k+1,std::make_pair(0,0))))-&gt;second; int mdl=(l+r)&gt;&gt;1; return Merge(query(o&lt;&lt;1,l,mdl,L,R,k),query(o&lt;&lt;1|1,mdl+1,r,L,R,k)); &#125;&#125;T;int Type,top,opt,x,y,z,u,lastans;int main()&#123; scanf(\"%d\",&amp;Type),Type&amp;=1; scanf(\"%d%d\",&amp;n,&amp;mod); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;A[i]); scanf(\"%d\",&amp;Q); for (int tim=1;tim&lt;=Q;tim++)&#123; scanf(\"%d\",&amp;opt); if (opt==1)&#123; scanf(\"%d%d%d%d\",&amp;x,&amp;y,&amp;z,&amp;u); if (Type) x^=lastans,y^=lastans; T.append(1,1,Q,++top,x,y,z,u); &#125; else&#123; scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z); if (Type) x^=lastans,y^=lastans,z^=lastans; std::pair&lt;int,int&gt; res=T.query(1,1,Q,x,y,z); printf(\"%d\\n\",lastans=(static_cast&lt;long long&gt;(res.first)*A[z]+res.second)%mod); &#125; &#125;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://ytxytx.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"lydsy 2653 middle","slug":"lydsy2653","date":"2019-10-14T10:18:19.000Z","updated":"2019-10-26T03:07:04.000Z","comments":true,"path":"2019/10/14/lydsy2653/","link":"","permalink":"https://ytxytx.github.io/2019/10/14/lydsy2653/","excerpt":"题目描述给出长度为$n$的整数序列$A$ 多次询问所有左端点在$[a,b]$，右端点在$[c,d]$的连续子序列中，中位数最大是多少$(1\\leq a&lt;b&lt;c\\leq n)$ 强制在线","text":"题目描述给出长度为$n$的整数序列$A$ 多次询问所有左端点在$[a,b]$，右端点在$[c,d]$的连续子序列中，中位数最大是多少$(1\\leq a&lt;b&lt;c\\leq n)$ 强制在线 题解首先离散化 对于一次询问$a,b,c,d$，考虑二分答案$w$ 假设将数列中所有$\\geq w$的数标为$+1$，所有$&lt;w$的数标为$-1$ 那么只需要检验，所有左端点在$[a,b]$，右端点在$[c,d]$的连续子序列和，最大是否超过了$0$（此处有细节，可能是$-1$或$1$），以此来判断答案需要减小或增大 称此时的$\\pm 1$序列为关于$w$的序列 为了得到最大的满足条件的子序列和，需要用线段树维护区间的最大前缀、最大后缀、区间和 为了得到所有关于$i$的序列的线段树，可以使用主席树预处理上述信息 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;vector&gt;int n;int V[30000],tmp[30000],tmptop,lstans,Q;struct SegmentTree&#123; struct data&#123; int premax,sufmax,sum; data()&#123;premax=sufmax=sum=0;&#125; data(int premax_,int sufmax_,int sum_)&#123;premax=premax_,sufmax=sufmax_,sum=sum_;&#125; inline data operator + (const data &amp;T)&#123;return data(std::max(premax,sum+T.premax),std::max(T.sufmax,T.sum+sufmax),sum+T.sum);&#125; &#125;; struct node&#123; int L,R; data D; node()&#123;L=R=0;&#125; &#125;T[10000000]; int tot; SegmentTree()&#123;tot=0;&#125; void update(int o)&#123;T[o].D=T[T[o].L].D+T[T[o].R].D;&#125; void init(int &amp;o,int l,int r)&#123; int nxt=++tot; T[nxt]=T[o],o=nxt; if (l==r)&#123;T[nxt].D=data(1,1,1);return;&#125; int mdl=(l+r)&gt;&gt;1; init(T[o].L,l,mdl),init(T[o].R,mdl+1,r); update(o); &#125; void modify(int &amp;o,int l,int r,int k)&#123; int nxt=++tot; T[nxt]=T[o],o=nxt; if (l==r)&#123;T[nxt].D=data(-1,-1,-1);return;&#125; int mdl=(l+r)&gt;&gt;1; if (k&lt;=mdl) modify(T[o].L,l,mdl,k); else modify(T[o].R,mdl+1,r,k); update(o); &#125; data query(int o,int l,int r,int L,int R)&#123; if (L&lt;=l&amp;&amp;r&lt;=R) return T[o].D; int mdl=(l+r)&gt;&gt;1; if (L&lt;=mdl&amp;&amp;mdl&lt;R) return query(T[o].L,l,mdl,L,R)+query(T[o].R,mdl+1,r,L,R); else if (L&lt;=mdl) return query(T[o].L,l,mdl,L,R); else return query(T[o].R,mdl+1,r,L,R); &#125; int sum(int o,int l,int r,int L,int R)&#123; if (l&gt;R||r&lt;L||L&gt;R) return 0; if (L&lt;=l&amp;&amp;r&lt;=R) return T[o].D.sum; int mdl=(l+r)&gt;&gt;1; return sum(T[o].L,l,mdl,L,R)+sum(T[o].R,mdl+1,r,L,R); &#125;&#125;T;int a[4],root[30000];std::vector&lt;int&gt; C[30000];int main()&#123; scanf(\"%d\",&amp;n); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;V[i]),tmp[i]=V[i]; std::sort(tmp+1,tmp+n+1); tmptop=std::unique(tmp+1,tmp+n+1)-tmp-1; for (int i=1;i&lt;=n;i++) V[i]=std::lower_bound(tmp+1,tmp+tmptop+1,V[i])-tmp,C[V[i]].push_back(i); T.init(root[1],1,n); for (int i=1;i&lt;tmptop;i++)&#123; root[i+1]=root[i]; for (std::vector&lt;int&gt;::iterator it=C[i].begin();it!=C[i].end();++it) T.modify(root[i+1],1,n,*it); &#125; scanf(\"%d\",&amp;Q); while (Q--)&#123; scanf(\"%d%d%d%d\",&amp;a[0],&amp;a[1],&amp;a[2],&amp;a[3]); a[0]=(a[0]+lstans)%n+1,a[1]=(a[1]+lstans)%n+1,a[2]=(a[2]+lstans)%n+1,a[3]=(a[3]+lstans)%n+1; std::sort(a,a+4); int L=1,R=tmptop,mdl; while (L&lt;R)&#123; mdl=(L+R+1)&gt;&gt;1; SegmentTree::data Ldata=T.query(root[mdl],1,n,a[0],a[1]),Rdata=T.query(root[mdl],1,n,a[2],a[3]); int Mdata=T.sum(root[mdl],1,n,a[1]+1,a[2]-1); int mx=Ldata.sufmax+Mdata+Rdata.premax; if (mx&lt;0) R=mdl-1; else L=mdl; &#125; printf(\"%d\\n\",lstans=tmp[L]); &#125;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://ytxytx.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"二分答案","slug":"二分答案","permalink":"https://ytxytx.github.io/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"}]},{"title":"[HNOI2008]Cards","slug":"lydsy1004","date":"2019-10-12T06:04:22.000Z","updated":"2019-10-26T03:07:01.000Z","comments":true,"path":"2019/10/12/lydsy1004/","link":"","permalink":"https://ytxytx.github.io/2019/10/12/lydsy1004/","excerpt":"题目描述给出一个$m$阶置换群$G$（如果缺少幺元则自己补上） 要求用红绿蓝三种颜色染色，且三种颜色的元素个数要恰好分别为$S_r,S_g,S_b$ 求在置换群作用下本质不同的染色方案数","text":"题目描述给出一个$m$阶置换群$G$（如果缺少幺元则自己补上） 要求用红绿蓝三种颜色染色，且三种颜色的元素个数要恰好分别为$S_r,S_g,S_b$ 求在置换群作用下本质不同的染色方案数 题解直接使用 Pólya 定理的生成函数形式，令三种颜色的形式变元为$r,g,b$ $$ Ans=\\frac{1}{m}\\sum_{f\\in G}|C_f| $$ 其中$C_f$表示在$f$的作用下不动合法染色集合 现在考虑如何求$|C_f|$ 假设$f$被循环分解为大小为$t_1,t_2,\\cdots,t_k$的循环 那么$|C_f|=[r^{S_r}g^{S_g}b^{S_b}]\\prod_{i=1}^{k}(r^{t_i}+g^{t_i}+b^{t_i})$ 上面的式子可以用类似dp的方法求出（每次乘上$r^{t_i}+g^{t_i}+b^{t_i}$） Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cassert&gt;int Sr,Sb,Sg,m,P,n;int pow(int a,int b)&#123; int ret=1; for (;b;b&gt;&gt;=1,a=a*a%P) if (b&amp;1) ret=ret*a%P; return ret;&#125;int G[70],ans;int dp[70][70][70];bool vis[70];inline void up(int &amp;A,int B)&#123;A=(A+B)%P;&#125;bool have,havetmp;int main()&#123; scanf(\"%d%d%d%d%d\",&amp;Sr,&amp;Sb,&amp;Sg,&amp;m,&amp;P),n=Sr+Sb+Sg; for (int i=1;i&lt;=m;i++)&#123; memset(vis,0,sizeof(bool)*(n+1)); memset(dp,0,sizeof(dp)); dp[0][0][0]=1; int sum=0; havetmp=true; for (int j=1;j&lt;=n;j++) scanf(\"%d\",&amp;G[j]),havetmp&amp;=(G[j]==j); have|=havetmp; for (int j=1;j&lt;=n;j++)&#123; if (vis[j]) continue; int len=0; for (int now=j;!vis[now];now=G[now]) len++,vis[now]=true; for (int k=0;k&lt;=sum;k++)&#123; for (int l=0;l&lt;=sum-k;l++)&#123; int p=(sum-k-l); up(dp[k+len][l][p],dp[k][l][p]); up(dp[k][l+len][p],dp[k][l][p]); up(dp[k][l][p+len],dp[k][l][p]); &#125; &#125; sum+=len; &#125; up(ans,dp[Sr][Sb][Sg]); &#125; if (!have)&#123; memset(vis,0,sizeof(bool)*(n+1)); memset(dp,0,sizeof(dp)); dp[0][0][0]=1; int sum=0; for (int j=1;j&lt;=n;j++) G[j]=j; for (int j=1;j&lt;=n;j++)&#123; if (vis[j]) continue; int len=0; for (int now=j;!vis[now];now=G[now]) len++,vis[now]=true; for (int k=0;k&lt;=sum;k++)&#123; for (int l=0;l&lt;=sum-k;l++)&#123; int p=(sum-k-l); up(dp[k+len][l][p],dp[k][l][p]); up(dp[k][l+len][p],dp[k][l][p]); up(dp[k][l][p+len],dp[k][l][p]); &#125; &#125; sum+=len; &#125; up(ans,dp[Sr][Sb][Sg]); printf(\"%d\\n\",ans*pow(m+1,P-2)%P); &#125; else printf(\"%d\\n\",ans*pow(m,P-2)%P);&#125;","categories":[],"tags":[{"name":"生成函数","slug":"生成函数","permalink":"https://ytxytx.github.io/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"},{"name":"Pólya 定理","slug":"Polya-定理","permalink":"https://ytxytx.github.io/tags/Polya-%E5%AE%9A%E7%90%86/"}]},{"title":"LOJ 6519 魔力环","slug":"loj6519","date":"2019-10-11T13:27:38.000Z","updated":"2019-10-26T03:06:58.000Z","comments":true,"path":"2019/10/11/loj6519/","link":"","permalink":"https://ytxytx.github.io/2019/10/11/loj6519/","excerpt":"题目描述一个项链被称为合法的，当且仅当： 其包含$n$个珠子，恰好$m$个黑珠子$n-m$个白珠子 最长连续黑珠子段长度不超过$k$ 两个项链被认为相同当且仅当可以通过旋转使项链完全一致 求有多少种不同的合法项链","text":"题目描述一个项链被称为合法的，当且仅当： 其包含$n$个珠子，恰好$m$个黑珠子$n-m$个白珠子 最长连续黑珠子段长度不超过$k$ 两个项链被认为相同当且仅当可以通过旋转使项链完全一致 求有多少种不同的合法项链 题解由于是旋转，考虑用 Burnside 引理，统计每一种旋转下的不动染色个数 枚举旋转量，如果旋转了$i$个单位，那么项链会以$\\gcd(i,n)$为周期 对于每个周期，可以破环为链进行计算 令$F_{d,p,k}$表示长度为$d$的链中，有$p$个黑珠子，且最长连续段不超过$k$的方案数（但由于是周期，所以相当于首尾相接） $$\\begin{aligned}Ans&amp;=\\sum_{i=1}^{n}[n|m\\gcd(i,n)]F_{\\gcd(i,n),m\\gcd(i,n)/n,k} \\\\&amp;=\\sum_{g=1}^{n}[n|mg]F_{g,m*g/n,k}\\sum_{i=1}^{n}[\\gcd(i,n)=g] \\\\&amp;=\\sum_{g|n}[n|m*g]F_{g,mg/n,k}\\varphi(\\frac{n}{g})\\end{aligned}$$ 做到这步，接下来的重点放在求$F_{d,p,k}$ 如果以所有$w=d-p$个白珠子为分割，连续黑珠子的长度记作$x$ 那么满足以下条件 $$\\begin{cases}x_0+x_1+\\cdots+x_w=p \\\\0\\leq x_1,x_2,\\cdots,x_{w-1}\\leq k \\\\0\\leq x_0+x_w\\leq k\\end{cases}$$ 注意到最后一个条件是由于周期收尾相接导致的 上述方程整数解与方案一一对应，因此只需要求上述方程的解数 对于$x_{1..w-1}$，构造生成函数 $$ G_k(x)=\\sum_{i=0}^{k}x^i=\\frac{1-x^{k+1}}{1-x} $$ 对于$x_0+x_w$，构造生成函数 $$\\begin{aligned}H_k(x)&amp;=\\sum_{i=0}^{k}(i+1)x^i \\\\&amp;=\\frac{\\mathrm{d}}{\\mathrm{d}x}\\sum_{i=0}^{k}x^{k+1} \\\\&amp;=\\frac{\\mathrm{d}}{\\mathrm{d}x}(\\frac{x^{k+2}-1}{x-1}-1) \\\\&amp;=\\frac{(k+1)x^{k+2}-(k+2)x^{k+1}+1}{(1-x)^2}\\end{aligned}$$ 那么 $$\\begin{aligned}F_{d,p,k}&amp;=[x^p]G_k^{w-1}(x)H_k(x) \\\\&amp;=[x^p]\\left(\\frac{1-x^{k+1}}{1-x}\\right)^{w-1}\\frac{(k+1)x^{k+2}-(k+2)x^{k+1}+1}{(1-x)^2} \\\\&amp;=[x^p]\\left((k+1)x^{k+2}-(k+2)x^{k+1}+1\\right)\\frac{(1-x^{k+1})^{w-1}}{(1-x)^{w+1}}\\end{aligned}$$ 转化为求出右侧的$x^p,x^{p-k-1},x^{p-k-2}$次项 $$\\begin{aligned}[x^a]\\frac{(1-x^{k+1})^{w-1}}{(1-x)^{w+1}}&amp;=[x^a]\\left(\\sum_{i=0}^{\\infty}\\binom{w-1}{i}(-x^{k+1})^i\\right)\\cdot\\left(\\sum_{i=0}^{\\infty}\\binom{w+i}{i}x^i\\right) \\\\&amp;=\\sum_{i=0}^{\\lfloor\\frac{a}{k+1}\\rfloor}\\binom{w-1}{a}(-1)^a\\cdot \\binom{w+a(k+1)-i}{a(k+1)-i}\\end{aligned}$$ 这个式子可以在$O(\\frac{a}{k+1})$的时间计算 由一开始的推导，需要对所有$d|n$计算$F_{d,\\cdots}$ 计算量大约是$\\sum_{d|n}\\frac{d}{k+1}=O(\\frac{\\sigma(n)}{k+1})$，绰绰有余 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;cstdio&gt;int n,m,k;const int mod=998244353;inline void chkinc(int &amp;C)&#123;C+=C&gt;&gt;31&amp;mod;&#125;inline int pow(int a,int b)&#123; int ret=1; for (;b;b&gt;&gt;=1,a=static_cast&lt;long long&gt;(a)*a%mod) if (b&amp;1) ret=static_cast&lt;long long&gt;(ret)*a%mod; return ret;&#125;int primes[10],pcnt[10],ptop,tmp;int val[1000],vphi[1000],vtop;void dfs(int now,int v=1,int p=1)&#123; if (now&gt;ptop)&#123; val[++vtop]=v; vphi[vtop]=p; return; &#125; dfs(now+1,v,p); dfs(now+1,v*=primes[now],p*=primes[now]-1); for (int i=2;i&lt;=pcnt[now];i++) dfs(now+1,v*=primes[now],p*=primes[now]);&#125;int ans;int fact[200050],ifact[200050];int C(int n,int m)&#123; if (n&lt;m) return 0; return static_cast&lt;long long&gt;(fact[n])*ifact[m]%mod*ifact[n-m]%mod;&#125;int calcpre(int p,int w,int k)&#123; int ret=0; const int lim=p/(k+1); for (int i=0;i&lt;=lim;i++) ret=(ret+((i&amp;1)?mod-1LL:1LL)*C(w-1,i)%mod*C(w+p-(k+1)*i,p-(k+1)*i))%mod; return ret;&#125;int calc(int d,int p,int k)&#123; int ret=calcpre(p,d-p,k); if (p&gt;=k+2) ret=(ret+(k+1LL)*calcpre(p-k-2,d-p,k))%mod; if (p&gt;=k+1) ret=(ret-(k+2LL)*calcpre(p-k-1,d-p,k)%mod+mod)%mod; return ret;&#125;int main()&#123; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;k); fact[0]=1; for (int i=1;i&lt;=n+n;i++) fact[i]=static_cast&lt;long long&gt;(fact[i-1])*i%mod; ifact[n+n]=pow(fact[n+n],mod-2); for (int i=n+n;i;i--) ifact[i-1]=static_cast&lt;long long&gt;(ifact[i])*i%mod; tmp=n; for (int i=2;i*i&lt;=n;i++)&#123; if (!(tmp%i)) primes[++ptop]=i; while (!(tmp%i)) tmp/=i,pcnt[ptop]++; &#125; if (tmp&gt;1) primes[++ptop]=tmp,pcnt[ptop]=1; dfs(1); for (int i=1;i&lt;=vtop;i++)&#123; if (static_cast&lt;long long&gt;(m)*val[i]%n) continue; ans=(ans+static_cast&lt;long long&gt;(vphi[vtop-i+1])*calc(val[i],m/val[vtop-i+1],k))%mod; &#125; printf(\"%lld\\n\",static_cast&lt;long long&gt;(ans)*pow(n,mod-2)%mod);&#125;","categories":[],"tags":[{"name":"Burnside 引理","slug":"Burnside-引理","permalink":"https://ytxytx.github.io/tags/Burnside-%E5%BC%95%E7%90%86/"},{"name":"生成函数","slug":"生成函数","permalink":"https://ytxytx.github.io/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"}]},{"title":"付公主的背包","slug":"luogu4389","date":"2019-10-10T02:40:31.000Z","updated":"2019-10-28T11:39:52.000Z","comments":true,"path":"2019/10/10/luogu4389/","link":"","permalink":"https://ytxytx.github.io/2019/10/10/luogu4389/","excerpt":"题目描述给定每个物品的大小$v_i$，每种物品有无穷个 求大小恰好为$s$的方案数，对所有$1\\leq s\\leq m$输出","text":"题目描述给定每个物品的大小$v_i$，每种物品有无穷个 求大小恰好为$s$的方案数，对所有$1\\leq s\\leq m$输出 题解一个大小为$v_i$的物品，其生成函数为 $$ f_{v_i}(x)=\\sum_{j=0}^{\\infty} x^{jv_i}=\\frac{1}{1-x^{v_i}} $$ 答案就是 $$ A(x)=\\prod_{i=1}^{n}f_{v_i}(x) $$ 的$1\\sim m$次项系数 $$ A(x)=\\prod_{i=1}^{n}f_{v_i}(x)=\\frac{1}{\\prod_{i=1}^{n}(1-x^{v_i})} $$ 接下来考虑求$G(x)=\\prod_{i=1}^{n}(1-x^{v_i})$ $$ G(x)=\\prod_{i=1}^{n}(1-x^{v_i})=\\exp\\left(\\ln\\left(\\prod_{i=1}^{n}(1-x^{v_i})\\right)\\right)=\\exp\\left(\\sum_{i=1}^{n}\\ln(1-x^{v_i})\\right) $$ 由于 $$ \\ln(1-x^k)=-\\sum_{i=1}^{\\infty}\\frac{x^{ik}}{i} $$ 对于不超过$m$次项只有$\\lfloor \\frac{m}{k}\\rfloor$项是有值的 因此对于相同的$v_i$一起计算，一共只需计算$O(m\\log m)$项（调和级数） 只要求得了$\\sum_{i=1}^{n}\\ln(1-x^{v_i})$，再$\\exp$一下就做完了 时间复杂度$O(n+m\\log m)$ Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;int n,m;const int mod=998244353;inline int pow(int a,int b,int mod=::mod)&#123; int ret=1; for (;b;b&gt;&gt;=1,a=static_cast&lt;long long&gt;(a)*a%mod) if (b&amp;1) ret=static_cast&lt;long long&gt;(ret)*a%mod; return ret;&#125;inline void chkinc(int &amp;C)&#123;C+=C&gt;&gt;31&amp;mod;&#125;namespace polyspace&#123; typedef std::vector&lt;int&gt; poly; const int MAXN=400000; int wn[MAXN],w[MAXN],rev[MAXN],lims,lim,inv[MAXN]; void FFTinit(int n)&#123; wn[0]=lim=1,lims=-1; while (lim&lt;n) lim&lt;&lt;=1,lims++; for (int i=1;i&lt;lim;i++) rev[i]=rev[i&gt;&gt;1]&gt;&gt;1|(i&amp;1)&lt;&lt;lims; for (int i=1,g=pow(3,mod/lim);i&lt;lim;i++) wn[i]=static_cast&lt;long long&gt;(wn[i-1])*g%mod; &#125; void FFT(int *V,int f)&#123; for (int i=0;i&lt;lim;i++) if (rev[i]&gt;i) std::swap(V[rev[i]],V[i]); for (int i=1;i&lt;lim;i&lt;&lt;=1)&#123; for (int j=0,t=lim/i/2;j&lt;i;j++) w[j]=wn[j*t]; for (int j=0;j&lt;lim;j+=i+i)&#123; for (int k=0;k&lt;i;k++)&#123; const int X=V[j+k],Y=static_cast&lt;long long&gt;(w[k])*V[i+j+k]%mod; chkinc(V[j+k]+=Y-mod),chkinc(V[i+j+k]=X-Y); &#125; &#125; &#125; if (!f)&#123; std::reverse(V+1,V+lim); const int invlim=pow(lim,mod-2); for (int i=0;i&lt;lim;i++) V[i]=static_cast&lt;long long&gt;(invlim)*V[i]%mod; &#125; &#125; poly &amp; operator += (poly &amp;A,const poly &amp;B)&#123; if (A.size()&lt;B.size()) A.resize(B.size()); for (int i=0;i&lt;B.size();i++) chkinc(A[i]+=B[i]-mod); return A; &#125; poly &amp; operator -= (poly &amp;A,const poly &amp;B)&#123; if (A.size()&lt;B.size()) A.resize(B.size()); for (int i=0;i&lt;B.size();i++) chkinc(A[i]-=B[i]); return A; &#125; poly operator + (poly A,const poly &amp;B)&#123;return A+=B;&#125; poly operator - (poly A,const poly &amp;B)&#123;return A-=B;&#125; poly operator * (poly A,poly B)&#123; int N=A.size()+B.size()-1; FFTinit(N); A.resize(lim),B.resize(lim); FFT(A.data(),1),FFT(B.data(),1); for (int i=0;i&lt;lim;i++) A[i]=static_cast&lt;long long&gt;(A[i])*B[i]%mod; FFT(A.data(),0); A.resize(N); return A; &#125; poly &amp; operator *= (poly &amp;A,const poly &amp;B)&#123;return A=A*B;&#125; poly Inv(poly A,int n)&#123; A.resize(n); if (n==1) return poly&#123;pow(A[0],mod-2)&#125;; else&#123; const int nxt=(n+1)&gt;&gt;1; poly ret=Inv(A,nxt),tmp=ret; FFTinit(n*3/2); tmp.resize(lim); A.resize(lim); FFT(tmp.data(),1),FFT(A.data(),1); for (int i=0;i&lt;lim;i++) chkinc(A[i]=-static_cast&lt;long long&gt;(A[i])*tmp[i]%mod*tmp[i]%mod); FFT(A.data(),0); ret.insert(ret.end(),A.begin()+nxt,A.begin()+n); return ret; &#125; &#125; poly Int(poly A)&#123; for (int i=1;i&lt;A.size();i++) A[i-1]=static_cast&lt;long long&gt;(A[i])*i%mod; A.pop_back(); return A; &#125; poly Der(poly A)&#123; A.push_back(0); for (int i=A.size()-1;i;i--) A[i]=static_cast&lt;long long&gt;(A[i-1])*inv[i]%mod; A[0]=0; return A; &#125; void __attribute__((constructor)) initfact()&#123; inv[1]=1; for (int i=2;i&lt;MAXN;i++) inv[i]=(mod-mod/i)*static_cast&lt;long long&gt;(inv[mod%i])%mod; &#125; poly Ln(poly A,int n)&#123; poly ret=Der(Int(A)*Inv(A,n)); ret.resize(n); return ret; &#125; poly Exp(poly A,int n)&#123; A.resize(n); if (n==1) return poly&#123;1&#125;; else&#123; const int nxt=(n+1)&gt;&gt;1; poly ret=Exp(A,nxt); ret=ret*(A-Ln(ret,n)+poly&#123;1&#125;); ret.resize(n); return ret; &#125; &#125;&#125;using namespace polyspace;int V[MAXN],cnt[MAXN];poly cc,tmp;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;V[i]),cnt[V[i]]++; cc.resize(m+1); for (int i=1;i&lt;=m;i++) for (int j=0,t=0;j&lt;=m;j+=i,t++) cc[j]=(cc[j]+cnt[i]*static_cast&lt;long long&gt;(inv[t]))%mod; cc=Exp(cc,m+1); for (int i=1;i&lt;=m;i++) printf(\"%d\\n\",cc[i]);&#125;","categories":[],"tags":[{"name":"FFT 快速傅里叶变换","slug":"FFT-快速傅里叶变换","permalink":"https://ytxytx.github.io/tags/FFT-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"}]},{"title":"AGC031D A Sequence of Permutations","slug":"agc031d","date":"2019-10-09T07:23:35.000Z","updated":"2019-10-26T03:06:48.000Z","comments":true,"path":"2019/10/09/agc031d/","link":"","permalink":"https://ytxytx.github.io/2019/10/09/agc031d/","excerpt":"题目描述给定排列$a_1=p$和$a_2=q$ 定义排列$u,v$的函数$f(u,v)$的结果是排列，满足$u_i$下标的数为$v_i$ 规定$a_n=f(a_{n-1},a_{n-2})$ 求$a_m$","text":"题目描述给定排列$a_1=p$和$a_2=q$ 定义排列$u,v$的函数$f(u,v)$的结果是排列，满足$u_i$下标的数为$v_i$ 规定$a_n=f(a_{n-1},a_{n-2})$ 求$a_m$ 题解如果把排列（permutation）看做置换（permutation） 那么可以发现$f(u,v)=v\\circ u^{-1}$ 观察前若干项： $$\\begin{aligned}a_1&amp;=p \\\\a_2&amp;=q \\\\a_3&amp;=q\\circ p^{-1} \\\\a_4&amp;=q\\circ p^{-1}\\circ q^{-1} \\\\a_5&amp;=q\\circ p^{-1}\\circ q^{-1}\\circ p\\circ q^{-1} \\\\a_6&amp;=q\\circ p^{-1}\\circ q^{-1}\\circ p^2\\circ q^{-1} \\\\a_7&amp;=q\\circ p^{-1}\\circ q^{-1}\\circ p\\circ q\\circ p\\circ q^{-1} \\\\a_8&amp;=q\\circ p^{-1}\\circ q^{-1}\\circ p\\circ q\\circ p^{-1}\\circ q\\circ p\\circ q^{-1}\\end{aligned}$$ 如果令$g=q\\circ p^{-1}\\circ q^{-1}\\circ p$ 可以发现$a_m=g\\circ a_{m-6}\\circ g^{-1}$ 发现结论以后可以容易的归纳证明 如果$m=6a+b,1\\leq b\\leq 6$，那么$a_m=g^a\\circ a_{b}\\circ g^{-a}$ 时间复杂度$O(n)$ Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;namespace PermutationSpace&#123; const int PermutationLen=100000; struct Permutation&#123; int P[PermutationLen+1]; Permutation()&#123;for (int i=0;i&lt;=PermutationLen;i++) P[i]=i;&#125; inline int &amp; operator [] (const int &amp;index)&#123;return P[index];&#125; &#125;; Permutation operator * (Permutation A,Permutation B)&#123; Permutation C; for (int i=1;i&lt;=PermutationLen;i++) C[i]=A[B[i]]; return C; &#125; Permutation Inv(Permutation C)&#123; Permutation D; for (int i=1;i&lt;=PermutationLen;i++) D[C[i]]=i; return D; &#125; Permutation Pow(Permutation D,int p)&#123; bool vis[PermutationLen+1]; int stk[PermutationLen],top; Permutation E; memset(vis,0,sizeof(vis)); for (int i=1;i&lt;=PermutationLen;i++)&#123; if (vis[i]) continue; top=0; for (int now=i;!vis[now];now=D[now]) stk[top++]=now,vis[now]=true; for (int j=0;j&lt;top;j++) E[stk[j]]=stk[(j+p)%top]; &#125; return E; &#125;&#125;using namespace PermutationSpace;Permutation A[6],G;int n,m;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;A[1][i]); for (int j=1;j&lt;=n;j++) scanf(\"%d\",&amp;A[2][j]); A[0]=Inv(A[2])*A[1]; A[3]=A[2]*Inv(A[1]); A[4]=A[3]*Inv(A[2]); A[5]=A[4]*Inv(A[3]); G=A[2]*Inv(A[1])*Inv(A[2])*A[1]; G=Pow(G,m/6)*A[m%6]*Pow(Inv(G),m/6); for (int i=1;i&lt;=n;i++) printf(\"%d \",G[i]);&#125;","categories":[],"tags":[]},{"title":"SPOJ DIVCNT2 Counting Divisors (square)","slug":"spojdivcnt2","date":"2019-10-07T08:02:31.000Z","updated":"2019-10-26T03:06:55.000Z","comments":true,"path":"2019/10/07/spojdivcnt2/","link":"","permalink":"https://ytxytx.github.io/2019/10/07/spojdivcnt2/","excerpt":"题目描述求 $$ S_2(n)=\\sum_{i=1}^{n}\\sigma_0(i^2) $$","text":"题目描述求 $$ S_2(n)=\\sum_{i=1}^{n}\\sigma_0(i^2) $$ 题解首先得到如下结论 $$ \\sigma_0(n^2)=\\sum_{d|n}2^{\\omega(d)} $$ 其中$\\omega(n)$表示$n$的不同质因子个数 可以这么解释： 先从$n$的约数中选择一个$d$ 然后对于$n=p_1^{\\alpha_1}p_2^{\\alpha_2}\\cdots p_k^{\\alpha_k}$，每种质因数要么全部选择（$p_i^{\\alpha_i}$），要么全部不选（$1$），乘到$d$上，可以产生所有$n^2$的约数 $$\\begin{aligned}S_2(n)&amp;=\\sum_{i=1}^{n}\\sum_{d|i}2^{\\omega(d)} \\\\&amp;=\\sum_{d=1}^{n}2^{\\omega(d)}\\lfloor\\frac{n}{d}\\rfloor\\end{aligned}$$ 进一步，考虑$2^{\\omega(n)}$的意义 可以表示$n$的无平方因子的约数个数 $$ 2^{\\omega(n)}=\\sum_{d|n}\\mu^2(d) $$ 于是， $$\\begin{aligned}\\sum_{i=1}^{n}2^{\\omega(i)}&amp;=\\sum_{i=1}^{n}\\sum_{d|i}\\mu^2(i) \\\\&amp;=\\sum_{d=1}^{n}\\mu^2(i)\\lfloor\\frac{n}{d}\\rfloor\\end{aligned}$$ 更进一步，考虑$\\mu^2(n)$如何计算 令$F(n)$表示$n$的最大平方因子的平方根，则 $$\\begin{aligned}\\sum_{i=1}^{n} \\mu^2(n)&amp;=\\sum_{i=1}^{n}[F(n)==1] \\\\&amp;=\\sum_{i=1}^{n}\\sum_{d|F(n)}\\mu(d) \\\\&amp;=\\sum_{i=1}^{n}\\sum_{d^2|n}\\mu(d) \\\\&amp;=\\sum_{d=1}^{\\lfloor\\sqrt{n}\\rfloor}\\mu(d)\\lfloor\\frac{n}{d^2}\\rfloor\\end{aligned}$$ 至此，可以用$\\mu$得到$\\mu^2$的前缀和（直接根号） 用$\\mu^2$得到$2^{\\omega}$的前缀和（整除分块） 再用$2^{\\omega}$得到答案（整除分块） 这三个根号算法套上杜教筛的思想和分析方法就是$O(n^{\\frac{2}{3}})$ 综上，时间复杂度为$O(Tn^{\\frac{2}{3}})$ Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cassert&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;map&gt;struct Array&#123; private: static const int mxsize=1000500; long long fulsize; int div; long long ArrL[mxsize],ArrR[mxsize]; public: inline long long &amp; operator [] (const long long &amp;idx)&#123;return idx&lt;div?ArrL[idx]:ArrR[fulsize/idx];&#125; inline void clear()&#123; memset(ArrL,0,sizeof(long long)*div); memset(ArrR,0,sizeof(long long)*div); &#125; inline void assign(long long n)&#123;fulsize=n,div=sqrtl(n)+1+1e-9;&#125; inline Array()&#123; fulsize=div=0; memset(ArrL,0,sizeof(int)*mxsize); memset(ArrR,0,sizeof(int)*mxsize); &#125;&#125;;namespace numberspace&#123; const int MAXN=70000000; int mu[MAXN],mu2[MAXN],minp[MAXN]; long long poww[MAXN]; int prime[MAXN],tot; long long vallist[2500000],valtot; Array Mu2,Poww; void initsieve(int MAXN=numberspace::MAXN)&#123; mu2[1]=mu[1]=poww[1]=1; for (int i=2;i&lt;MAXN;i++)&#123; if (!minp[i]) prime[++tot]=i,mu2[i]=1,mu[i]=-1,poww[i]=2,minp[i]=i; for (int j=1;i*prime[j]&lt;MAXN;j++)&#123; if (prime[j]==minp[i])&#123; minp[i*prime[j]]=minp[i]; mu2[i*prime[j]]=0; mu[i*prime[j]]=0; poww[i*prime[j]]=poww[i]; break; &#125; minp[i*prime[j]]=prime[j]; mu2[i*prime[j]]=mu2[i]; mu[i*prime[j]]=-mu[i]; poww[i*prime[j]]=poww[i]*2; &#125; &#125; for (int i=2;i&lt;MAXN;i++) mu2[i]+=mu2[i-1],poww[i]+=poww[i-1]; &#125; void duinit(long long n)&#123; valtot=0; Mu2.clear(),Poww.clear(); Mu2.assign(n),Poww.assign(n); for (long long l=1,r;l&lt;=n;l=r+1)&#123; long long div=n/l; r=n/div; vallist[++valtot]=r; &#125; for (int i=1;i&lt;=valtot;i++)&#123; const long long &amp;val=vallist[i]; if (val&lt;MAXN) Mu2[val]=mu2[val],Poww[val]=poww[val]; else&#123; for (long long i=1,t;(t=i*i)&lt;=val;i++) Mu2[val]+=mu[i]*(val/t); for (long long l=1,r;l&lt;=val;l=r+1)&#123; const long long div=val/l; r=val/div,Poww[val]+=(Mu2[r]-Mu2[l-1])*div; &#125; &#125; &#125; &#125;&#125;int T;long long ans,N[10000],Nmax;int main()&#123; scanf(\"%d\",&amp;T); for (int i=0;i&lt;T;i++) scanf(\"%lld\",&amp;N[i]),Nmax=std::max(Nmax,N[i]); numberspace::initsieve(std::min&lt;long long&gt;(Nmax+1,numberspace::MAXN)); for (int i=0;i&lt;T;i++)&#123; numberspace::duinit(N[i]); ans=0; for (long long l=1,r;l&lt;=N[i];l=r+1)&#123; long long div=N[i]/l; r=N[i]/div; ans+=(numberspace::Poww[r]-numberspace::Poww[l-1])*div; &#125; printf(\"%lld\\n\",ans); &#125;&#125;","categories":[],"tags":[{"name":"杜教筛","slug":"杜教筛","permalink":"https://ytxytx.github.io/tags/%E6%9D%9C%E6%95%99%E7%AD%9B/"}]},{"title":"THUWC 2017 在美妙的数学王国中畅游","slug":"loj2289","date":"2019-10-06T07:36:34.000Z","updated":"2019-10-26T03:06:44.000Z","comments":true,"path":"2019/10/06/loj2289/","link":"","permalink":"https://ytxytx.github.io/2019/10/06/loj2289/","excerpt":"题目描述维护一棵动态树，每个节点上有$\\sin(ax+b),e^{ax+b},ax+b$中的一种函数 其中$a,b$是绑定在节点的属性 支持加边删边，单点修改函数类型和属性 询问路径上取$x_0$的函数值之和","text":"题目描述维护一棵动态树，每个节点上有$\\sin(ax+b),e^{ax+b},ax+b$中的一种函数 其中$a,b$是绑定在节点的属性 支持加边删边，单点修改函数类型和属性 询问路径上取$x_0$的函数值之和 题解在题面下方给出了函数的泰勒展开式： $$ f(x)=f(x_0)+\\frac{f’(x_0)(x-x_0)}{1!}+\\frac{f’’(x_0)(x-x_0)^2}{2!}+ \\cdots +\\frac{f^{(n)}(\\xi)(x-x_0)^n}{n!} $$ 取$x_0=0$，可以得到 $$ \\sin(ax+b)=\\sin(b)+\\frac{\\cos(b)ax}{1!}-\\frac{\\sin(b)a^2x^2}{2!}-\\frac{\\cos(b)a^3x^3}{3!}+\\frac{\\sin(b)a^4x^4}{4!}+\\cdots $$ $$ e^{ax+b}=e^b(1+\\frac{ax}{1!}+\\frac{a^2x^2}{2!}+\\frac{a^3x^3}{3!}+\\cdots) $$ 而对于一次函数不作处理 大约只需要取次数不超过$12$的项就可以得到精度极高的近似值 剩下的只需要用LCT维护，链上泰勒展开后函数和，带入询问值即可 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;int n,Q;const double Pi=acosl(-1);struct LCT&#123; static const int MAXN=100050,funcmax=12; struct node&#123; int son[2],fa; bool flip; double func[funcmax],funcsum[funcmax]; node()&#123; son[0]=son[1]=fa=0,flip=false; memset(func,0,sizeof(func)); memset(funcsum,0,sizeof(funcsum)); &#125; &#125;T[MAXN]; inline bool isroot(int o)&#123;return T[T[o].fa].son[0]!=o&amp;&amp;T[T[o].fa].son[1]!=o;&#125; inline bool way(int o)&#123;return T[T[o].fa].son[1]==o;&#125; inline void puttag(int o)&#123;std::swap(T[o].son[0],T[o].son[1]),T[o].flip^=1;&#125; inline void pushdown(int o)&#123;if (T[o].flip) puttag(T[o].son[0]),puttag(T[o].son[1]),T[o].flip=0;&#125; inline void update(int o)&#123;for (int i=0;i&lt;funcmax;i++) T[o].funcsum[i]=T[T[o].son[0]].funcsum[i]+T[T[o].son[1]].funcsum[i]+T[o].func[i];&#125; void rotate(int o)&#123; int F=T[o].fa,G=T[F].fa,w=way(o),S=T[o].son[!w]; if (!isroot(F)) T[G].son[way(F)]=o; T[o].son[!w]=F,T[F].son[w]=S; T[S].fa=F,T[F].fa=o,T[o].fa=G; update(F),update(o); &#125; void splay(int o)&#123; static int stk[MAXN],top=0; for (int now=o;!isroot(stk[++top]=now);now=T[now].fa); while (top) pushdown(stk[top--]); for (;!isroot(o);rotate(o)) if (!isroot(T[o].fa)) rotate(way(o)^way(T[o].fa)?o:T[o].fa); &#125; inline void access(int o)&#123;for (int ls=0;o;splay(o),T[o].son[1]=ls,update(ls=o),o=T[o].fa);&#125; inline void makeroot(int o)&#123;access(o),splay(o),puttag(o);&#125; inline void split(int x,int y)&#123;makeroot(x),access(y),splay(y);&#125; inline bool haveedge(int x,int y)&#123;return split(x,y),T[x].fa==y&amp;&amp;!T[x].son[1];&#125; inline bool conn(int x,int y)&#123;return x==y||(split(x,y),T[x].fa);&#125; inline void link(int x,int y)&#123;if (!conn(x,y)) T[x].fa=y;&#125; inline void cut(int x,int y)&#123;if (haveedge(x,y)) T[x].fa=T[y].son[0]=0,update(y);&#125; inline void modifytype(int o,int tp,double a,double b)&#123; access(o),splay(o); double tmp=1; if (tp==1)&#123; double sinlist[4]=&#123;sin(b),cos(b)&#125;; sinlist[2]=-sinlist[0],sinlist[3]=-sinlist[1]; for (int i=0;i&lt;funcmax;i++)&#123; T[o].func[i]=sinlist[i%4]*tmp; tmp*=a/(i+1.); &#125; &#125; else if (tp==2)&#123; const double expval=expl(b); for (int i=0;i&lt;funcmax;i++)&#123; T[o].func[i]=expval*tmp; tmp*=a/(i+1.); &#125; &#125; else&#123; T[o].func[0]=b,T[o].func[1]=a; for (int i=2;i&lt;funcmax;i++) T[o].func[i]=0; &#125; update(o); &#125; inline double query(int x,int y,double val)&#123; split(x,y); double f=0,v=1; for (int i=0;i&lt;funcmax;i++,v*=val) f+=v*T[y].funcsum[i]; return f; &#125;&#125;T;char opt[10];int x,y,t;double g,u,v;int main()&#123; scanf(\"%d%d%*s\",&amp;n,&amp;Q); for (int i=1;i&lt;=n;i++)&#123; scanf(\"%d%lf%lf\",&amp;t,&amp;u,&amp;v); T.modifytype(i,t,u,v); &#125; while (Q--)&#123; scanf(\"%s\",opt); switch (opt[0])&#123; case 'a': scanf(\"%d%d\",&amp;x,&amp;y); T.link(x+1,y+1); break; case 'd': scanf(\"%d%d\",&amp;x,&amp;y); T.cut(x+1,y+1); break; case 'm': scanf(\"%d%d%lf%lf\",&amp;x,&amp;y,&amp;u,&amp;v); T.modifytype(x+1,y,u,v); break; case 't': scanf(\"%d%d%lf\",&amp;x,&amp;y,&amp;g); if (!T.conn(x+1,y+1)) puts(\"unreachable\"); else printf(\"%.12le\\n\",T.query(x+1,y+1,g)); break; &#125; &#125;&#125;","categories":[],"tags":[{"name":"Link-cut Tree","slug":"Link-cut-Tree","permalink":"https://ytxytx.github.io/tags/Link-cut-Tree/"}]},{"title":"UOJ 266 【清华集训2016】Alice和Bob又在玩游戏","slug":"uoj266","date":"2019-09-28T05:15:52.000Z","updated":"2019-10-26T03:06:41.000Z","comments":true,"path":"2019/09/28/uoj266/","link":"","permalink":"https://ytxytx.github.io/2019/09/28/uoj266/","excerpt":"题目描述Alice 和 Bob 在玩游戏。 给定一个有根树森林，每次一方可以选择一个存在的节点$x$，将$x$到根路径上的节点全部删除。 问 Alice 是否必胜。","text":"题目描述Alice 和 Bob 在玩游戏。 给定一个有根树森林，每次一方可以选择一个存在的节点$x$，将$x$到根路径上的节点全部删除。 问 Alice 是否必胜。 题解显然，每一棵树是独立的，考虑应用SG定理，计算每一棵树的SG值得到答案。 现在的问题是，一棵树的SG值如何求得。 对于一棵树，指定的节点可能是根，也可能在某个子树中： 如果删去根，到达的状态SG值是所有子树SG值的异或和。 如果删去某个子树中的节点，所有能到达的状态SG值是 其他子树SG值异或和 异或 该子树能到达的状态的SG值。 可以用Trie维护子树能到达状态的SG值 对于情况 1. 只需要在Trie中插入 对于情况 2. ，可以对所有子树的Trie先打上 异或其他子树SG值异或和 的标记，然后Trie合并 为了确定$mex$，就是找到当前Trie中最小的没有出现过的数 我的做法是再维护Trie上的$size$，如果某个节点$size$是满的就在兄弟节点中找 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cassert&gt;int T,n,m;int son[60000000][2],tag[60000000],sz[60000000],top;int roots[100050],rtop,SG[100050],root[100050];bool vis[100050];struct edge&#123;int to,nxt;&#125;E[200050];int H[100050],tot;void add_edge(int a,int b)&#123; E[++tot]=(edge)&#123;b,H[a]&#125;;H[a]=tot; E[++tot]=(edge)&#123;a,H[b]&#125;;H[b]=tot;&#125;int dfs(int now,int fa)&#123; int tmp=now; vis[now]=true; for (int i=H[now];i;i=E[i].nxt) if (E[i].to!=fa) tmp=std::min(tmp,dfs(E[i].to,now)); return tmp;&#125;void pushdown(int now,int dep)&#123; if (tag[now]&gt;&gt;dep&amp;1) std::swap(son[now][0],son[now][1]); tag[son[now][0]]^=tag[now],tag[son[now][1]]^=tag[now]; tag[now]=0;&#125;void update(int now)&#123;sz[now]=sz[son[now][0]]+sz[son[now][1]];&#125;void merge(int &amp;now,int t,int dep)&#123; if (!now)&#123;now=t;return;&#125; if (!t) return; if (dep&lt;0) return; pushdown(now,dep); pushdown(t,dep); merge(son[now][0],son[t][0],dep-1); merge(son[now][1],son[t][1],dep-1); update(now);&#125;int find(int now,int dep,int v)&#123; if (!~dep) return v; pushdown(now,dep); if (sz[son[now][0]]==1&lt;&lt;dep) return find(son[now][1],dep-1,v&lt;&lt;1|1); else return find(son[now][0],dep-1,v&lt;&lt;1);&#125;void insert(int &amp;now,int dep,int v)&#123; if (!now) now=++top; if (dep&lt;0)&#123;sz[now]=1;return;&#125; pushdown(now,dep); if (v&gt;&gt;dep&amp;1) insert(son[now][1],dep-1,v); else insert(son[now][0],dep-1,v); update(now);&#125;void solve(int now,int fa)&#123; bool sons=false; for (int i=H[now];i;i=E[i].nxt)&#123; if (E[i].to!=fa)&#123; solve(E[i].to,now); SG[now]^=SG[E[i].to]; sons=true; &#125; &#125; root[now]=++top; if (!sons)&#123; insert(root[now],14,0); insert(root[now],14,1); SG[now]=1; return; &#125; for (int i=H[now];i;i=E[i].nxt)&#123; if (E[i].to!=fa)&#123; tag[root[E[i].to]]^=SG[now]^SG[E[i].to]; merge(root[now],root[E[i].to],14); &#125; &#125; SG[now]=find(root[now],14,0); insert(root[now],14,SG[now]);&#125;int Ans;int main()&#123; scanf(\"%d\",&amp;T); while (T--)&#123; scanf(\"%d%d\",&amp;n,&amp;m); Ans=0; for (int i=1,x,y;i&lt;=m;i++) scanf(\"%d%d\",&amp;x,&amp;y),add_edge(x,y); for (int i=1;i&lt;=n;i++) if (!vis[i]) roots[++rtop]=dfs(i,0); for (int i=1;i&lt;=rtop;i++) solve(roots[i],0),Ans^=SG[roots[i]]; puts(Ans?\"Alice\":\"Bob\"); // clear memset(vis,0,sizeof(bool)*(n+1)); memset(son,0,sizeof(int)*2*(top+1)); memset(tag,0,sizeof(int)*(top+1)); memset(sz,0,sizeof(int)*(top+1)); memset(root,0,sizeof(int)*(n+1)); memset(SG,0,sizeof(int)*(n+1)); memset(E,0,sizeof(edge)*(tot+1)); memset(H,0,sizeof(int)*(n+1)); tot=top=rtop=0; &#125;&#125;","categories":[],"tags":[{"name":"Trie","slug":"Trie","permalink":"https://ytxytx.github.io/tags/Trie/"},{"name":"博弈论","slug":"博弈论","permalink":"https://ytxytx.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}]},{"title":"UOJ 335 【清华集训2017】生成树计数","slug":"uoj335","date":"2019-09-23T13:44:53.000Z","updated":"2019-10-26T03:05:26.000Z","comments":true,"path":"2019/09/23/uoj335/","link":"","permalink":"https://ytxytx.github.io/2019/09/23/uoj335/","excerpt":"题目描述在一个$s$个点的图中，存在$s−n$条边，使图中形成了$n$个连通块，第$i$个连通块中有$a_i$个点。 现在我们需要再连接$n−1$条边，使该图变成一棵树。对一种连边方案，设原图中第$i$个连通块连出了$d_i$条边，那么这棵树$T$的价值为： $$ \\mathrm{val}(T)=(\\prod_{i=1}^{n}d_i^m)(\\sum_{i=1}^{n}d_i^m) $$ 你的任务是求出所有可能的生成树的价值之和，对$998244353$取模。","text":"题目描述在一个$s$个点的图中，存在$s−n$条边，使图中形成了$n$个连通块，第$i$个连通块中有$a_i$个点。 现在我们需要再连接$n−1$条边，使该图变成一棵树。对一种连边方案，设原图中第$i$个连通块连出了$d_i$条边，那么这棵树$T$的价值为： $$ \\mathrm{val}(T)=(\\prod_{i=1}^{n}d_i^m)(\\sum_{i=1}^{n}d_i^m) $$ 你的任务是求出所有可能的生成树的价值之和，对$998244353$取模。 题解所求的答案： $$\\begin{align}Ans \\nonumber&amp;=\\sum_{T}(\\sum_{i=1}^{n}d_i^m)(\\prod_{i=1}^{n}d_i^m)(\\prod_{i=1}^{n}a_i^{d_i})\\end{align}$$ 换成枚举Prüfer序列，$s$为每个结点出现次数 由Prüfer序列的性质，$s_i+1$就是$i$号点的度数 $$\\begin{align}Ans \\nonumber&amp;=\\sum_{P}(\\sum_{i=1}^{n}(s_i+1)^m)(\\prod_{i=1}^{n}(s_i+1)^m)(\\prod_{i=1}^{n}a_i^{s_i+1}) \\\\\\nonumber&amp;=\\sum_{s}[\\sum s=n-2]\\frac{(n-2)!}{\\prod s_i!}(\\sum (s_i+1)^m)(\\prod (s_i+1)^m)(\\prod a_i^{s_i+1})\\end{align}$$ 令常数$C=(n-2)!\\prod a_i$， $$\\begin{align}Ans \\nonumber&amp;=C\\sum_{s}[\\sum s=n-2](\\sum (s_i+1)^m)(\\prod\\frac{1}{s_i!})(\\prod (s_i+1)^m)(\\prod a_i^{s_i}) \\\\\\nonumber&amp;=C\\sum_{s}[\\sum s=n-2](\\sum (s_i+1)^m)(\\prod\\frac{(s_i+1)^m a_i^{s_i}}{s_i!})\\end{align}$$ 接下来是令人费解的转换，将$i=j$的项移到求和项考虑： $$\\begin{align}Ans \\nonumber&amp;=C\\sum_{s}[\\sum s=n-2](\\sum_{i=1}^{n} \\frac{(s_i+1)^{2m} a_i^{s_i}}{s_i!}\\prod_{j\\neq i}\\frac{(s_j+1)^m a_j^{s_j}}{s_j!})\\end{align}$$ 定义生成函数$A$和$B$： $$ A(x)=\\sum_{k=0}^{\\infty}{\\frac{(k+1)^{2m}x^k}{k!}} $$ $$ B(x)=\\sum_{k=0}^{\\infty}{\\frac{(k+1)^m x^k}{k!}} $$ 可以得到： $$\\begin{align}Ans \\nonumber&amp;=C[x^{n-2}]\\sum_{i=1}^{n}A(a_i x)\\prod_{j\\neq i}B(a_j x) \\\\\\nonumber&amp;=C[x^{n-2}](\\sum_{i=1}^{n}\\frac{A(a_i x)}{B(a_i x)})(\\prod_{j=1}^{n}B(a_j x)) \\\\\\nonumber&amp;=C[x^{n-2}](\\sum_{i=1}^{n}\\frac{A(a_i x)}{B(a_i x)})\\exp(\\sum_{j=1}^{n}\\ln B(a_j x))\\end{align}$$ 令$F(x)=\\frac{A(x)}{B(x)},G(x)=\\ln B(x)$ $$\\begin{align}Ans \\nonumber&amp;=C[x^{n-2}](\\sum_{i=1}^{n}F(a_i x))\\exp(\\sum_{i=1}^{n}G(a_i x)) \\\\\\nonumber&amp;=C[x^{n-2}](\\sum_{k=0}^{\\infty}F_k x^k\\sum_{i=1}^{n}a_i^k)\\exp(\\sum_{k=0}^{\\infty}G_k x^k\\sum_{i=1}^{n}a_i^k)\\end{align}$$ 至此，只要对于所有的$k\\in [0,n-2]$快速得到$\\sum_{i=1}^{n}a_i^k$即可 令： $$\\begin{align}Z(x) \\nonumber&amp;=\\sum_{k=0}^{\\infty}\\sum_{i=1}^{n}a_i^kx^k \\\\\\nonumber&amp;=\\sum_{k=0}^{\\infty}\\sum_{i=1}^{n}(a_ix)^k \\\\\\nonumber&amp;=\\sum_{i=1}^{n}\\sum_{k=0}^{\\infty}(a_ix)^k \\\\\\nonumber&amp;=\\sum_{i=1}^{n}\\frac{1}{1-a_ix}\\end{align}$$ 用此式进行分治FFT已经可以得到$Z$了，也可以进一步推导但复杂度不变： 令$D(x)=\\prod_{i=1}^{n}(1-a_ix)$ 可以发现$Z(x)=n-\\frac{xD’(x)}{D(x)}$ 这样的编程难度会小一些 总时间复杂度$O(n\\log^2 n)$ Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cassert&gt;int n,m,A[50000];const int mod=998244353;int pow(int a,int b,int mod=::mod)&#123; int ret=1; for (;b;b&gt;&gt;=1,a=static_cast&lt;long long&gt;(a)*a%mod) if (b&amp;1) ret=static_cast&lt;long long&gt;(ret)*a%mod; return ret;&#125;inline void chkinc(int &amp;C)&#123;C+=C&gt;&gt;31&amp;mod;&#125;namespace polyspace&#123; typedef std::vector&lt;int&gt; poly; const int MAXN=200000; int wn[MAXN],w[MAXN],lim,lims,rev[MAXN],inv[MAXN]; void FFTinit(int n)&#123; wn[0]=lim=1,lims=-1; while (lim&lt;n) lim&lt;&lt;=1,lims++; for (int i=1;i&lt;lim;i++) rev[i]=rev[i&gt;&gt;1]&gt;&gt;1|(i&amp;1)&lt;&lt;lims; for (int g=pow(3,mod/lim),i=1;i&lt;lim;i++) wn[i]=static_cast&lt;long long&gt;(wn[i-1])*g%mod; &#125; void FFT(int *V,int f)&#123; for (int i=0;i&lt;lim;i++) if (rev[i]&gt;i) std::swap(V[rev[i]],V[i]); for (int i=1;i&lt;lim;i&lt;&lt;=1)&#123; for (int j=0,t=lim/2/i;j&lt;i;j++) w[j]=wn[j*t]; for (int j=0;j&lt;lim;j+=i+i)&#123; for (int k=0;k&lt;i;k++)&#123; const int X=V[j+k],Y=static_cast&lt;long long&gt;(V[i+j+k])*w[k]%mod; chkinc(V[j+k]+=Y-mod),chkinc(V[i+j+k]=X-Y); &#125; &#125; &#125; if (!f)&#123; std::reverse(V+1,V+lim); const int invlim=pow(lim,mod-2); for (int i=0;i&lt;lim;i++) V[i]=static_cast&lt;long long&gt;(V[i])*invlim%mod; &#125; &#125; poly &amp; operator += (poly &amp;A,const poly &amp;B)&#123; if (A.size()&lt;B.size()) A.resize(B.size()); for (int i=0;i&lt;A.size();i++) chkinc(A[i]+=B[i]-mod); return A; &#125; poly &amp; operator -= (poly &amp;A,const poly &amp;B)&#123; if (A.size()&lt;B.size()) A.resize(B.size()); for (int i=0;i&lt;A.size();i++) chkinc(A[i]-=B[i]); return A; &#125; poly operator + (poly A,const poly &amp;B)&#123;return A+=B;&#125; poly operator - (poly A,const poly &amp;B)&#123;return A-=B;&#125; poly operator * (poly A,poly B)&#123; const int N=A.size()+B.size()-1; FFTinit(N); A.resize(lim),B.resize(lim); FFT(A.data(),1),FFT(B.data(),1); for (int i=0;i&lt;lim;i++) A[i]=static_cast&lt;long long&gt;(A[i])*B[i]%mod; FFT(A.data(),0); A.resize(N); return A; &#125; poly &amp; operator *= (poly &amp;A,const poly &amp;B)&#123;return A=A*B;&#125; poly Inv(poly A,int N)&#123; // N&gt;0 A.resize(N); if (N==1) return poly&#123;pow(A[0],mod-2)&#125;; const int nxt=(N+1)&gt;&gt;1; poly ret=Inv(A,nxt),tmp=ret; FFTinit(N*3/2); A.resize(lim),ret.resize(N),tmp.resize(lim); FFT(A.data(),1); FFT(tmp.data(),1); for (int i=0;i&lt;lim;i++) A[i]=static_cast&lt;long long&gt;(A[i])*tmp[i]%mod*tmp[i]%mod; FFT(A.data(),0); for (int i=nxt;i&lt;N;i++) chkinc(ret[i]=-A[i]); return ret; &#125; poly Der(poly A)&#123; // A.size()&gt;0 poly B; B.resize(A.size()-1); for (int i=0;i&lt;B.size();i++) B[i]=(i+1LL)*A[i+1]%mod; return B; &#125; poly Int(poly A)&#123; poly B; B.resize(A.size()+1); for (int i=0;i&lt;A.size();i++) B[i+1]=static_cast&lt;long long&gt;(A[i])*inv[i+1]%mod; return B; &#125; poly Ln(poly A,int N)&#123; assert(A[0]==1); A.resize(N); poly ret=Int(Der(A)*Inv(A,N)); ret.resize(N); return ret; &#125; poly Exp(poly A,int N)&#123; assert(A[0]==0); A.resize(N); if (N==1) return poly&#123;1&#125;; poly ret=Exp(A,(N+1)&gt;&gt;1); ret*=(poly&#123;1&#125;+A-Ln(ret,N)); ret.resize(N); return ret; &#125; __attribute__((constructor)) void polyinit()&#123; inv[1]=1; for (int i=2;i&lt;MAXN;i++) inv[i]=static_cast&lt;long long&gt;(mod-mod/i)*inv[mod%i]%mod; &#125;&#125;using namespace polyspace;int fact[MAXN],ifact[MAXN];poly P,Q,R;poly solve(int L,int R)&#123; if (L==R) return poly&#123;1,(mod-A[L])%mod&#125;; int mdl=(L+R)&gt;&gt;1; return solve(L,mdl)*solve(mdl+1,R);&#125;poly shift(poly A)&#123; A.resize(A.size()+1); for (int i=A.size()-1;i;i--) A[i]=A[i-1]; A[0]=0; return A;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;A[i]); R=solve(1,n); fact[0]=1; for (int i=1;i&lt;=n;i++) fact[i]=static_cast&lt;long long&gt;(fact[i-1])*i%mod; ifact[n]=pow(fact[n],mod-2); for (int i=n;i;i--) ifact[i-1]=static_cast&lt;long long&gt;(ifact[i])*i%mod; poly X=shift(Der(R))*Inv(R,n); X.resize(n); X=poly&#123;n&#125;-X; P.resize(n-1),Q.resize(n-1); for (int i=0;i&lt;n-1;i++) P[i]=static_cast&lt;long long&gt;(pow(i+1,2*m))*ifact[i]%mod%mod; for (int i=0;i&lt;n-1;i++) Q[i]=static_cast&lt;long long&gt;(pow(i+1,m))*ifact[i]%mod; P*=Inv(Q,n-1); P.resize(n-1); for (int i=0;i&lt;n-1;i++) P[i]=static_cast&lt;long long&gt;(P[i])*X[i]%mod; Q=Ln(Q,n-1); for (int i=0;i&lt;n-1;i++) Q[i]=static_cast&lt;long long&gt;(Q[i])*X[i]%mod; Q=Exp(Q,n-1); P*=Q; int ans=static_cast&lt;long long&gt;(P[n-2])*fact[n-2]%mod; for (int i=1;i&lt;=n;i++) ans=static_cast&lt;long long&gt;(ans)*A[i]%mod; printf(\"%d\\n\",ans);&#125;","categories":[],"tags":[{"name":"FFT 快速傅里叶变换","slug":"FFT-快速傅里叶变换","permalink":"https://ytxytx.github.io/tags/FFT-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"},{"name":"生成函数","slug":"生成函数","permalink":"https://ytxytx.github.io/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"},{"name":"Prüfer序列","slug":"Prufer序列","permalink":"https://ytxytx.github.io/tags/Prufer%E5%BA%8F%E5%88%97/"}]},{"title":"Codeforces 280D k-Maximum Subsequence Sum","slug":"cf280d","date":"2019-09-20T01:45:34.000Z","updated":"2019-10-26T03:06:30.000Z","comments":true,"path":"2019/09/20/cf280d/","link":"","permalink":"https://ytxytx.github.io/2019/09/20/cf280d/","excerpt":"题目描述维护一个长度为$n$的整数序列$A$ 支持单点修改，区间询问选出$k$个无交子区间的最大和","text":"题目描述维护一个长度为$n$的整数序列$A$ 支持单点修改，区间询问选出$k$个无交子区间的最大和 题解先考虑建出费用流模型 一共$n+1$个结点，$i$向$i+1$的费用是$A_i$ $S$连向所有结点，所有结点连向$T$，所有边流量为$1$ 这样建模，一条增广路只有以下两种实际意义 选择一段没选过元素的区间 删掉一段全部被选择的区间（边权取负） 这样增广$k$次就选出了至多$k$个区间 在这基础上，每次找到费用最大的增广路，就是找到两种情况下和最大的区间 如果用$0,1$代表一个元素未选择和选择，可以用线段树维护同状态最大子段和，并且支持区间反转状态 维护的信息会很多，需要优秀的实现方法（在我的实现中，一个结点维护了$33$个信息） 注意需要撤销操作 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;int n,A[200000],Q;const int minv=0xcfcfcfcf;struct SegmentTree&#123; struct data&#123; int Ls,Rs,sum,mx,Lx,Rx,Lp,Rp; inline data()&#123;&#125; inline data(int Ls_,int Rs_,int sum_,int mx_,int Lx_,int Rx_,int Lp_,int Rp_)&#123;Ls=Ls_,Rs=Rs_,sum=sum_,mx=mx_,Lx=Lx_,Rx=Rx_,Lp=Lp_,Rp=Rp_;&#125; inline friend data operator + (const data &amp;A,const data &amp;B)&#123; data C; C.sum=std::max(A.sum+B.sum,minv); if (A.Ls&lt;A.sum+B.Ls) C.Ls=A.sum+B.Ls,C.Lx=B.Lx; else C.Ls=A.Ls,C.Lx=A.Lx; if (B.Rs&lt;B.sum+A.Rs) C.Rs=B.sum+A.Rs,C.Rx=A.Rx; else C.Rs=B.Rs,C.Rx=B.Rx; if (A.Rs+B.Ls&gt;std::max(A.mx,B.mx)) C.mx=A.Rs+B.Ls,C.Lp=A.Rx,C.Rp=B.Lx; else if (A.mx&gt;B.mx) C.mx=A.mx,C.Lp=A.Lp,C.Rp=A.Rp; else C.mx=B.mx,C.Lp=B.Lp,C.Rp=B.Rp; return C; &#125; &#125;; struct node&#123; bool flip; data D0,D1,E0,E1; &#125;T[800000]; inline void puttag(int o)&#123;std::swap(T[o].D0,T[o].E0),std::swap(T[o].D1,T[o].E1),T[o].flip^=1;&#125; inline void pushdown(int o)&#123;if (T[o].flip) puttag(o&lt;&lt;1),puttag(o&lt;&lt;1|1),T[o].flip=false;&#125; inline void update(int o)&#123; T[o].D0=T[o&lt;&lt;1].D0+T[o&lt;&lt;1|1].D0,T[o].D1=T[o&lt;&lt;1].D1+T[o&lt;&lt;1|1].D1; T[o].E0=T[o&lt;&lt;1].E0+T[o&lt;&lt;1|1].E0,T[o].E1=T[o&lt;&lt;1].E1+T[o&lt;&lt;1|1].E1; &#125; std::vector&lt;std::pair&lt;int,node&gt; &gt; operations; bool trace[800000]; void traceback()&#123; for (std::vector&lt;std::pair&lt;int,node&gt; &gt;::reverse_iterator it=operations.rbegin();it!=operations.rend();++it) T[it-&gt;first]=it-&gt;second,trace[it-&gt;first]=false; operations.clear(); &#125; void addtrace(int o)&#123; if (trace[o]) return; trace[o]=true; operations.push_back(std::make_pair(o,T[o])); &#125; std::pair&lt;data,data&gt; query(int o,int l,int r,int L,int R)&#123; addtrace(o); if (l&gt;R||r&lt;L) return std::make_pair(data(minv,minv,minv,minv,L,L,L,L),data(minv,minv,minv,minv,L,L,L,L)); if (L&lt;=l&amp;&amp;r&lt;=R) return std::make_pair(T[o].D0,T[o].D1); addtrace(o&lt;&lt;1); addtrace(o&lt;&lt;1|1); pushdown(o); int mdl=(l+r)&gt;&gt;1; std::pair&lt;data,data&gt; Ld=query(o&lt;&lt;1,l,mdl,L,R); std::pair&lt;data,data&gt; Rd=query(o&lt;&lt;1|1,mdl+1,r,L,R); return std::make_pair(Ld.first+Rd.first,Ld.second+Rd.second); &#125; std::pair&lt;std::pair&lt;int,int&gt;,int&gt; query(int L,int R)&#123; std::pair&lt;data,data&gt; Ds=query(1,1,n,L,R); if (Ds.first.mx&gt;Ds.second.mx) return std::make_pair(std::make_pair(Ds.first.Lp,Ds.first.Rp),Ds.first.mx); else return std::make_pair(std::make_pair(Ds.second.Lp,Ds.second.Rp),Ds.second.mx); &#125; void modify(int o,int l,int r,int L,int R)&#123; addtrace(o); if (l&gt;R||r&lt;L) return; if (L&lt;=l&amp;&amp;r&lt;=R)&#123;puttag(o);return;&#125; addtrace(o&lt;&lt;1); addtrace(o&lt;&lt;1|1); pushdown(o); int mdl=(l+r)&gt;&gt;1; modify(o&lt;&lt;1,l,mdl,L,R); modify(o&lt;&lt;1|1,mdl+1,r,L,R); update(o); &#125; void modify_single(int o,int l,int r,int k,int v)&#123; if (l==r)&#123; T[o].D0=data(v,v,v,v,l,l,l,l); T[o].D1=data(minv,minv,minv,minv,l,l,l,l); T[o].E0=data(minv,minv,minv,minv,l,l,l,l); T[o].E1=data(-v,-v,-v,-v,l,l,l,l); &#125; else&#123; pushdown(o); int mdl=(l+r)&gt;&gt;1; if (k&lt;=mdl) modify_single(o&lt;&lt;1,l,mdl,k,v); else modify_single(o&lt;&lt;1|1,mdl+1,r,k,v); update(o); &#125; &#125; void init(int o,int l,int r)&#123; if (l==r)&#123; T[o].D0=data(A[l],A[l],A[l],A[l],l,l,l,l); T[o].D1=data(minv,minv,minv,minv,l,l,l,l); T[o].E0=data(minv,minv,minv,minv,l,l,l,l); T[o].E1=data(-A[l],-A[l],-A[l],-A[l],l,l,l,l); return; &#125; int mdl=(l+r)&gt;&gt;1; init(o&lt;&lt;1,l,mdl); init(o&lt;&lt;1|1,mdl+1,r); update(o); &#125;&#125;T;int opt,L,R,v;int main()&#123; scanf(\"%d\",&amp;n); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;A[i]); T.init(1,1,n); scanf(\"%d\",&amp;Q); while (Q--)&#123; scanf(\"%d\",&amp;opt); if (opt==0)&#123; scanf(\"%d%d\",&amp;L,&amp;v); T.modify_single(1,1,n,L,v); &#125; else&#123; scanf(\"%d%d%d\",&amp;L,&amp;R,&amp;v); int ans=0; for (int k=0;k&lt;v;k++)&#123; std::pair&lt;std::pair&lt;int,int&gt;,int&gt; S=T.query(L,R); if (S.second&lt;0) break; ans+=S.second; T.modify(1,1,n,S.first.first,S.first.second); &#125; printf(\"%d\\n\",ans); &#125; T.traceback(); &#125;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://ytxytx.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"模拟费用流","slug":"模拟费用流","permalink":"https://ytxytx.github.io/tags/%E6%A8%A1%E6%8B%9F%E8%B4%B9%E7%94%A8%E6%B5%81/"}]},{"title":"HDU 6584 Meteor","slug":"hdu6584","date":"2019-09-15T02:38:54.000Z","updated":"2019-10-26T03:06:36.000Z","comments":true,"path":"2019/09/15/hdu6584/","link":"","permalink":"https://ytxytx.github.io/2019/09/15/hdu6584/","excerpt":"题目描述求所有$1\\leq p,q\\leq n$的最简分数$\\frac{p}{q}$中第$k$小的","text":"题目描述求所有$1\\leq p,q\\leq n$的最简分数$\\frac{p}{q}$中第$k$小的 题解首先二分答案区间$[L,R]$ 可以发现这些最简分数两两之差一定大于$\\frac{1}{n^2}$ 因此只要$R-L&lt;=\\frac{1}{n^2}$，这个区间中至多只有一个数 如果可以计算出$\\leq mid$的最简分数个数，就可以确定答案在$mid$左侧或右侧 考虑计算$\\leq k$的最简分数个数 $$\\begin{align}\\sum_{i=1}^{n}\\sum_{j=1}^{\\lfloor ki\\rfloor}[\\gcd(i,j)=1]&amp;=\\sum_{i=1}^{n}\\sum_{j=1}^{\\lfloor ki\\rfloor}\\sum_{d|i\\\\d|j}\\mu(d) \\\\&amp;=\\sum_{d=1}^{n}\\mu(d)\\sum_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\lfloor ki\\rfloor\\end{align}$$ 这个式子可以用整除分块+类欧几里得算法在$O(\\sqrt{n}\\log{n})$的时间内计算 加上外层的二分，复杂度是$O(\\sqrt{n}\\log^2{n})$ 得到了答案所在的区间，最后可以在Stern-Brocot Tree上遍历寻找大于等于左端点的最小值 树上遍历的复杂度是$O(n)$的，在答案为$\\frac{1}{n}$时取到 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;cstdio&gt;int T;long long x,y,b,co,n,m;long long calc(long long a,long long b,long long c,long long n)&#123; // \\sum_&#123;i=0&#125;^&#123;n&#125;\\lfloor\\frac&#123;ai+b&#125;&#123;c&#125;\\rfloor if (!a) return b/c*(n+1); if (a&gt;=c||b&gt;=c) return a/c*n*(n+1)/2+b/c*(n+1)+calc(a%c,b%c,c,n); const long long m=a*n/c+b/c+(a*n%c+b%c&gt;=c); return n*m-calc(c,c-b-1,a,m-1);&#125;long long calc2(long long a,long long b,long long c,long long n)&#123; long long ret=0; for (int i=0;i&lt;=n;i++) ret+=(a*i+b)/c; return ret;&#125;int mu[1000005],prime[300000],tot;bool isnprime[1000005];void sieve()&#123; mu[1]=1,isnprime[1]=true; for (int i=2;i&lt;=1000000;i++)&#123; if (!isnprime[i]) prime[++tot]=i,mu[i]=-1; for (int j=1;i*prime[j]&lt;=1000000;j++)&#123; isnprime[i*prime[j]]=true; if (!(i%prime[j]))&#123; mu[i*prime[j]]=0; break; &#125; mu[i*prime[j]]=-mu[i]; &#125; &#125; for (int i=2;i&lt;=1000000;i++) mu[i]+=mu[i-1];&#125;struct frac&#123; long long x,y; frac()&#123;x=y=0;&#125; frac(long long x_,long long y_)&#123;x=x_,y=y_;&#125;&#125;;inline frac combine(const frac &amp;A,const frac &amp;B)&#123;return frac(A.x+B.x,A.y+B.y);&#125;inline bool operator &lt;= (const frac &amp;A,const frac &amp;B)&#123;return static_cast&lt;__int128&gt;(A.y)*B.x-static_cast&lt;__int128&gt;(A.x)*B.y&gt;=0;&#125;int main()&#123; sieve(); scanf(\"%d\",&amp;T); while (T--)&#123; scanf(\"%lld%lld\",&amp;n,&amp;m); co=n*n; b=1,x=0,y=1; while (b&lt;=co)&#123; x&lt;&lt;=1,y&lt;&lt;=1,b&lt;&lt;=1; long long mdl=(x+y)&gt;&gt;1,sum=0; for (int l=1,r;l&lt;=n;l=r+1)&#123; int dd=n/l; r=n/dd; sum+=(mu[r]-mu[l-1])*calc(mdl,0,b,dd); &#125; if (sum&gt;=m) y=mdl; else x=mdl; &#125; frac L(0,1),now(1,1),R(1,0),ans(1,1),g(x,b); while (true)&#123; if (g&lt;=now&amp;&amp;now&lt;=g)&#123;ans=now;break;&#125; if (g&lt;=now)&#123; if (now&lt;=ans) ans=now; frac Lval=combine(L,now); if (Lval.y&gt;n) break; R=now,now=Lval; &#125; else&#123; frac Rval=combine(now,R); if (Rval.y&gt;n) break; L=now,now=Rval; &#125; &#125; printf(\"%lld/%lld\\n\",ans.x,ans.y); &#125;&#125;","categories":[],"tags":[{"name":"二分","slug":"二分","permalink":"https://ytxytx.github.io/tags/%E4%BA%8C%E5%88%86/"},{"name":"类欧几里得算法","slug":"类欧几里得算法","permalink":"https://ytxytx.github.io/tags/%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/"},{"name":"Stern-Brocot Tree","slug":"Stern-Brocot-Tree","permalink":"https://ytxytx.github.io/tags/Stern-Brocot-Tree/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"https://ytxytx.github.io/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"}]},{"title":"HDU 6599 I Love Palindrome String","slug":"hdu6599","date":"2019-09-06T06:08:40.000Z","updated":"2019-10-26T03:06:33.000Z","comments":true,"path":"2019/09/06/hdu6599/","link":"","permalink":"https://ytxytx.github.io/2019/09/06/hdu6599/","excerpt":"题目描述给定字符串$S$，对于每个长度$i$求这样的子串个数，满足： 其本身是回文串 其前一半是回文串","text":"题目描述给定字符串$S$，对于每个长度$i$求这样的子串个数，满足： 其本身是回文串 其前一半是回文串 题解首先用Manacher预处理每个点为中点最长的回文子串 对给定串构建回文树 构建的同时处理出每个结点代表的回文串是否满足题目要求的性质 用到了Manacher预处理出的信息判断一个子串是否是回文串 还要在回文树上处理出每个回文串的出现次数，最后统计即可 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;char S[700000],T[700000];int n;int pal[700000];void Manacher()&#123; pal[1]=0; int id=1; for (int i=2;i&lt;=n+n;i++)&#123; if (i&lt;=id+pal[id]) pal[i]=std::min(pal[id+id-i],id+pal[id]-i); while (T[i+pal[i]+1]==T[i-pal[i]-1]) pal[i]++; if (i+pal[i]&gt;id+pal[id]) id=i; &#125;&#125;inline bool ispalindrome(int L,int R)&#123;return pal[L+R+2]&gt;=R-L;&#125;struct PAM&#123; struct node&#123; int son[26],link,len,sum; bool isp; inline void clear()&#123;memset(son,0,sizeof(son)),link=len=sum=0,isp=false;&#125; node()&#123;clear();&#125; &#125;T[400000]; int tot; void insert(char *S)&#123; int L=strlen(S),now=1; for (int i=0;i&lt;L;i++)&#123; while (S[i]!=S[i-T[now].len-1]) now=T[now].link; if (!T[now].son[S[i]-'a'])&#123; tot++; T[tot].len=T[now].len+2; T[tot].link=T[now].link; while (S[i]!=S[i-T[T[tot].link].len-1]) T[tot].link=T[T[tot].link].link; T[tot].link=T[T[tot].link].son[S[i]-'a']; now=T[now].son[S[i]-'a']=tot; T[now].isp=ispalindrome(((2*i-T[now].len)&gt;&gt;1)+1,i); &#125; else now=T[now].son[S[i]-'a']; T[now].sum++; &#125; &#125; void prepare()&#123;for (int i=tot;i;i--) T[T[i].link].sum+=T[i].sum;&#125; void clear()&#123; for (int i=0;i&lt;=tot;i++) T[i].clear(); tot=1,T[0].link=1,T[1].len=-1; &#125; PAM()&#123;tot=1,T[0].link=1,T[1].len=-1;&#125;&#125;P;int ans[500000];int main()&#123; while (~scanf(\"%s\",S+1))&#123; n=strlen(S+1); T[0]='$'; T[1]='#'; memcpy(T+1,S+1,sizeof(char)*(n+1)); for (int i=n;i;i--) T[i+i+1]='#',T[i+i]=S[i]; Manacher(); P.insert(S+1); P.prepare(); for (int i=2;i&lt;=P.tot;i++) if (P.T[i].isp) ans[P.T[i].len]+=P.T[i].sum; for (int i=1;i&lt;=n;i++) printf(\"%d%c\",ans[i],\" \\n\"[i==n]); // clear P.clear(); memset(ans,0,sizeof(int)*(n+1)); memset(pal,0,sizeof(int)*(n+n+5)); memset(T,0,sizeof(char)*(n+n+5)); &#125;&#125;","categories":[],"tags":[{"name":"回文树","slug":"回文树","permalink":"https://ytxytx.github.io/tags/%E5%9B%9E%E6%96%87%E6%A0%91/"},{"name":"Manacher","slug":"Manacher","permalink":"https://ytxytx.github.io/tags/Manacher/"}]},{"title":"HDU 6607 Easy Math Problem","slug":"hdu6607","date":"2019-08-30T08:30:46.000Z","updated":"2019-10-26T03:06:24.000Z","comments":true,"path":"2019/08/30/hdu6607/","link":"","permalink":"https://ytxytx.github.io/2019/08/30/hdu6607/","excerpt":"题目描述求 $$ \\sum_{i=1}^{n}\\sum_{j=1}^{n}\\gcd(i,j)^k\\textrm{lcm}(i,j)[\\gcd(i,j)\\in\\mathbb{P}] $$","text":"题目描述求 $$ \\sum_{i=1}^{n}\\sum_{j=1}^{n}\\gcd(i,j)^k\\textrm{lcm}(i,j)[\\gcd(i,j)\\in\\mathbb{P}] $$ 题解推式子 $$\\begin{align}Ans\\nonumber&amp;=\\sum_{i=1}^{n}\\sum_{j=1}^{n}\\gcd(i,j)^k\\textrm{lcm}(i,j)[\\gcd(i,j)\\in\\mathbb{P}] \\\\\\nonumber&amp;=\\sum_{i=1}^{n}\\sum_{j=1}^{n}ij\\gcd(i,j)^{k-1}[\\gcd(i,j)\\in\\mathbb{P}] \\\\\\nonumber&amp;=\\sum_{p\\in\\mathbb{P}}\\sum_{i=1}^{n}\\sum_{j=1}^{n}ijp^{k-1}[\\gcd(i,j)=p] \\\\\\nonumber&amp;=\\sum_{p\\in\\mathbb{P}}p^{k-1}\\sum_{i=1}^{\\lfloor\\frac{n}{p}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{n}{p}\\rfloor}ip\\cdot jp[\\gcd(i,j)=1] \\\\\\nonumber&amp;=\\sum_{p\\in\\mathbb{P}}p^{k+1}\\sum_{i=1}^{\\lfloor\\frac{n}{p}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{n}{p}\\rfloor}ij[\\gcd(i,j)=1] \\\\\\nonumber&amp;=\\sum_{p\\in\\mathbb{P}}p^{k+1}\\sum_{i=1}^{\\lfloor\\frac{n}{p}\\rfloor}i^2\\varphi(i) \\\\\\nonumber&amp;=\\sum_{i=1}^{n}i^2\\varphi(i)\\sum_{\\begin{array}{c}p\\in\\mathbb{P} \\\\ p\\leq\\lfloor\\frac{n}{i}\\rfloor\\end{array}}p^{k+1} \\nonumber\\end{align}$$ 到此为止，就可以用杜教筛处理$i^2\\varphi(i)$的前缀和，以及素数处点值的那套理论处理$p^{k+1}$的部分和 关于杜教筛处理，令$F(n)=n^2\\varphi(n),G(n)=n^2$，则有$F*G(n)=n^3$ 最后套一个整除分块就做完了 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;int sqrtn,T,k;long long n,V[300000];int vtot;const int mod=1000000007,inv6=166666668,inv4=250000002;int prime[5000000],ptot,foo[5000000];bool isnprime[5000000];void sieve()&#123; isnprime[1]=true,foo[1]=1; for (int i=2;i&lt;=4900000;i++)&#123; if (!isnprime[i]) prime[++ptot]=i,foo[i]=i-1; for (int j=1;i*prime[j]&lt;=4900000;j++)&#123; isnprime[i*prime[j]]=true; if (!(i%prime[j]))&#123; foo[i*prime[j]]=foo[i]*prime[j]; break; &#125; foo[i*prime[j]]=foo[i]*(prime[j]-1); &#125; &#125; for (int i=2;i&lt;=4900000;i++) foo[i]=(foo[i-1]+i*static_cast&lt;long long&gt;(i)%mod*foo[i])%mod;&#125;struct Array&#123; private: int S[200000],T[200000]; public: inline int &amp; operator [] (const long long idx)&#123;return idx&lt;=sqrtn?S[idx]:T[n/idx];&#125; void clear(unsigned char cl)&#123; memset(S,cl,sizeof(S)); memset(T,cl,sizeof(T)); &#125; Array()&#123;clear(0x00);&#125;&#125;G,F;inline int sig2(long long n)&#123;return n%=mod,n*(n+1LL)%mod*(2LL*n+1LL)%mod*inv6%mod;&#125;inline int sig3(long long n)&#123;return n%=mod,n*(n+1LL)%mod*n%mod*(n+1LL)%mod*inv4%mod;&#125;inline int pow(long long a,int b)&#123; int ret=1; a%=mod; for (;b;b&gt;&gt;=1,a=a*static_cast&lt;long long&gt;(a)%mod) if (b&amp;1) ret=ret*static_cast&lt;long long&gt;(a)%mod; return ret;&#125;void Lagrange(int *A,int *B,int n)&#123; int F[n+2],tmp[n+2]; memset(F,0,sizeof(F)); F[0]=1; for (int i=0;i&lt;=n;i++)&#123; for (int j=i;~j;j--) F[j+1]=F[j]; F[0]=0; for (int j=0;j&lt;=i;j++) F[j]=(F[j]-i*static_cast&lt;long long&gt;(F[j+1])%mod+mod)%mod; &#125; memset(B,0,sizeof(int)*(n+1)); for (int i=0;i&lt;=n;i++)&#123; int mul=1; for (int j=0;j&lt;=n;j++)&#123; if (i==j) continue; mul=mul*static_cast&lt;long long&gt;(i-j+mod)%mod; &#125; mul=pow(mul,mod-2); mul=mul*static_cast&lt;long long&gt;(A[i])%mod; memcpy(tmp,F,sizeof(tmp)); for (int j=n;~j;j--)&#123; B[j]=(B[j]+static_cast&lt;long long&gt;(tmp[j+1])*mul)%mod; tmp[j]=(tmp[j]+static_cast&lt;long long&gt;(tmp[j+1])*i)%mod; &#125; &#125;&#125;int X[200],Y[200];void init()&#123; // min-25 for (int i=1;prime[i]*static_cast&lt;long long&gt;(prime[i])&lt;=n;i++) for (int j=vtot;j&amp;&amp;prime[i]*static_cast&lt;long long&gt;(prime[i])&lt;=V[j];j--) F[V[j]]=(F[V[j]]-pow(prime[i],k+1)*static_cast&lt;long long&gt;(F[V[j]/prime[i]]-F[prime[i]-1]+mod)%mod+mod)%mod; // dujiao const long long part=pow(static_cast&lt;double&gt;(n),2./3); int it; for (it=1;V[it]&lt;=part;it++) G[V[it]]=foo[V[it]]; for (int i=it;i&lt;=vtot;i++)&#123; G[V[i]]=sig3(V[i]); for (long long l=2,r;l&lt;=V[i];l=r+1)&#123; const long long divd=V[i]/l; r=V[i]/divd; G[V[i]]=(G[V[i]]-(sig2(r)-sig2(l-1)+mod)*static_cast&lt;long long&gt;(G[divd])%mod+mod)%mod; &#125; &#125;&#125;int ans;int main()&#123; sieve(); scanf(\"%d\",&amp;T); while (T--)&#123; scanf(\"%lld%d\",&amp;n,&amp;k); sqrtn=sqrtl(n)+1e-10; vtot=0,G.clear(0x00),F.clear(0x00); for (long long l=1;l&lt;=n;l=(n/(n/l))+1) V[++vtot]=n/l; std::reverse(V+1,V+vtot+1); for (int i=1;i&lt;=k+2;i++) X[i]=(X[i-1]+pow(i,k+1))%mod; Lagrange(X,Y,k+2); for (int i=1;i&lt;=vtot;i++)&#123; int dv=V[i]%mod; for (int j=k+2;~j;j--) F[V[i]]=(F[V[i]]*static_cast&lt;long long&gt;(dv)%mod+Y[j])%mod; F[V[i]]=(F[V[i]]-1+mod)%mod; &#125; init(); ans=0; for (long long l=1,r;l&lt;=n;l=r+1)&#123; long long divd=n/l; r=n/divd; ans=(ans+F[divd]*static_cast&lt;long long&gt;(G[r]-G[l-1]+mod))%mod; &#125; printf(\"%d\\n\",ans); &#125;&#125;","categories":[],"tags":[{"name":"杜教筛","slug":"杜教筛","permalink":"https://ytxytx.github.io/tags/%E6%9D%9C%E6%95%99%E7%AD%9B/"}]},{"title":"HDU 6694 Play Games with Rounddog","slug":"hdu6694","date":"2019-08-30T02:06:40.000Z","updated":"2019-10-26T03:06:15.000Z","comments":true,"path":"2019/08/30/hdu6694/","link":"","permalink":"https://ytxytx.github.io/2019/08/30/hdu6694/","excerpt":"题目描述给定串$S$，和正整数数组$W$ 每次询问$S$的一个子串$S[L:R]$，在所有以$S[L:R]$为后缀的不同子串中，选出若干作为${T_i}$，使得$W_{T_i的出现次数}$线性无关且和最大","text":"题目描述给定串$S$，和正整数数组$W$ 每次询问$S$的一个子串$S[L:R]$，在所有以$S[L:R]$为后缀的不同子串中，选出若干作为${T_i}$，使得$W_{T_i的出现次数}$线性无关且和最大 题解以$S[L:R]$为后缀，就是在反串的后缀树上$S_R[L:R]$对应的结点的子树 后缀树上一个结点代表的一些字符串出现次数相同，也就是$endpos$集合的大小，可以用后缀自动机处理 对于和最大的线性无关组，可以参考[CQOI2013]新Nim游戏的做法（线性基+贪心） 用后缀自动机建出后缀树后，在后缀树上预处理出子树中所有$W_{|endpos|}$的和最大的线性基，可以使用线性基合并 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;int T,n,m;char S[105000];unsigned long long W[105000];struct SAM&#123; struct node&#123; int son[26]; int len,link,sz; node()&#123; memset(son,0xff,sizeof(son)); len=link=sz=0; &#125; &#125;T[200500]; int lst,tot; int insert(char C)&#123; C-='a'; int q=++tot,p=lst; lst=q,T[q].len=T[p].len+1,T[q].sz=1; while (~p&amp;&amp;!~T[p].son[C]) T[p].son[C]=q,p=T[p].link; if (!~p) return q; int np=T[p].son[C]; if (T[p].len+1==T[np].len) T[q].link=np; else&#123; int nq=++tot; memcpy(T[nq].son,T[np].son,sizeof(int)*26); T[nq].len=T[p].len+1; T[nq].link=T[np].link; T[q].link=T[np].link=nq; while (~p&amp;&amp;T[p].son[C]==np) T[p].son[C]=nq,p=T[p].link; &#125; return q; &#125; void clear()&#123; for (int i=0;i&lt;=tot;i++) T[i]=node(); T[0].link=-1; lst=tot=0; &#125; SAM()&#123; lst=tot=0; T[0].link=-1; &#125;&#125;G;int id[105000];struct edge&#123;int to,nxt;&#125;E[200500];int H[200500],tot;void add_edge(int a,int b)&#123;E[++tot]=(edge)&#123;b,H[a]&#125;,H[a]=tot;&#125;struct Basis&#123; unsigned long long B[58],origin[58],sum; void insert(unsigned long long W)&#123; unsigned long long tmp=W; for (int i=57;~i;i--)&#123; if (W&gt;&gt;i&amp;1)&#123; if (!B[i])&#123;B[i]=W,origin[i]=tmp,sum+=tmp;return;&#125; else W^=B[i]; &#125; &#125; &#125; void clear()&#123; memset(B,0,sizeof(B)); memset(origin,0,sizeof(origin)); sum=0; &#125; Basis()&#123;clear();&#125;&#125;D[200500];Basis merge(const Basis &amp;A,const Basis &amp;B)&#123; Basis ret; unsigned long long tmp[116]; memcpy(tmp,A.origin,sizeof(unsigned long long)*58); memcpy(tmp+58,B.origin,sizeof(unsigned long long)*58); std::sort(tmp,tmp+116,std::greater&lt;unsigned long long&gt;()); for (int i=0;i&lt;116;i++) ret.insert(tmp[i]); return ret;&#125;int jmp[200500][19];void prework1(int now)&#123; jmp[now][0]=G.T[now].link; if (!now) jmp[now][0]=0; for (int i=1;i&lt;=18;i++) jmp[now][i]=jmp[jmp[now][i-1]][i-1]; for (int i=H[now];i;i=E[i].nxt)&#123; prework1(E[i].to); G.T[now].sz+=G.T[E[i].to].sz; &#125;&#125;void prework2(int now)&#123; for (int i=H[now];i;i=E[i].nxt) prework2(E[i].to),D[now]=merge(D[now],D[E[i].to]);&#125;int jump(int now,int len)&#123; for (int i=18;~i;i--) if (G.T[jmp[now][i]].len&gt;=len) now=jmp[now][i]; return now;&#125;int main()&#123; scanf(\"%d\",&amp;T); while (T--)&#123; scanf(\"%d\",&amp;n); scanf(\"%s\",S+1); for (int i=1;i&lt;=n;i++) scanf(\"%llu\",&amp;W[i]); for (int i=1;i&lt;=n;i++) id[i]=G.insert(S[i]); for (int i=1;i&lt;=G.tot;i++) add_edge(G.T[i].link,i); prework1(0); for (int i=0;i&lt;=G.tot;i++) D[i].insert(W[G.T[i].sz]); prework2(0); scanf(\"%d\",&amp;m); for (int i=1,L,R;i&lt;=m;i++)&#123; scanf(\"%d%d\",&amp;L,&amp;R); int J=jump(id[R],R-L+1); printf(\"%llu\\n\",D[J].sum); &#125; // clearing for (int i=0;i&lt;=G.tot;i++) D[i].clear(); memset(E,0,sizeof(edge)*(tot+1)); memset(H,0,sizeof(int)*(G.tot+1)); tot=0; G.clear(); &#125;&#125;","categories":[],"tags":[{"name":"后缀自动机","slug":"后缀自动机","permalink":"https://ytxytx.github.io/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"后缀树","slug":"后缀树","permalink":"https://ytxytx.github.io/tags/%E5%90%8E%E7%BC%80%E6%A0%91/"},{"name":"倍增","slug":"倍增","permalink":"https://ytxytx.github.io/tags/%E5%80%8D%E5%A2%9E/"},{"name":"线性基","slug":"线性基","permalink":"https://ytxytx.github.io/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"}]},{"title":"Codeforces 53E Dead Ends","slug":"cf53e","date":"2019-08-03T13:30:22.000Z","updated":"2019-10-26T03:06:38.000Z","comments":true,"path":"2019/08/03/cf53e/","link":"","permalink":"https://ytxytx.github.io/2019/08/03/cf53e/","excerpt":"题目描述给出$n$个点的无向图，求恰好$k$个叶子的生成树个数","text":"题目描述给出$n$个点的无向图，求恰好$k$个叶子的生成树个数 题解首先提一句，Codeforces Tutorial给出了一种状态数是$2^n*2^n$的一种dp，复杂度较劣 这里考虑使用容斥 令$F_S$表示钦定$S$集合中的点是叶子节点（没被钦定到的点可能有叶子节点）的生成树个数 令$G_S$表示只有$S$集合中的点是叶子节点的生成树个数 答案就是$\\sum_{|S|=k}{G_S}$ 可以得到$F$和$G$的关系 $$ F_S=\\sum_{T\\supseteq S}{G_T} $$ 如果用$\\overline{S}$表示$S$的补集，那么 $$ F_\\overline{S}=\\sum_{\\overline{T}\\subseteq \\overline{S}}{G_\\overline{T}} $$ 这就是莫比乌斯变换的形式，如果可以得到$F$，就可以进行莫比乌斯反演得到$G$ $$ G_\\overline{S}=\\sum_{\\overline{T}\\subseteq \\overline{S}}{(-1)^{|\\overline{S}|-|\\overline{T}|}F_\\overline{T}} $$ 为了得到$F_S$，可以先用矩阵树定理求$\\overline{S}$的导出子图的生成树个数，再乘把每个被钦定的叶子接到生成树上的方案 总时间复杂度$O(2^n*n^3)$ Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;int n,m,k;const int mod=998244353;bool E[10][10];int M[10][10],ful,id[10],di[10],top;inline int pow(int a,int b)&#123; int ret=1; for (;b;b&gt;&gt;=1,a=a*static_cast&lt;long long&gt;(a)%mod) if (b&amp;1) ret=ret*static_cast&lt;long long&gt;(a)%mod; return ret;&#125;int Gauss(int B)&#123; int H=1; for (int i=0;i&lt;B;i++)&#123; if (!M[i][i]) for (int j=i;j&lt;B;j++) if (M[j][i]) std::swap(M[i],M[j]),H=mod-H; H=H*static_cast&lt;long long&gt;(M[i][i])%mod; int inv=pow(M[i][i],mod-2); for (int j=i;j&lt;B;j++) M[i][j]=M[i][j]*static_cast&lt;long long&gt;(inv)%mod; for (int j=i+1;j&lt;B;j++)&#123; int G=M[j][i]; for (int k=i;k&lt;B;k++) M[j][k]=(M[j][k]-M[i][k]*static_cast&lt;long long&gt;(G)%mod+mod)%mod; &#125; &#125; for (int i=0;i&lt;B;i++) H=H*static_cast&lt;long long&gt;(M[i][i])%mod; return H;&#125;int calc(int S)&#123; top=0; for (int i=0;i&lt;n;i++) if (S&gt;&gt;i&amp;1) di[id[i]=top++]=i; memset(M,0,sizeof(M)); for (int i=0;i&lt;top;i++) for (int j=0;j&lt;top;j++) if (E[di[i]][di[j]]) M[i][i]++,M[i][j]=mod-1; int G=Gauss(top-1); for (int i=0;i&lt;n;i++)&#123; if (!(S&gt;&gt;i&amp;1))&#123; int cnt=0; for (int j=0;j&lt;top;j++) cnt+=E[i][di[j]]; G=G*static_cast&lt;long long&gt;(cnt)%mod; &#125; &#125; return G;&#125;int V[1&lt;&lt;10],ans;void FMT(int L)&#123; for (int i=0;i&lt;L;i++) for (int j=0;j&lt;(1&lt;&lt;L);j++) if (j&gt;&gt;i&amp;1) V[j]=(V[j]-V[j^(1&lt;&lt;i)]+mod)%mod;&#125;int main()&#123; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;k); ful=(1&lt;&lt;n)-1; for (int i=1,x,y;i&lt;=m;i++) scanf(\"%d%d\",&amp;x,&amp;y),x--,y--,E[x][y]=E[y][x]=true; for (int i=0;i&lt;(1&lt;&lt;n);i++) V[i]=calc(i); FMT(n); for (int i=0;i&lt;(1&lt;&lt;n);i++) if (__builtin_popcount(i)==n-k) ans=(ans+V[i])%mod; printf(\"%d\\n\",ans);&#125;","categories":[],"tags":[{"name":"容斥","slug":"容斥","permalink":"https://ytxytx.github.io/tags/%E5%AE%B9%E6%96%A5/"},{"name":"快速莫比乌斯变换（反演）","slug":"快速莫比乌斯变换（反演）","permalink":"https://ytxytx.github.io/tags/%E5%BF%AB%E9%80%9F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%98%E6%8D%A2%EF%BC%88%E5%8F%8D%E6%BC%94%EF%BC%89/"},{"name":"矩阵树定理","slug":"矩阵树定理","permalink":"https://ytxytx.github.io/tags/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/"}]},{"title":"Codeforces 700E Cool Slogans","slug":"cf700e","date":"2019-08-02T14:08:49.000Z","updated":"2019-10-26T03:06:27.000Z","comments":true,"path":"2019/08/02/cf700e/","link":"","permalink":"https://ytxytx.github.io/2019/08/02/cf700e/","excerpt":"题目描述给定母串$S$ 要求一个字符串列表$T$，满足$T$中元素都是$S$的子串，且$T_i$在$T_{i+1}$中出现至少$2$次 问列表最长长度","text":"题目描述给定母串$S$ 要求一个字符串列表$T$，满足$T$中元素都是$S$的子串，且$T_i$在$T_{i+1}$中出现至少$2$次 问列表最长长度 题解对母串建出后缀自动机 每次选择列表的下一个元素，一定可以在parent树上对应结点的子树中选择 因为parent树的子树对应的字符串都以该串为后缀 可以写成dp的形式，令$F_i$表示$i$号结点代表的字符串前最多可以接多少字符串 最终要求的就是dp的最大值 接下来考虑，如何判断$x$的某个祖先$y$对应的字符串是否在$x$对应的字符串中出现至少两次 由于在parent树上，所以一定作为后缀出现了一次 另外一次只要利用$endpos_y$判断是否作为$x$对应字符串的非后缀子串即可 endpos可以用线段树合并预处理，dp时注意转移点的处理 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;int n;char S[300000];struct edge&#123;int to,nxt;&#125;E[500000];int H[500000],tot;inline void add_edge(int a,int b)&#123;E[++tot]=(edge)&#123;b,H[a]&#125;,H[a]=tot;&#125;struct SegmentTree&#123; struct node&#123; node *L,*R; node()&#123;L=R=NULL;&#125; &#125;; node *root; void insert(node *&amp;now,int l,int r,int k)&#123; if (!now) now=new node; if (l==r) return; int mdl=(l+r)&gt;&gt;1; if (k&lt;=mdl) insert(now-&gt;L,l,mdl,k); else insert(now-&gt;R,mdl+1,r,k); &#125; bool query(node *now,int l,int r,int L,int R)&#123; if (l&gt;R||r&lt;L||!now) return false; if (L&lt;=l&amp;&amp;r&lt;=R) return true; int mdl=(l+r)&gt;&gt;1; return query(now-&gt;L,l,mdl,L,R)|query(now-&gt;R,mdl+1,r,L,R); &#125; SegmentTree()&#123;root=NULL;&#125;&#125;;SegmentTree::node * merge(SegmentTree::node *&amp;A,SegmentTree::node *&amp;B)&#123; if (!(A&amp;&amp;B)) return A?A:B; SegmentTree::node *nw=new SegmentTree::node; nw-&gt;L=merge(A-&gt;L,B-&gt;L),nw-&gt;R=merge(A-&gt;R,B-&gt;R); return nw;&#125;struct SAM&#123; struct node&#123; int son[26],len,link,R; SegmentTree S; node()&#123; memset(son,0xff,sizeof(int)*26); len=link=R=0; &#125; &#125;T[500000]; int tot,lst; void insert(char C)&#123; C-='a'; int q=++tot,p=lst; T[q].len=T[p].len+1,T[q].S.insert(T[q].S.root,1,n,T[q].R=T[q].len); lst=q; while (~p&amp;&amp;!~T[p].son[C]) T[p].son[C]=q,p=T[p].link; if (!~p) return; int np=T[p].son[C]; if (T[p].len+1==T[np].len) T[q].link=np; else&#123; int nq=++tot; memcpy(T[nq].son,T[np].son,sizeof(int)*26); T[nq].link=T[np].link; T[nq].len=T[p].len+1; T[np].link=T[q].link=nq; while (~p&amp;&amp;T[p].son[C]==np) T[p].son[C]=nq,p=T[p].link; &#125; &#125; SAM()&#123;tot=lst=0,T[0].link=-1;&#125;&#125;G;void pre(int now)&#123; for (int i=H[now];i;i=E[i].nxt)&#123; pre(E[i].to); G.T[now].R=std::max(G.T[now].R,G.T[E[i].to].R); G.T[now].S.root=merge(G.T[now].S.root,G.T[E[i].to].S.root); &#125;&#125;int Ans;void solve(int now,int ans,int top)&#123; Ans=std::max(Ans,ans); for (int i=H[now];i;i=E[i].nxt)&#123; if (G.T[top].S.query(G.T[top].S.root,1,n,G.T[E[i].to].R-G.T[E[i].to].len+G.T[top].len,G.T[E[i].to].R-1)) solve(E[i].to,ans+1,E[i].to); else solve(E[i].to,ans,top); &#125;&#125;int main()&#123; scanf(\"%d%s\",&amp;n,S+1); if (n==1) return puts(\"1\"),0; for (int i=1;i&lt;=n;i++) G.insert(S[i]); for (int i=1;i&lt;=G.tot;i++) add_edge(G.T[i].link,i); pre(0),solve(0,0,0); printf(\"%d\\n\",Ans);&#125;","categories":[],"tags":[{"name":"后缀自动机","slug":"后缀自动机","permalink":"https://ytxytx.github.io/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"线段树合并","slug":"线段树合并","permalink":"https://ytxytx.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/"}]},{"title":"[HEOI2016/TJOI2016]字符串","slug":"luogu4094","date":"2019-08-01T10:26:37.000Z","updated":"2019-10-26T03:06:20.000Z","comments":true,"path":"2019/08/01/luogu4094/","link":"","permalink":"https://ytxytx.github.io/2019/08/01/luogu4094/","excerpt":"题目描述给定字符串$S$，多次询问$S[a:b]$的子串和$S[c:d]$的最长公共前缀的最大值","text":"题目描述给定字符串$S$，多次询问$S[a:b]$的子串和$S[c:d]$的最长公共前缀的最大值 题解后缀自动机不方便处理前缀，首先反转$S$，转化为询问后缀 一个容易发现的事实是，如果最长公共前缀长度为$L$，那么一定存在$0\\sim L-1$的每一种答案 由于后缀自动机上每个结点的$endpos$集合是$parent$树上儿子$endpos$的并，可以用线段树合并预处理出来 每次询问，因为反转了串，先转换读入的区间 二分答案$Ans$，转化为$S[d-Ans+1:d]$是否是$S[a:b]$的子串，判定性问题 令转换后的询问为$a,b,c,d$，在前缀串$S[1:d]$所在结点到根的链上，利用维护的$len$值倍增找到$S[d-Ans+1:d]$所在的结点（$Ans=0$即为$\\varnothing$串） 如果$S[a:b]$中存在串$S[d-Ans+1:d]$，则意味着所在结点的$endpos$集合中存在$(a+Ans,b]$中的某个值 如果不存在则减小二分的答案 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;int n,m;char S[300000];struct edge&#123;int to,nxt;&#125;E[300000];int H[300000],tot;void add_edge(int a,int b)&#123;E[++tot]=(edge)&#123;b,H[a]&#125;,H[a]=tot;&#125;struct SegmentTree&#123; struct node&#123; node *L,*R; node()&#123;L=R=NULL;&#125; &#125;; node *root; void insert(node *&amp;now,int l,int r,int v)&#123; if (!now) now=new node; if (l==r) return; int mdl=(l+r)&gt;&gt;1; if (v&lt;=mdl) insert(now-&gt;L,l,mdl,v); else insert(now-&gt;R,mdl+1,r,v); &#125; bool query(node *now,int l,int r,int L,int R)&#123; if (l&gt;R||r&lt;L||!now) return false; if (L&lt;=l&amp;&amp;r&lt;=R) return true; int mdl=(l+r)&gt;&gt;1; return query(now-&gt;L,l,mdl,L,R)|query(now-&gt;R,mdl+1,r,L,R); &#125; SegmentTree()&#123;root=NULL;&#125;&#125;;SegmentTree::node * merge(SegmentTree::node *&amp;A,SegmentTree::node *&amp;B)&#123; if (!(A&amp;&amp;B)) return A?A:B; SegmentTree::node *nw=new SegmentTree::node; nw-&gt;L=merge(A-&gt;L,B-&gt;L); nw-&gt;R=merge(A-&gt;R,B-&gt;R); return nw;&#125;struct SAM&#123; struct node&#123; int son[26],len,link; SegmentTree S; node()&#123; memset(son,0xff,sizeof(int)*26); len=link=0; &#125; &#125;T[300000]; int tot,lst,f; int insert(char C)&#123; C-='a'; int q=++tot,p=lst; lst=q,f++; T[q].S.insert(T[q].S.root,1,n,f); T[q].len=T[p].len+1; while (~p&amp;&amp;!~T[p].son[C]) T[p].son[C]=q,p=T[p].link; if (!~p) return q; int np=T[p].son[C]; if (T[p].len+1==T[np].len) T[q].link=np; else&#123; int nq=++tot; memcpy(T[nq].son,T[np].son,sizeof(int)*26); T[nq].len=T[p].len+1; T[nq].link=T[np].link; T[q].link=T[np].link=nq; while (~p&amp;&amp;T[p].son[C]==np) T[p].son[C]=nq,p=T[p].link; &#125; return q; &#125; SAM()&#123;tot=lst=0,T[0].link=-1;&#125;&#125;G;int Fa[300000][19],B[300000];void pre(int now)&#123; for (int i=H[now];i;i=E[i].nxt)&#123; Fa[E[i].to][0]=now; for (int j=1;j&lt;19;j++) Fa[E[i].to][j]=Fa[Fa[E[i].to][j-1]][j-1]; pre(E[i].to); G.T[now].S.root=merge(G.T[now].S.root,G.T[E[i].to].S.root); &#125;&#125;int jump(int now,int len)&#123; for (int i=18;~i;i--) if (G.T[Fa[now][i]].len&gt;=len) now=Fa[now][i]; return now;&#125;int a,b,c,d;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); scanf(\"%s\",S); std::reverse(S,S+n); for (int i=0;i&lt;n;i++) B[i+1]=G.insert(S[i]); for (int i=1;i&lt;=G.tot;i++) add_edge(G.T[i].link,i); pre(0); while (m--)&#123; scanf(\"%d%d%d%d\",&amp;b,&amp;a,&amp;d,&amp;c); a=n-a+1,b=n-b+1,c=n-c+1,d=n-d+1; int L=0,R=std::min(d-c+1,b-a+1),mdl; while (L&lt;R)&#123; mdl=(L+R+1)&gt;&gt;1; int id=jump(B[d],mdl); if (G.T[id].S.query(G.T[id].S.root,1,n,a+mdl-1,b)) L=mdl; else R=mdl-1; &#125; printf(\"%d\\n\",L); &#125;&#125;","categories":[],"tags":[{"name":"后缀自动机","slug":"后缀自动机","permalink":"https://ytxytx.github.io/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"线段树合并","slug":"线段树合并","permalink":"https://ytxytx.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/"},{"name":"倍增","slug":"倍增","permalink":"https://ytxytx.github.io/tags/%E5%80%8D%E5%A2%9E/"}]},{"title":"hihoCoder 1193 树堆","slug":"hiho1193","date":"2019-07-25T14:29:12.000Z","updated":"2019-10-26T03:06:17.000Z","comments":true,"path":"2019/07/25/hiho1193/","link":"","permalink":"https://ytxytx.github.io/2019/07/25/hiho1193/","excerpt":"题目描述给定$n$个结点的带权有根树 可以进行多次操作，每次删去一个结点，并把它的所有孩子直接接到它的父亲上 要求若干次操作后形成的有根树是一个树堆 对每个结点询问它的子树最大能形成多大的树堆","text":"题目描述给定$n$个结点的带权有根树 可以进行多次操作，每次删去一个结点，并把它的所有孩子直接接到它的父亲上 要求若干次操作后形成的有根树是一个树堆 对每个结点询问它的子树最大能形成多大的树堆 题解先考虑一个朴素的dp 令$F_{i,v}$表示在$i$号结点所在的子树中，所有点的点权均不大于$v$，最大能形成多大的树堆（或者说是树堆森林，可以在最顶端接一个点将森林连成树） 有一个显然的事实是，$F_{i,v}$是随$v$增加单调不降的，因为限制的点权越大，限制越松 设当前点权为$w_i$ 当$v&lt;w_i$时，当前点不能被选择，只能直接转移 $$ F_{i,v}=\\sum_{u\\in i.son}{F_{u,v}} $$ 当$v\\geq w_i$时，可以选择当前点（同时也将森林连成了树） $$ F_{i,v}=\\sum_{u\\in i.son}{\\max(F_{u,v},F_{i,w_i}+1)} $$ 事实上，这个转移可以被看做先全部当成第一个转移，再将下标大于$w_i$的对$F_{i,w_i}+1$取$\\max$ 当成第一种转移合并的时候可以考虑用线段树合并解决 但是线段树合并不太支持维护区间对某个数取$\\max$ 因此利用$F$的单调性优化 因为每次只对$F_{i,w_i}+1$取$\\max$，所以影响到的只会是值等于$F_{i,w_i}$的那一段 在线段树上二分找到最右的值等于$F_{i,w_i}$的位置 然后给这段区间$+1$即可，把区间取$\\max$转化为了区间加，就可以用线段树合并维护了 时间复杂度$O(n\\log n)$ Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;iostream&gt;#include&lt;cstdio&gt;int n;struct node&#123; node *L,*R; int tag,rst; node()&#123;L=R=NULL,tag=rst=0;&#125;&#125;;void puttag(node *now,int v)&#123;now-&gt;tag+=v,now-&gt;rst+=v;&#125;void pushdown(node *now)&#123; if (!now-&gt;L) now-&gt;L=new node; if (!now-&gt;R) now-&gt;R=new node; puttag(now-&gt;L,now-&gt;tag),puttag(now-&gt;R,now-&gt;tag); now-&gt;tag=0;&#125;void update(node *now)&#123;now-&gt;rst=now-&gt;R-&gt;rst;&#125;struct SegmentTree&#123; node *root; void modify(node *&amp;o,int l,int r,int L,int R)&#123; if (l&gt;R||r&lt;L) return; if (!o) o=new node; if (L&lt;=l&amp;&amp;r&lt;=R) puttag(o,1); else&#123; pushdown(o); int mdl=(l+r)&gt;&gt;1; modify(o-&gt;L,l,mdl,L,R),modify(o-&gt;R,mdl+1,r,L,R); update(o); &#125; &#125; int query(node *o,int l,int r,int k)&#123; if (l==r) return o-&gt;rst; pushdown(o); int mdl=(l+r)&gt;&gt;1; if (k&lt;=mdl) return query(o-&gt;L,l,mdl,k); else return query(o-&gt;R,mdl+1,r,k); &#125; int findrpos(node *o,int l,int r,int k)&#123; if (l==r)&#123; if (o-&gt;rst&gt;k) return l-1; else return l; &#125; pushdown(o); int mdl=(l+r)&gt;&gt;1; if (o-&gt;L-&gt;rst&lt;=k) return findrpos(o-&gt;R,mdl+1,r,k); else return findrpos(o-&gt;L,l,mdl,k); &#125; SegmentTree()&#123;root=new node;&#125;&#125;S[200000];node * merge(node *L,node *R)&#123; if (!L||!R) return L?L:R; L-&gt;L=merge(L-&gt;L,R-&gt;L),L-&gt;R=merge(L-&gt;R,R-&gt;R); L-&gt;rst+=R-&gt;rst,L-&gt;tag+=R-&gt;tag; delete R; return L;&#125;int val[200000];struct edge&#123;int to,nxt;&#125;E[500000];int H[200000],tot;void add_edge(int a,int b)&#123; E[++tot]=(edge)&#123;b,H[a]&#125;;H[a]=tot; E[++tot]=(edge)&#123;a,H[b]&#125;;H[b]=tot;&#125;int ans[200000];void solve(int now,int fa)&#123; for (int i=H[now];i;i=E[i].nxt)&#123; if (E[i].to==fa) continue; solve(E[i].to,now); merge(S[now].root,S[E[i].to].root); &#125; int v=S[now].query(S[now].root,0,1000000000,val[now]); int rp=S[now].findrpos(S[now].root,0,1000000000,v); S[now].modify(S[now].root,0,1000000000,val[now],rp); ans[now]=v+1;&#125;int main()&#123; scanf(\"%d\",&amp;n); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;val[i]); for (int i=1,x,y;i&lt;n;i++) scanf(\"%d%d\",&amp;x,&amp;y),add_edge(x+1,y+1); solve(1,0); for (int i=1;i&lt;=n;i++) printf(\"%d \",ans[i]);&#125;","categories":[],"tags":[{"name":"线段树合并","slug":"线段树合并","permalink":"https://ytxytx.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/"}]}]}