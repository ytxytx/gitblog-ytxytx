<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>成都七中WC联训 总结与反思</title>
      <link href="/2019/12/02/summary-cdqz2019/"/>
      <url>/2019/12/02/summary-cdqz2019/</url>
      
        <content type="html"><![CDATA[<p>经历了8天在成都七中的训练，真实地感受到自己水平欠缺，实力悬殊。</p><p>自己写一写总结，给时间所剩不多的PKUWC认真做个规划。</p><p>8天的集训，24道题，现场A掉的只有1题，相比前面的选手有能力A掉大半的题，自己却连骗分也不会，真正该审视一下这半年来的学习情况了。</p><p>这次考核，发现自己在各种算法上都有欠缺，并且在思维上也暴露出很大的缺陷。</p><p>且抛开那些尚未普及的算法，比如拟阵交，比如Nim积，剩下的题目重点考察了对题目探求的深度和思维，而大多不是以某种特定的算法或数据结构为主体，比如发现性质，比如构造。</p><p>为了准备二十天后的PKUWC，只能在这些方面下功夫，算是速学一下，Codeforces和AtCoder上的题就比较符合这种类型，要多做。</p><p>自己薄弱的另外一块内容是数据结构和树剖一类，做这些题比较能锻炼代码能力，以及对数据维护的思考。</p><p>对于每次的模拟测试，要认真对待，考完后尽自己所能把题目订正完，经过考场思考的题目再订正起来效果会更好一点。</p><p>真心希望自己的努力可以得到预期的回报，不负韶华，不负本心。</p>]]></content>
      
      
      <categories>
          
          <category> 游记/随想 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSP 2019 游记</title>
      <link href="/2019/11/19/CSP2019/"/>
      <url>/2019/11/19/CSP2019/</url>
      
        <content type="html"><![CDATA[<p>CSP-S 2019 游记</p><a id="more"></a><h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p>最近的一个月，几乎每天都有模拟测试，或者在下午，或者在晚上。</p><p>今天上午就是喜闻乐见的“胜利模拟赛”，也是CSP前的最后一场模拟。教练从cf上选了三道2000上下的题组成一套：</p><blockquote><p>T1：<a href="https://codeforces.com/problemset/problem/24/A" target="_blank" rel="noopener">“[CF24A]Ring road”</a><br>T2：<a href="https://codeforces.com/problemset/problem/254/C" target="_blank" rel="noopener">“[CF254C]Anagram”</a><br>T3：<a href="https://codeforces.com/problemset/problem/852/E" target="_blank" rel="noopener">“[CF852E]Casinos and travel”</a></p></blockquote><p>T1问题不大；</p><p>T2真实降智题，想了好久才做出来，结果把一个数组开成char类型直接人没；</p><p>T3问题不大，但是有一处<code>static_cast&lt;long long&gt;(A)*B</code>打成<code>static_cast&lt;long long&gt;(A*B)</code>又人没了。</p><p>信心赛表现成这样，大概正式比赛会好些？</p><p>下午两点，一起坐校车出发前往杭州。</p><p>由于初中部受到诺如病毒的侵扰，这回初高中强制分成了两辆车。</p><p>车上听会儿歌，打会儿游戏<del>（为什么又没人打雀了啊）</del>，聊会儿天，在车上颠簸两个小时就到了。</p><p>杭州给我的第一印象是：太挤。高楼密布的环境让我有些不适应，抬头望不尽天空，着实会让人喘不过气来。</p><p>下车状态有点糟，或许是水土不服，大概八点就睡下了，有些小紧张，但疲惫还是占了上风，这也与近阶段高压的训练状态脱不了干系。</p><p>也不得不感叹自己本身就不是那种能熬夜的人，每每看到同学深夜打cf第二天又能精力充沛地上课总是既羡慕又无奈。</p><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>睡到六点十五，是学校起床铃响的时间，早饭挺糟糕，草草吃完就上路了。那时候才真正感觉到，CSP就在眼前了。</p><p>进了考场，地下室挺空旷，挺干净。自己坐的那把凳子下刚好垫了一块木板，一侧高一侧低，不过也没有大影响。面前就是教学用的电子屏，各种通知都能第一时间看到。</p><p>很快就开始考试了，在已经响起的嘈杂的键盘声中，我尽量使自己冷静下来，先看完题。</p><p>按照惯例，T1应该是很简单的，但是题面稍微有点长，一开始脑子乱看不进去，就先看看T2。</p><p>T2树上括号序列，看起来不是难题，有了大方向，再回过头去看看T1，再看看T3。</p><p>看题加上T1码完，大概半个小时多过去了，开始刚T2。</p><p>大约刚了1h多，T2也码完加对拍过了。</p><p>看起来时间并不紧迫，开T3。</p><p>一开始毫无头绪，看看链，菊花，感觉还是没有思路。就这样迷茫了半个多小时，出去呼吸了一下新鲜空气（氨气），回来继续刚。</p><p>把轨迹画出来试试？嗯？是不是一个环路啊。感觉能贪心？理了理思路，大概又过去十几分钟，这时候只剩下一个半小时左右了。</p><p>码码码，码的差不多了，也有点担心自己的贪心是假的，又花了点时间写了阶乘的暴力，调试，样例过了！</p><p>大屏幕上跳动的时间似乎也使内心的希望跳动起来。</p><p>和暴力拍上，假了，调试。调掉了一个锅，继续再拍。嗯？不对劲，手模一下假掉了？当场就开始慌了。大约只剩下10分钟了，前两题的文件输入输出还没加上，赶紧先加上，保住前两题再说。</p><p>“保住前两题”大概已经是我仅剩的一些理智了。接下来的十分钟，完完全全就慌掉了。看看自己T3还剩几分？链能过吗？菊花能过吗？都过不了。这样不行啊，赶紧把写的暴力拉进来，能拿几分是几分了。套进一个namespace，去掉几个变量，匆匆忙忙判了一下10分的部分分，完全没有管“删掉多余文件”的要求，可是最终再拿到自己的代码使才发现判成$n\leq 8$了。</p><p>一考完状态非常差，人都要站不住了，两腿发软，对刚才的经历心有余悸。面包和水都没有动过。Day 1如果只有210，放在历年这并不是一个好的结果，况且在仅剩的理智快被耗尽的时候，我也没法确保前两题完全不出差错。</p><p>出了考场，想哭但是又不习惯于哭。也许本不该把这次比赛看得太重，也许只是因为紧张过后的余悸。耳边也传过一些谈论的话语，似乎大家对T3的看法分化严重，或者做出，或者只有10分，并且后者占了大多数。这多多少少给了我一些慰藉，使我糟糕的状态不至于持续太久。</p><p>中午吃完饭又在宾馆里躺了一个小时，爸爸给了我太多的鼓励和安慰。他不曾要求过我要有多优秀，他给我印象最深的一句话是：“只要不忘记自己学信息的初心，尽力完成比赛就好了。”</p><p>关于我与OI的缘分，和我学OI的初心，在此展开就显得有些不妥了，但这句话，确乎是给了我很大的启发。</p><p>下午爸爸带着我去钱塘江边散心。在江边可以清楚地看见对岸，仍然是高楼林立，这不禁令我有些失望。拍了些照片，和爸爸一起走了很远，又骑着共享单车慢慢骑回来，直到夕阳西下。我已记不清上次骑车是在何时，但这一定是我骑行最远的一次，也是我骑车上路的第一次。</p><p>钱塘江有涨潮与落潮，正如这条OI路上有喜悦，也有不尽人意。既然第一天结果无法改变，那就专心为Day 2准备吧。</p><h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><p>早饭换了一处吃，不那么糟糕了，但胃口不好，吃不下太多。</p><p>还是那个座位，但我并不那么紧张了，反而更加有了信心。</p><p>比赛开始，按照习惯，我还是先花六七分钟通读了一遍题面，借此机会使自己冷静下来。</p><p>T1不像往年那么能切，而且又是中长题面；T2第一反应像是斜率优化；T3一眼大概是个数据结构题。</p><p>先按顺序开，T1想到容斥，只是第一反应有些不可思议，T1放个容斥不像往年的风格。很快就想到$O(n^3m)$的做法了，可是无奈被降智，止步于此了。</p><p>看看T2，再看看T3，对数据结构题没什么兴趣，也没什么感觉（虽然可能不是个数据结构题？），那就先做T2。</p><p>如果是斜率优化一定可以写出转移方程，但设计状态的时候总感觉第二维那么大，大概行不通？</p><p>冒出一个贪心的念头，大力猜了波结论，写了发$O(n^2)$，一遍就把大小样例都过了，再拍一拍，过拍了。看起来走对路了！想想优化，好像单调队列就完事了？88分到手，高精先搁一搁，先做T3。</p><p>还剩一个半小时多，T3普遍的线段树合并做法我无力想下去了，本来数据结构基础就薄弱。部分分有75分，那就写吧。</p><p>暴力和链都很简单，完美二叉树想了一会儿，稍微花了点时间，多测了几遍，还剩半个小时左右。</p><p>写高精还得把解码方式读一遍实现一遍，而且没怎么写过高精风险还是有的，估了估时间，那就不写了，也就-12pts。</p><p>一直很担心Day 1会因为慌张写错文件等等，所以Day 2留足了时间检查。算了算如果写的分都拿到，还是挺可观的，所以一遍一遍地测，生怕自己挂分。</p><p>考完状态比Day 1好多了，比起Day 2，最担心的仍然是Day 1。</p><p>考完就坐上校车离开了，下午晚上都在家里躺着，没去学校，什么都不想做。</p><h2 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h2><p>没有休息的时间，返校正常上课了。上完一、二两节课就来机房等估分。</p><p>估分出来前，总有一种进退两难的感觉，于是心不在焉，不想学文化课，也不想打代码，静不下心。</p><p>zgz咕咕咕，导致这天并没有公布选手源程序，白白荒废了一天。</p><h2 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h2><p>终于公布选手源程序了，几乎发布三分钟内就把包下载了下来，赶紧测。</p><p>结果和预想的一样，除了D1T3提到的判成$n\leq 8$的失误。</p><p>悬着的心终于可以放下，我的OI之路至少幸运的没有在这个关头终结。比起含着不舍写下“告别”的选手，可以继续走下去，这是多少选手可望而不可即，是莫大的幸运了。</p>]]></content>
      
      
      <categories>
          
          <category> 游记/随想 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GCC 的 builtin 函数整理</title>
      <link href="/2019/11/10/builtins/"/>
      <url>/2019/11/10/builtins/</url>
      
        <content type="html"><![CDATA[<p>这篇文章主要用来记录常用的builtin函数，更详细的可以参阅<a href="https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html#Other-Builtins" target="_blank" rel="noopener">文档</a></p><a id="more"></a><p>$\texttt{108=(01101100)}_\texttt{2}$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __builtin_ffs(<span class="keyword">int</span> x);</span><br><span class="line"><span class="keyword">int</span> __builtin_ffsl(<span class="keyword">long</span> x);</span><br><span class="line"><span class="keyword">int</span> __builtin_ffsll(<span class="keyword">long</span> <span class="keyword">long</span> x);</span><br><span class="line"></span><br><span class="line">__builtin_ffs(<span class="number">108</span>)=<span class="number">3</span></span><br></pre></td></tr></table></figure><blockquote><p>$x$最低$1$位置加一，如果$x=0$则值为$0$</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __builtin_clz(<span class="keyword">unsigned</span> <span class="keyword">int</span> x);</span><br><span class="line"><span class="keyword">int</span> __builtin_clzl(<span class="keyword">unsigned</span> <span class="keyword">long</span> x);</span><br><span class="line"><span class="keyword">int</span> __builtin_clzll(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> x);</span><br><span class="line"></span><br><span class="line">__builtin_clz(<span class="number">108</span>)=<span class="number">25</span></span><br></pre></td></tr></table></figure><blockquote><p>$x$最高位起连续$0$位数，如果$x=0$则未定义</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __builtin_ctz(<span class="keyword">unsigned</span> <span class="keyword">int</span> x);</span><br><span class="line"><span class="keyword">int</span> __builtin_ctzl(<span class="keyword">unsigned</span> <span class="keyword">long</span> x);</span><br><span class="line"><span class="keyword">int</span> __builtin_ctzll(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> x);</span><br><span class="line"></span><br><span class="line">__builtin_clz(<span class="number">108</span>)=<span class="number">2</span></span><br></pre></td></tr></table></figure><blockquote><p>$x$最低位起连续$0$位数，如果$x=0$则未定义</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __builtin_clrsb(<span class="keyword">int</span> x);</span><br><span class="line"><span class="keyword">int</span> __builtin_clrsbl(<span class="keyword">long</span> x);</span><br><span class="line"><span class="keyword">int</span> __builtin_clrsbll(<span class="keyword">long</span> <span class="keyword">long</span> x);</span><br><span class="line"></span><br><span class="line">__builtin_clrsb(<span class="number">108</span>)=<span class="number">24</span></span><br><span class="line">__builtin_clrsb(<span class="number">-1</span>)=<span class="number">31</span></span><br></pre></td></tr></table></figure><blockquote><p>可以认为是$x$最高位开始连续相同位长度减一</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __builtin_popcount(<span class="keyword">unsigned</span> <span class="keyword">int</span> x);</span><br><span class="line"><span class="keyword">int</span> __builtin_popcountl(<span class="keyword">unsigned</span> <span class="keyword">long</span> x);</span><br><span class="line"><span class="keyword">int</span> __builtin_popcountll(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> x);</span><br><span class="line"></span><br><span class="line">__builtin_popcount(<span class="number">108</span>)=<span class="number">4</span></span><br></pre></td></tr></table></figure><blockquote><p>$x$中$1$位个数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __builtin_parity(<span class="keyword">unsigned</span> <span class="keyword">int</span> x);</span><br><span class="line"><span class="keyword">int</span> __builtin_parityl(<span class="keyword">unsigned</span> <span class="keyword">long</span> x);</span><br><span class="line"><span class="keyword">int</span> __builtin_parityll(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> x);</span><br><span class="line"></span><br><span class="line">__builtin_parity(<span class="number">108</span>)=<span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p>$x$中$1$位个数的奇偶性</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint16_t</span> __builtin_bswap16(<span class="keyword">uint16_t</span> x);</span><br><span class="line"><span class="keyword">uint32_t</span> __builtin_bswap32(<span class="keyword">uint32_t</span> x);</span><br><span class="line"><span class="keyword">uint64_t</span> __builtin_bswap64(<span class="keyword">uint64_t</span> x);</span><br><span class="line"></span><br><span class="line">__builtin_bswap32(<span class="number">108</span>)=<span class="number">1811939328</span></span><br></pre></td></tr></table></figure><blockquote><p>高低位翻转$x$的二进制位</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法/技巧 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 585F Digits of Number Pi</title>
      <link href="/2019/11/07/cf585f/"/>
      <url>/2019/11/07/cf585f/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定字符集为数位（0-9）的字符串$S$</p><p>给定相同位数$d$的上下界$L,R$，没有前导零</p><p>求所有$L\leq x\leq R$，满足$x$中存在至少$\lfloor\frac{d}{2}\rfloor$的连续位在$S$中作为子串出现的个数</p><p>$1\leq |S|\leq 1000;2\leq d\leq 50$，对$10^9+7$取模</p><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>对$S$中所有长度为$\lfloor\frac{d}{2}\rfloor$的子串建出AC自动机</p><p>如果单独考虑一个$x$，只要$x$在自动机上走到过尾节点，$x$就满足条件</p><p>在AC自动机上数位dp，定义状态$F_{now,pos,0/1,0/1,0/1}$为当前考虑到$now$位（从高到低），在自动机上走到$pos$，是否被上界$R$限制，是否被下界$L$限制，是否到达过尾节点</p><p>其边界状态为$F_{d,pos,0/1,0/1,vis}=vis$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> S[<span class="number">1050</span>],A[<span class="number">70</span>],B[<span class="number">70</span>];</span><br><span class="line"><span class="keyword">int</span> len,D;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ACautomaton</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> son[<span class="number">10</span>],dep,fail;</span><br><span class="line"><span class="keyword">bool</span> ed;</span><br><span class="line">&#125;T[<span class="number">50000</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *S,<span class="keyword">int</span> len=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!~len) len=<span class="built_in">strlen</span>(S);</span><br><span class="line"><span class="keyword">int</span> now=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> &amp;nxt=T[now].son[S[i]-<span class="string">'0'</span>];</span><br><span class="line"><span class="keyword">if</span> (!nxt) nxt=++tot;</span><br><span class="line">T[nxt].dep=T[now].dep+<span class="number">1</span>;</span><br><span class="line">now=nxt;</span><br><span class="line">&#125;</span><br><span class="line">T[now].ed=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (T[<span class="number">1</span>].son[i]) Q.push(T[<span class="number">1</span>].son[i]),T[T[<span class="number">1</span>].son[i]].fail=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> T[<span class="number">1</span>].son[i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!Q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> now=Q.front();</span><br><span class="line">Q.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"> <span class="keyword">if</span> (T[now].son[i]) Q.push(T[now].son[i]),T[T[now].son[i]].fail=T[T[now].fail].son[i];</span><br><span class="line"> <span class="keyword">else</span> T[now].son[i]=T[T[now].fail].son[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ACautomaton()&#123;tot=<span class="number">1</span>;&#125;</span><br><span class="line">&#125;T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">chkinc</span><span class="params">(<span class="keyword">int</span> &amp;A)</span></span>&#123;A+=A&gt;&gt;<span class="number">31</span>&amp;mod;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">55</span>][<span class="number">50000</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> pos,<span class="keyword">bool</span> upper=<span class="literal">true</span>,<span class="keyword">bool</span> lower=<span class="literal">true</span>,<span class="keyword">bool</span> vis=<span class="literal">false</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (now==D) <span class="keyword">return</span> vis;</span><br><span class="line"><span class="keyword">int</span> &amp;nowdp=dp[now][pos][upper][lower][vis];</span><br><span class="line"><span class="keyword">if</span> (~nowdp) <span class="keyword">return</span> nowdp;</span><br><span class="line"><span class="keyword">int</span> L=lower?A[now]-<span class="string">'0'</span>:<span class="number">0</span>,R=upper?B[now]-<span class="string">'0'</span>:<span class="number">9</span>;</span><br><span class="line">nowdp=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=L;i&lt;=R;i++) chkinc(nowdp+=DP(now+<span class="number">1</span>,T.T[pos].son[i],upper&amp;&amp;i==R,lower&amp;&amp;i==L,vis||T.T[T.T[pos].son[i]].ed)-mod);</span><br><span class="line"><span class="keyword">return</span> nowdp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0xff</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%s%s"</span>,S,A,B);</span><br><span class="line">len=<span class="built_in">strlen</span>(S);</span><br><span class="line">D=<span class="built_in">strlen</span>(A);</span><br><span class="line"><span class="keyword">if</span> (D/<span class="number">2</span>&gt;len) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>),<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len-D/<span class="number">2</span>+<span class="number">1</span>;i++) T.insert(S+i,D/<span class="number">2</span>);</span><br><span class="line">T.make();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,DP(<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 做题记录 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC自动机 </tag>
            
            <tag> 数位dp </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kyoya and Train</title>
      <link href="/2019/11/01/cf553e/"/>
      <url>/2019/11/01/cf553e/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一张$n$个点$m$条有向边的图，</p><p>对于每条边$e$，有$P_{e,t}$的概率花费$t$单位时间通过，代价为$c_e$</p><p>从$1$走到$n$，如果超过时限$T$则额外付出代价$x$</p><p>求期望代价最小值</p><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先考虑一个dp：</p><p>令$F_{i,t}$表示走到$i$，已经用了$t$时间，余下路程的最小期望代价</p><p>令$\operatorname{dis}(i,j)$表示从$i$走到$j$的最小代价（最短路）</p><p>对于$t&gt;T$，既然已经超时，不如直接走最短路花费最小</p><p>$$ F_{i,t}=\operatorname{dis}(i,n)+x $$</p><p>否则抱有一丝希望</p><p>$$ F_{i,j}=\min_{e\in E,x_e=i}\left(c_e+\sum_{k=1}^{T}F_{y_e,j+k}\cdot P_{e,k}\right) $$</p><p>令</p><p>$$ S_{e,j}=\sum_{k=1}^{T}F_{y_e,j+k}\cdot P_{e,k} $$</p><p>那么</p><p>$$ F_{i,j}=\min_{e\in E,x_e=i}(c_e+S_{e,j}) $$</p><p>至此，可以使用分治FFT完成$F$和$S$的计算，对<strong>已经耗费的时间</strong>分治</p><p>具体的，对于分治区间$[L,R]$：</p><p>如果$L=R$，那么$F_{i,L}$可以用对应的$S$转移得到</p><p>否则，先分治右半边，然后用右半边的$F$更新左半边的$S$（FFT），再分治左半边</p><p>时间复杂度为$O(mT\log^2T)$，注意实现的常数</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">double</span> A,B;</span><br><span class="line">Complex():A(<span class="number">0</span>),B(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">Complex(<span class="keyword">double</span> A_):A(A_),B(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">Complex(<span class="keyword">double</span> A_,<span class="keyword">double</span> B_):A(A_),B(B_)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span> + (<span class="keyword">const</span> Complex &amp;A,<span class="keyword">const</span> Complex &amp;B)&#123;<span class="keyword">return</span> Complex(A.A+B.A,A.B+B.B);&#125;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span> - (<span class="keyword">const</span> Complex &amp;A,<span class="keyword">const</span> Complex &amp;B)&#123;<span class="keyword">return</span> Complex(A.A-B.A,A.B-B.B);&#125;</span><br><span class="line"><span class="keyword">inline</span> Complex <span class="keyword">operator</span> * (<span class="keyword">const</span> Complex &amp;A,<span class="keyword">const</span> Complex &amp;B)&#123;<span class="keyword">return</span> Complex(A.A*B.A-A.B*B.B,A.A*B.B+A.B*B.A);&#125;</span><br><span class="line"><span class="keyword">inline</span> Complex &amp; <span class="keyword">operator</span> /= (Complex &amp;A,<span class="keyword">const</span> <span class="keyword">double</span> B)&#123;<span class="keyword">return</span> A.A/=B,A.B/=B,A;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">70</span>][<span class="number">70</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,t,x;</span><br><span class="line"><span class="keyword">int</span> A[<span class="number">105</span>],B[<span class="number">105</span>],C[<span class="number">105</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; son[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">double</span> P[<span class="number">105</span>][<span class="number">40050</span>];</span><br><span class="line"><span class="keyword">double</span> S[<span class="number">105</span>][<span class="number">40050</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> dp[<span class="number">105</span>][<span class="number">40050</span>];</span><br><span class="line"></span><br><span class="line">Complex tmp1[<span class="number">200000</span>],tmp2[<span class="number">200000</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi=acosl(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">Complex w[<span class="number">200000</span>],wn[<span class="number">200000</span>];</span><br><span class="line"><span class="keyword">int</span> lim,lims,rev[<span class="number">200000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFTinit</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">w[<span class="number">0</span>]=<span class="number">1</span>,lim=<span class="number">1</span>,lims=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (lim&lt;N) lim&lt;&lt;=<span class="number">1</span>,lims++;</span><br><span class="line"><span class="function">Complex <span class="title">g</span><span class="params">(cosl(<span class="number">2</span>*pi/lim),sinl(<span class="number">2</span>*pi/lim))</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;lim;i++) w[i]=w[i<span class="number">-1</span>]*g;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;lim;i++) rev[i]=rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>|(i&amp;<span class="number">1</span>)&lt;&lt;lims;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex *V,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++) <span class="keyword">if</span> (rev[i]&gt;i) <span class="built_in">std</span>::swap(V[rev[i]],V[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;lim;i&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>,t=lim/i/<span class="number">2</span>;j&lt;i;j++) wn[j]=w[j*t];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;lim;j+=i+i)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;k++)&#123;</span><br><span class="line">Complex X=V[j+k],Y=V[i+j+k]*wn[k];</span><br><span class="line">V[j+k]=X+Y,V[i+j+k]=X-Y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!f)&#123;</span><br><span class="line"><span class="built_in">std</span>::reverse(V+<span class="number">1</span>,V+lim);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;lim;k++) V[k]/=lim;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L==R)&#123;</span><br><span class="line"><span class="keyword">if</span> (L&gt;t) <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[i][L]=dis[i][n]+x;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">dp[i][L]=<span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">double</span>&gt;::max();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=son[i].begin();it!=son[i].end();++it)</span><br><span class="line">dp[i][L]=<span class="built_in">std</span>::min(dp[i][L],S[*it][L]+C[*it]);</span><br><span class="line">&#125;</span><br><span class="line">dp[n][L]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mdl=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">solve(mdl+<span class="number">1</span>,R);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">FFTinit(R-L+<span class="number">2</span>+R-mdl+<span class="number">2</span>);</span><br><span class="line">sum+=lim;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;lim;j++) tmp1[j]=Complex();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;lim;j++) tmp2[j]=Complex();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=mdl+<span class="number">1</span>;j&lt;=R;j++) tmp1[j-mdl]=dp[B[i]][j];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=R-L+<span class="number">1</span>;j++) tmp2[R-L-j+<span class="number">2</span>]=P[i][j];</span><br><span class="line">FFT(tmp1,<span class="number">1</span>),FFT(tmp2,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;lim;j++) tmp1[j]=tmp1[j]*tmp2[j];</span><br><span class="line">FFT(tmp1,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=L;j&lt;=mdl;j++) S[i][j]+=tmp1[R-L+<span class="number">2</span>-(mdl-j)].A;</span><br><span class="line">&#125;</span><br><span class="line">solve(L,mdl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;t,&amp;x);</span><br><span class="line"><span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dis[i][i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;A[i],&amp;B[i],&amp;C[i]);</span><br><span class="line">son[A[i]].push_back(i);</span><br><span class="line">dis[A[i]][B[i]]=C[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=t;j++) <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;P[i][j]),P[i][j]/=<span class="number">100000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">dis[i][j]=<span class="built_in">std</span>::min(dis[i][j],dis[i][k]+dis[k][j]);</span><br><span class="line">solve(<span class="number">0</span>,t+t);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.8lf\n"</span>,dp[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 做题记录 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FFT 快速傅里叶变换 </tag>
            
            <tag> DP 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lydsy 4231 回忆树</title>
      <link href="/2019/10/28/lydsy4231/"/>
      <url>/2019/10/28/lydsy4231/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一棵无根树，每条树边上有单个小写字母</p><p>多次询问，给定$u,v,S$，表示询问$S$在$u$到$v$路径组成的字符串中出现了几次</p><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>$S$在$u$到$v$路径上出现，分两种情况讨论：</p><ol><li><p>$S$跨过$\operatorname{LCA}(u,v)$</p></li><li><p>$S$不跨过$\operatorname{LCA}(u,v)$</p></li></ol><p>对于第一种情况，将$\operatorname{LCA}$附近一小段字符串取出来做kmp，其长度不超过$2|S|$</p><p>重点讨论第二种情况，每一个询问右侧拆成到根的两个询问，左侧拆成其询问串反串的两个询问</p><p>做完以上转化，现在问题大体变成若干询问：</p><p>$S$在$1$到$u$的路径上组成的字符串中出现几次</p><p>对于所有询问串（及其反串）建出AC自动机，并得到其fail树的dfs序</p><p>离线记录原树上每个节点的询问</p><p>dfs原树，同时记录其在AC自动机上走到的节点，将其权$+1$，回溯的时候$-1$</p><p>处理每个节点的所有询问就是该询问串在fail树上的子树和，用树状数组维护</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,Q;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,nxt;</span><br><span class="line"><span class="keyword">char</span> C;</span><br><span class="line">&#125;E[<span class="number">200050</span>];</span><br><span class="line"><span class="keyword">int</span> H[<span class="number">100050</span>],tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">char</span> v)</span></span>&#123;</span><br><span class="line">E[++tot]=(edge)&#123;b,H[a],v&#125;;H[a]=tot;</span><br><span class="line">E[++tot]=(edge)&#123;a,H[b],v&#125;;H[b]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">char</span> o;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> X[<span class="number">100050</span>],Y[<span class="number">100050</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str[<span class="number">100050</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> FenwickMax;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fenwick</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> F[<span class="number">600050</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span>&#123;<span class="keyword">while</span> (x&lt;=FenwickMax) F[x]+=v,x+=x&amp;-x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">int</span> ret=<span class="number">0</span>;<span class="keyword">while</span> (x) ret+=F[x],x&amp;=x<span class="number">-1</span>;<span class="keyword">return</span> ret;&#125;</span><br><span class="line">&#125;F;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AC</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> son[<span class="number">26</span>],fail;</span><br><span class="line">node()&#123;<span class="built_in">memset</span>(son,<span class="number">0</span>,<span class="keyword">sizeof</span>(son)),fail=<span class="number">0</span>;&#125;</span><br><span class="line">&#125;T[<span class="number">600050</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> &amp;S)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> now=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">string</span>::iterator it=S.begin();it!=S.end();++it)&#123;</span><br><span class="line"><span class="keyword">int</span> &amp;nxt=T[now].son[*it-<span class="string">'a'</span>];</span><br><span class="line"><span class="keyword">if</span> (!nxt) nxt=++tot;</span><br><span class="line">now=nxt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (T[<span class="number">1</span>].son[i]) Q.push(T[<span class="number">1</span>].son[i]),T[T[<span class="number">1</span>].son[i]].fail=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> T[<span class="number">1</span>].son[i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!Q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> now=Q.front();</span><br><span class="line">Q.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (T[now].son[i]) Q.push(T[now].son[i]),T[T[now].son[i]].fail=T[T[now].fail].son[i];</span><br><span class="line"><span class="keyword">else</span> T[now].son[i]=T[T[now].fail].son[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AC()&#123;tot=<span class="number">1</span>;&#125;</span><br><span class="line">&#125;A;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; son[<span class="number">600050</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; query[<span class="number">300050</span>];</span><br><span class="line"><span class="keyword">int</span> id[<span class="number">600050</span>],dfn[<span class="number">600050</span>],sz[<span class="number">600050</span>],DFN;</span><br><span class="line"><span class="keyword">int</span> Fa[<span class="number">600050</span>][<span class="number">20</span>],dep[<span class="number">600050</span>];</span><br><span class="line"><span class="keyword">char</span> Fach[<span class="number">600050</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">dfn[now]=++DFN,sz[now]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=son[now].begin();it!=son[now].end();++it)</span><br><span class="line">Fa[*it][<span class="number">0</span>]=now,dep[*it]=dep[now]+<span class="number">1</span>,dfs1(*it),sz[now]+=sz[*it];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">Fa[now][<span class="number">0</span>]=fa;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">20</span>;i++) Fa[now][i]=Fa[Fa[now][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">dep[now]=dep[fa]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=H[now];i;i=E[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span> (E[i].to!=fa) dfs2(E[i].to,now);</span><br><span class="line">Fach[E[i].to]=E[i].C;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dep[x]&lt;dep[y]) <span class="built_in">std</span>::swap(x,y);</span><br><span class="line"><span class="keyword">int</span> dx=dep[x]-dep[y];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++) <span class="keyword">if</span> (dx&gt;&gt;i&amp;<span class="number">1</span>) x=Fa[x][i];</span><br><span class="line"><span class="keyword">if</span> (x==y) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">19</span>;~i;i--) <span class="keyword">if</span> (Fa[x][i]!=Fa[y][i]) x=Fa[x][i],y=Fa[y][i];</span><br><span class="line"><span class="keyword">return</span> Fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (d&gt;dep[x]) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">int</span> dx=dep[x]-d;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++) <span class="keyword">if</span> (dx&gt;&gt;i&amp;<span class="number">1</span>) x=Fa[x][i];</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> tmp[<span class="number">100050</span>];</span><br><span class="line"><span class="keyword">int</span> border[<span class="number">100050</span>],ans[<span class="number">200050</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> fa,<span class="keyword">int</span> dnow)</span></span>&#123;</span><br><span class="line">F.add(dfn[dnow],<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=query[now].begin();it!=query[now].end();++it)&#123;</span><br><span class="line"><span class="keyword">if</span> (*it&gt;<span class="number">0</span>) ans[*it]+=F.query(dfn[id[*it]]+sz[id[*it]]<span class="number">-1</span>)-F.query(dfn[id[*it]]<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">else</span> ans[-*it]-=F.query(dfn[id[-*it]]+sz[id[-*it]]<span class="number">-1</span>)-F.query(dfn[id[-*it]]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=H[now];i;i=E[i].nxt)</span><br><span class="line"><span class="keyword">if</span> (E[i].to!=fa) solve(E[i].to,now,A.T[dnow].son[E[i].C-<span class="string">'a'</span>]);</span><br><span class="line">F.add(dfn[dnow],<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;Q);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isspace</span>(o=getchar()));</span><br><span class="line">add_edge(x,y,o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Q;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;X[i],&amp;Y[i]);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;str[i];</span><br><span class="line">id[i]=A.insert(str[i]);</span><br><span class="line"><span class="built_in">std</span>::reverse(str[i].begin(),str[i].end());</span><br><span class="line">id[i+Q]=A.insert(str[i]);</span><br><span class="line"><span class="built_in">std</span>::reverse(str[i].begin(),str[i].end());</span><br><span class="line">&#125;</span><br><span class="line">A.make();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=A.tot;i++) son[A.T[i].fail].push_back(i);</span><br><span class="line">dfs1(<span class="number">1</span>);</span><br><span class="line">dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Q;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> lca=LCA(X[i],Y[i]),jx=jump(X[i],dep[lca]+str[i].length()<span class="number">-1</span>),jy=jump(Y[i],dep[lca]+str[i].length()<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (dep[X[i]]-dep[lca]&gt;=str[i].length()) query[X[i]].push_back(i+Q),query[jx].push_back(-i-Q);</span><br><span class="line"><span class="keyword">if</span> (dep[Y[i]]-dep[lca]&gt;=str[i].length()) query[Y[i]].push_back(i),query[jy].push_back(-i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len=dep[jx]+dep[jy]<span class="number">-2</span>*dep[lca];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> now=jx,t=<span class="number">0</span>;now!=lca;now=Fa[now][<span class="number">0</span>],t++) tmp[t]=Fach[now];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> now=jy,t=len<span class="number">-1</span>;now!=lca;now=Fa[now][<span class="number">0</span>],t--) tmp[t]=Fach[now];</span><br><span class="line">tmp[len]=<span class="number">0</span>;</span><br><span class="line">border[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>,len=str[i].length();j&lt;=len;j++)&#123;</span><br><span class="line">border[j]=border[j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (border[j]&amp;&amp;str[i][j<span class="number">-1</span>]!=str[i][border[j]<span class="number">-1</span>]) border[j]=border[border[j]<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>,t=<span class="number">0</span>;j&lt;len;j++)&#123;</span><br><span class="line">t++;</span><br><span class="line"><span class="keyword">while</span> (t&amp;&amp;str[i][t<span class="number">-1</span>]!=tmp[j]) t=border[t<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (t==str[i].length()) ans[i]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">FenwickMax=A.tot;</span><br><span class="line">solve(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Q;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]+ans[i+Q]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 做题记录 </category>
          
          <category> lydsy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC自动机 </tag>
            
            <tag> 倍增 </tag>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 587F Duff is Mad</title>
      <link href="/2019/10/23/cf587f/"/>
      <url>/2019/10/23/cf587f/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定若干字符串$S_i$</p><p>多次询问编号在$[L,R]$区间中的字符串在$S_k$中出现次数总和</p><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>由于是多串匹配问题，先建出AC自动机</p><p>接下来要用到fail树的性质</p><p>询问$[L,R]$区间中的字符串在$S_k$中出现次数总和可以从两个方法考虑：</p><ol><li><p>对于所有$[L,R]$中的$S_i$在Trie树中的对应节点，使其在fail树中的子树全部加一，然后询问$S_k$匹配路径上的权值和</p></li><li><p>将$S_k$匹配路径上的权值置为$1$，然后询问所有$[L,R]$中的$S_i$在Trie树中的对应节点，其在fail树中的子树和</p></li></ol><p>令$T$为Trie树上节点个数（不会超过$\sum S_i$）</p><p>将询问离线，将询问$[L,R]$转化为$[1,R]$和$[1,L-1]$的询问，并处理出fail树的dfs序</p><p>对于$|S_k|&gt;\sqrt{T}$，这样的字符串不会超过$\sqrt{T}$个</p><p>使用第二种方法，对于这$\sqrt{T}$种字符串分别求解，路径上点置$1$，然后子树求和，时间复杂度$O(n\sqrt{T}+Q)$</p><p>而对于$|S_k|&lt;=\sqrt{T}$，使用第一种方法</p><p>字符串逐个进行子树加，然后对于右端点为当前字符串的询问，暴力询问$S_k$匹配路径上的单点值进行求和</p><p>如果使用分块可以做到$O(\sqrt{T})-O(1)$，复杂度达到$O(n\sqrt{T}+Q)$</p><p>综上，时间复杂度为$O(n\sqrt{T}+Q)$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,Q,len;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; son[<span class="number">100050</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ACautomaton</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> son[<span class="number">26</span>],fail;</span><br><span class="line">node()&#123;<span class="built_in">memset</span>(son,<span class="number">0</span>,<span class="keyword">sizeof</span>(son)),fail=<span class="number">0</span>;&#125;</span><br><span class="line">&#125;T[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; insert(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;S)&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">path.push_back(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> len=S.length();</span><br><span class="line"><span class="keyword">int</span> now=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> &amp;nxt=T[now].son[S[i]-<span class="string">'a'</span>];</span><br><span class="line"><span class="keyword">if</span> (!nxt) nxt=++tot;</span><br><span class="line">now=nxt;</span><br><span class="line">path.push_back(now);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (T[<span class="number">1</span>].son[i]) Q.push(T[<span class="number">1</span>].son[i]),T[T[<span class="number">1</span>].son[i]].fail=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> T[<span class="number">1</span>].son[i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!Q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> now=Q.front();</span><br><span class="line">son[T[now].fail].push_back(now);</span><br><span class="line">Q.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (T[now].son[i]) Q.push(T[now].son[i]),T[T[now].son[i]].fail=T[T[now].fail].son[i];</span><br><span class="line"><span class="keyword">else</span> T[now].son[i]=T[T[now].fail].son[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ACautomaton()&#123;tot=<span class="number">1</span>;&#125;</span><br><span class="line">&#125;T;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path[<span class="number">100050</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> S[<span class="number">100050</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[<span class="number">100050</span>],DFN,sz[<span class="number">100050</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">dfn[now]=++DFN;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=son[now].begin();it!=son[now].end();++it)</span><br><span class="line">dfs(*it),sz[now]+=sz[*it];</span><br><span class="line">sz[now]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tmp</span>&#123;</span><span class="keyword">int</span> t,s,flag,id;&#125;Y[<span class="number">200050</span>];</span><br><span class="line"><span class="keyword">int</span> tot,splitid,blo;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(tmp a,tmp b)</span></span>&#123;<span class="keyword">return</span> S[a.s].length()&lt;S[b.s].length();&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmps</span><span class="params">(tmp a,tmp b)</span></span>&#123;<span class="keyword">return</span> a.s&lt;b.s;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpt</span><span class="params">(tmp a,tmp b)</span></span>&#123;<span class="keyword">return</span> a.t&lt;b.t;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ttmp[<span class="number">100050</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[<span class="number">100050</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">block</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> tag[<span class="number">1000</span>],val[<span class="number">100050</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> bl=L/blo,br=R/blo;</span><br><span class="line"><span class="keyword">if</span> (bl==br) <span class="keyword">for</span> (<span class="keyword">int</span> i=L;i&lt;=R;i++) val[i]++;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=L;i&lt;(bl+<span class="number">1</span>)*blo;i++) val[i]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=br*blo;i&lt;=R;i++) val[i]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=bl+<span class="number">1</span>;i&lt;=br<span class="number">-1</span>;i++) tag[i]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;<span class="keyword">return</span> tag[k/blo]+val[k];&#125;</span><br><span class="line"></span><br><span class="line">block()&#123;<span class="built_in">memset</span>(tag,<span class="number">0</span>,<span class="keyword">sizeof</span>(tag)),<span class="built_in">memset</span>(val,<span class="number">0</span>,<span class="keyword">sizeof</span>(val));&#125;</span><br><span class="line">&#125;B;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;Q);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;S[i],path[i]=T.insert(S[i]);</span><br><span class="line">T.make();</span><br><span class="line"></span><br><span class="line">blo=<span class="built_in">sqrt</span>(T.tot)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,x,y,z;i&lt;=Q;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">Y[i*<span class="number">2</span><span class="number">-1</span>]=(tmp)&#123;y,z,<span class="number">1</span>,i&#125;;</span><br><span class="line">Y[i*<span class="number">2</span>]=(tmp)&#123;x<span class="number">-1</span>,z,<span class="number">-1</span>,i&#125;;</span><br><span class="line">&#125;</span><br><span class="line">tot=<span class="number">2</span>*Q;</span><br><span class="line"><span class="built_in">std</span>::sort(Y+<span class="number">1</span>,Y+tot+<span class="number">1</span>,cmp);</span><br><span class="line">splitid=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (splitid&lt;=tot&amp;&amp;S[Y[splitid].s].length()&lt;=blo) splitid++;</span><br><span class="line"><span class="built_in">std</span>::sort(Y+<span class="number">1</span>,Y+splitid,cmpt);</span><br><span class="line"><span class="built_in">std</span>::sort(Y+splitid,Y+tot+<span class="number">1</span>,cmps);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> L=splitid,R;L&lt;=tot;L=R+<span class="number">1</span>)&#123;</span><br><span class="line">R=L;</span><br><span class="line"><span class="keyword">while</span> (R&lt;=tot&amp;&amp;Y[R+<span class="number">1</span>].s==Y[L].s) R++;</span><br><span class="line"><span class="built_in">std</span>::sort(Y+L,Y+R+<span class="number">1</span>,cmpt);</span><br><span class="line"><span class="built_in">memset</span>(ttmp,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(T.tot+<span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=path[Y[L].s].begin();it!=path[Y[L].s].end();++it) ttmp[dfn[*it]]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=T.tot;i++) ttmp[i]+=ttmp[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">int</span> it=L;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> addtmp=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (it&lt;=R&amp;&amp;!Y[it].t) it++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">addtmp+=ttmp[dfn[path[i].back()]+sz[path[i].back()]<span class="number">-1</span>]-ttmp[dfn[path[i].back()]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">while</span> (it&lt;=R&amp;&amp;Y[it].t==i) ans[Y[it].id]+=Y[it].flag*addtmp,it++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> it=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (it&lt;splitid&amp;&amp;!Y[it].t) it++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">B.add(dfn[path[i].back()],dfn[path[i].back()]+sz[path[i].back()]<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">while</span> (it&lt;splitid&amp;&amp;Y[it].t==i)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator dit=path[Y[it].s].begin();dit!=path[Y[it].s].end();++dit) ans[Y[it].id]+=Y[it].flag*B.query(dfn[*dit]);</span><br><span class="line">it++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Q;i++) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 做题记录 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC自动机 </tag>
            
            <tag> 分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UOJ 315 【NOI2017】蚯蚓排队</title>
      <link href="/2019/10/21/uoj315/"/>
      <url>/2019/10/21/uoj315/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>维护一个字符集大小为$6$的字符串集，支持：</p><ol><li><p>将集合中一个字符串接到另一个后面</p></li><li><p>将某个字符串截成两个</p></li><li><p>给定另一个字符串$S’$和正整数$k$，求$S’$的所有长度为$k$的连续子串在字符串集中作为某个串子串的出现次数乘积</p></li></ol><p>其中，$2$操作不超过$c=1000$次，$3$操作$k$不超过$50$</p><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>由于询问$k$很小，可以考虑直接维护所有长度不超过$50$的子串的哈希值</p><p>这样的子串只有不超过$50|S|$个</p><p>每次合并字符串，找到所有经过连接点的长度不超过$50$的子串加入哈希表</p><p>而分裂字符串就找到所有经过分裂点的长度不超过$50$的子串从哈希表中删去</p><p>乍一看，复杂度好像是$O(Qk^2)$的，其中$Q$是总询问次数</p><p>假如只有合并，每个字符串仅会被加入哈希表一次，这样分析复杂度是$O(Qk)$的</p><p>分裂字符串的次数很少，对上面的复杂度分析没有影响</p><p>对于询问，直接在哈希表中查找出现次数即可</p><p>时间复杂度$O(Qk+ck^2+\sum|S’|)$</p><p>注意哈希模数的选取，我直接使用了自然溢出</p><p>注意算法实现的常数</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">200001</span>],suf[<span class="number">200001</span>],id[<span class="number">200001</span>];</span><br><span class="line"><span class="keyword">char</span> S[<span class="number">10000000</span>];</span><br><span class="line"><span class="keyword">int</span> opt,x,y;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mul=<span class="number">19260817</span>,MOD=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> powmul[<span class="number">60</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> tablemod=(<span class="number">1</span>&lt;&lt;<span class="number">24</span>)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> tmp[tablemod+<span class="number">1</span>],tot;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> val;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> real;<span class="keyword">int</span> nxt;&#125;E[tablemod+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> &amp; <span class="keyword">operator</span> [] (<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> idx)&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> r=idx&amp;tablemod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=tmp[r];i;i=E[i].nxt)</span><br><span class="line"><span class="keyword">if</span> (E[i].real==idx) <span class="keyword">return</span> E[i].val;</span><br><span class="line">E[++tot]=(edge)&#123;<span class="number">0</span>,idx,tmp[r]&#125;;tmp[r]=tot;</span><br><span class="line"><span class="keyword">return</span> E[tot].val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;H;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> tmp[<span class="number">51</span>];</span><br><span class="line"><span class="keyword">int</span> top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">powmul[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++) powmul[i]=<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(powmul[i<span class="number">-1</span>])*mul;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;id[i]),H[id[i]]++;</span><br><span class="line"><span class="keyword">while</span> (m--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;opt);</span><br><span class="line"><span class="keyword">switch</span> (opt)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">top=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> now=x,t=<span class="number">1</span>;t&lt;=<span class="number">49</span>&amp;&amp;now;t++,now=pre[now])</span><br><span class="line">tmp[top+<span class="number">1</span>]=tmp[top]+<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(id[now])*powmul[t<span class="number">-1</span>],top++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> now=y,t=<span class="number">1</span>;t&lt;=<span class="number">49</span>&amp;&amp;now;t++,now=suf[now])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i+t&lt;=<span class="number">50</span>&amp;&amp;i&lt;=top;i++)</span><br><span class="line">tmp[i]=tmp[i]*<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(mul)+id[now],H[tmp[i]]++;</span><br><span class="line">suf[x]=y,pre[y]=x;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">top=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> now=x,t=<span class="number">1</span>;t&lt;=<span class="number">49</span>&amp;&amp;now;t++,now=pre[now])</span><br><span class="line">tmp[top+<span class="number">1</span>]=tmp[top]+<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(id[now])*powmul[t<span class="number">-1</span>],top++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> now=suf[x],t=<span class="number">1</span>;t&lt;=<span class="number">49</span>&amp;&amp;now;t++,now=suf[now])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i+t&lt;=<span class="number">50</span>&amp;&amp;i&lt;=top;i++)</span><br><span class="line">tmp[i]=tmp[i]*<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(mul)+id[now],H[tmp[i]]--;</span><br><span class="line">pre[suf[x]]=<span class="number">0</span>,suf[x]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%d"</span>,S,&amp;x);</span><br><span class="line">y=<span class="built_in">strlen</span>(S);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> hashval=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;x;i++) hashval=hashval*<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(mul)+(S[i]&amp;<span class="number">7</span>);</span><br><span class="line"><span class="keyword">int</span> ans=H[hashval];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=x;i&lt;y;i++)&#123;</span><br><span class="line">hashval=hashval*<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(mul)+(S[i]&amp;<span class="number">7</span>)-<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(S[i-x]&amp;<span class="number">7</span>)*powmul[x];</span><br><span class="line">ans=<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(ans)*H[hashval]%MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 做题记录 </category>
          
          <category> UOJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UOJ 119 【UR #8】决战圆锥曲线</title>
      <link href="/2019/10/19/uoj119/"/>
      <url>/2019/10/19/uoj119/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>维护一个序列，支持：</p><ul><li><p>单点修改</p></li><li><p>区间变成$100000-v$</p></li><li><p>区间询问所有$i\in[L,R]$，$ai+bv_i+civ_i$的最大值</p></li></ul><p><strong>保证初始序列、修改询问区间随机</strong></p><p>时刻保证权值在$[0,100000]$中</p><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题并不需要深入挖掘$a_i+bv_i+civ_i$的性质，只需要发现一点：</p><p>当$i_1&lt;i_2$且$v_{i_1}&lt;v_{i_2}$时，$i_1$位置不对答案造成贡献</p><p>由这个基础而美妙的性质，可以证明随机序列中造成贡献的位置是$O(\log n)$级别的</p><p>具体证明可以考虑一个位置$i$造成贡献，当且仅当后面所有的$j&gt;i$，都有$v_j&lt;v_i$，其概率为$\frac{1}{n-i+1}$</p><p>因此总和为调和级数，与$O(\log n)$同阶</p><p>如果可以快速的定位到这$O(\log n)$个位置，这题就做完了</p><p>现在考虑如何快速定位：</p><p>递归时记录当前区间要求至少要$w$才能产生贡献</p><p>如果$w$不小于当前区间最大值，则这个区间不会产生贡献，返回</p><p>否则先遍历右儿子，在得到右侧最大答案的同时也得到右侧$v_i$最大值$w_R$</p><p>那么对于左侧的要求就是至少$\max(w,w_R)$，递归左侧</p><p>如果当前节点是叶子结点，就说明定位到一个可能产生贡献的位置</p><p>这样定位$O(\log n)$个位置的时间复杂度是$O(\log^2 n)$</p><p>总时间复杂度为$O((n+m)\log n+Q\log^2 n)$</p><p>其中$Q$表示询问个数（非修改），不超过$100000$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,x0;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">gene</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (x0=<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;((<span class="number">100000005L</span>L*x0+<span class="number">20150609</span>)%<span class="number">998244353</span>))/<span class="number">100</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> max[<span class="number">400000</span>],min[<span class="number">400000</span>];</span><br><span class="line"><span class="keyword">bool</span> tag[<span class="number">400000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">puttag</span><span class="params">(<span class="keyword">int</span> o)</span></span>&#123;<span class="built_in">std</span>::swap(max[o]=<span class="number">100000</span>-max[o],min[o]=<span class="number">100000</span>-min[o]),tag[o]^=<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> o)</span></span>&#123;<span class="keyword">if</span> (tag[o]) puttag(o&lt;&lt;<span class="number">1</span>),puttag(o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>),tag[o]^=<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> o)</span></span>&#123;</span><br><span class="line">max[o]=<span class="built_in">std</span>::max(max[o&lt;&lt;<span class="number">1</span>],max[o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">min[o]=<span class="built_in">std</span>::min(min[o&lt;&lt;<span class="number">1</span>],min[o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l==r) max[o]=min[o]=gene()%<span class="number">100001</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> mdl=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">init(o&lt;&lt;<span class="number">1</span>,l,mdl),init(o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mdl+<span class="number">1</span>,r);</span><br><span class="line">update(o);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; query(<span class="keyword">int</span> o,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> lim)&#123;</span><br><span class="line"><span class="keyword">if</span> (l&gt;R||r&lt;L||max[o]&lt;=lim) <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(<span class="number">0L</span>L,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (l==r) <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(a)*l+<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(b)*max[o]+<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(c)*l*max[o],max[o]);</span><br><span class="line">pushdown(o);</span><br><span class="line"><span class="keyword">int</span> mdl=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">std</span>::pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; resR=query(o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mdl+<span class="number">1</span>,r,L,R,a,b,c,lim);</span><br><span class="line"><span class="built_in">std</span>::pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; resL=query(o&lt;&lt;<span class="number">1</span>,l,mdl,L,R,a,b,c,<span class="built_in">std</span>::max(lim,resR.second));</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::make_pair(<span class="built_in">std</span>::max(resR.first,resL.first),<span class="built_in">std</span>::max(resR.second,resL.second));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l&gt;R||r&lt;L) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (L&lt;=l&amp;&amp;r&lt;=R)&#123;puttag(o);<span class="keyword">return</span>;&#125;</span><br><span class="line">pushdown(o);</span><br><span class="line"><span class="keyword">int</span> mdl=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">flip(o&lt;&lt;<span class="number">1</span>,l,mdl,L,R);</span><br><span class="line">flip(o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mdl+<span class="number">1</span>,r,L,R);</span><br><span class="line">update(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l==r) max[o]=min[o]=v;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">pushdown(o);</span><br><span class="line"><span class="keyword">int</span> mdl=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (k&lt;=mdl) modify(o&lt;&lt;<span class="number">1</span>,l,mdl,k,v);</span><br><span class="line"><span class="keyword">else</span> modify(o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mdl+<span class="number">1</span>,r,k,v);</span><br><span class="line">update(o);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> opt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;x0);</span><br><span class="line">T.init(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">while</span> (m--)&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isspace</span>(opt=getchar()));</span><br><span class="line"><span class="keyword">if</span> (opt==<span class="string">'C'</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> p=gene()%n+<span class="number">1</span>,y=gene()%<span class="number">100001</span>;</span><br><span class="line">T.modify(<span class="number">1</span>,<span class="number">1</span>,n,p,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (opt==<span class="string">'R'</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> p=gene()%n+<span class="number">1</span>,q=gene()%n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (p&gt;q) <span class="built_in">std</span>::swap(p,q);</span><br><span class="line">T.flip(<span class="number">1</span>,<span class="number">1</span>,n,p,q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,b,c,p=gene()%n+<span class="number">1</span>,q=gene()%n+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line"><span class="keyword">if</span> (p&gt;q) <span class="built_in">std</span>::swap(p,q);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,T.query(<span class="number">1</span>,<span class="number">1</span>,n,p,q,a,b,c,<span class="number">0</span>).first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 做题记录 </category>
          
          <category> UOJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UOJ 46 【清华集训2014】玄学</title>
      <link href="/2019/10/17/uoj46/"/>
      <url>/2019/10/17/uoj46/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定初始长度为$n$的序列$A_i$</p><p>支持追加一个操作：将$[L,R]$的区间变为$ax+b$</p><p>支持询问：如果按顺序执行编号在$[L,R]$的操作，那么$k$位置上的数变为多少</p><p>强制在线</p><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>对时间建出线段树，每个节点储存“进行完这个节点对应时间区间的操作后，序列每一个位置变化为$ax+b$（合并tag）”</p><p>但是记录整个序列的变化太浪费了，因为序列可能有很长一段的操作是完全相同的</p><p>那么改进一下，每个节点储存“进行完这个节点对应时间区间的操作后，序列相同操作的每一段变化为$ax+b$”</p><p>这样，对于一个时刻的操作（线段树的叶子节点），至多被分为$3$段</p><p>而对于非叶子节点，可以由左右子节点的信息归并得到</p><p>这题加上的强制在线的限制，那么就将操作逐个加入时间线段树，如果一个非叶子节点的左右儿子都满了，就将左右儿子的信息归并</p><p>询问就在时间线段树上询问，对于完整包含的节点，二分确定查询的位置在哪个段，然后返回那段区间的tag即可</p><p>时间复杂度$O(Q\log Q\log n)$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,Q,mod,A[<span class="number">200000</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; &gt; V[<span class="number">2400000</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; Merge(<span class="keyword">const</span> <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp;A,<span class="keyword">const</span> <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp;B)&#123;<span class="keyword">return</span> <span class="built_in">std</span>::make_pair(<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(A.first)*B.first%mod,(<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(A.second)*B.first+B.second)%mod);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> o)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> L=<span class="number">0</span>,R=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (L&lt;V[o&lt;&lt;<span class="number">1</span>].size()&amp;&amp;R&lt;V[o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].size())&#123;</span><br><span class="line"><span class="keyword">if</span> (V[o&lt;&lt;<span class="number">1</span>][L].first==V[o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>][R].first) V[o].push_back(<span class="built_in">std</span>::make_pair(V[o&lt;&lt;<span class="number">1</span>][L].first,Merge(V[o&lt;&lt;<span class="number">1</span>][L].second,V[o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>][R].second))),L++,R++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (V[o&lt;&lt;<span class="number">1</span>][L].first&lt;V[o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>][R].first) V[o].push_back(<span class="built_in">std</span>::make_pair(V[o&lt;&lt;<span class="number">1</span>][L].first,Merge(V[o&lt;&lt;<span class="number">1</span>][L].second,V[o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>][R<span class="number">-1</span>].second))),L++;</span><br><span class="line"><span class="keyword">else</span> V[o].push_back(<span class="built_in">std</span>::make_pair(V[o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>][R].first,Merge(V[o&lt;&lt;<span class="number">1</span>][L<span class="number">-1</span>].second,V[o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>][R].second))),R++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (L&lt;V[o&lt;&lt;<span class="number">1</span>].size()) V[o].push_back(<span class="built_in">std</span>::make_pair(V[o&lt;&lt;<span class="number">1</span>][L].first,Merge(V[o&lt;&lt;<span class="number">1</span>][L].second,V[o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>][R<span class="number">-1</span>].second))),L++;</span><br><span class="line"><span class="keyword">while</span> (R&lt;V[o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].size()) V[o].push_back(<span class="built_in">std</span>::make_pair(V[o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>][R].first,Merge(V[o&lt;&lt;<span class="number">1</span>][L<span class="number">-1</span>].second,V[o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>][R].second))),R++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> z,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l==r)&#123;</span><br><span class="line"><span class="keyword">if</span> (L!=<span class="number">1</span>) V[o].push_back(<span class="built_in">std</span>::make_pair(<span class="number">1</span>,<span class="built_in">std</span>::make_pair(<span class="number">1</span>,<span class="number">0</span>)));</span><br><span class="line">V[o].push_back(<span class="built_in">std</span>::make_pair(L,<span class="built_in">std</span>::make_pair(a,b)));</span><br><span class="line"><span class="keyword">if</span> (R!=n) V[o].push_back(<span class="built_in">std</span>::make_pair(R+<span class="number">1</span>,<span class="built_in">std</span>::make_pair(<span class="number">1</span>,<span class="number">0</span>)));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mdl=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (z&lt;=mdl) append(o&lt;&lt;<span class="number">1</span>,l,mdl,z,L,R,a,b);</span><br><span class="line"><span class="keyword">else</span> append(o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mdl+<span class="number">1</span>,r,z,L,R,a,b);</span><br><span class="line"><span class="keyword">if</span> (z==r) update(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; query(<span class="keyword">int</span> o,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> k)&#123;</span><br><span class="line"><span class="keyword">if</span> (l&gt;R||r&lt;L) <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (L&lt;=l&amp;&amp;r&lt;=R) <span class="keyword">return</span> <span class="built_in">std</span>::prev(<span class="built_in">std</span>::lower_bound(V[o].begin(),V[o].end(),<span class="built_in">std</span>::make_pair(k+<span class="number">1</span>,<span class="built_in">std</span>::make_pair(<span class="number">0</span>,<span class="number">0</span>))))-&gt;second;</span><br><span class="line"><span class="keyword">int</span> mdl=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> Merge(query(o&lt;&lt;<span class="number">1</span>,l,mdl,L,R,k),query(o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mdl+<span class="number">1</span>,r,L,R,k));</span><br><span class="line">&#125;</span><br><span class="line">&#125;T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Type,top,opt,x,y,z,u,lastans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Type),Type&amp;=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;mod);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;A[i]);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Q);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> tim=<span class="number">1</span>;tim&lt;=Q;tim++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;opt);</span><br><span class="line"><span class="keyword">if</span> (opt==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;x,&amp;y,&amp;z,&amp;u);</span><br><span class="line"><span class="keyword">if</span> (Type) x^=lastans,y^=lastans;</span><br><span class="line">T.append(<span class="number">1</span>,<span class="number">1</span>,Q,++top,x,y,z,u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line"><span class="keyword">if</span> (Type) x^=lastans,y^=lastans,z^=lastans;</span><br><span class="line"><span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; res=T.query(<span class="number">1</span>,<span class="number">1</span>,Q,x,y,z);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,lastans=(<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(res.first)*A[z]+res.second)%mod);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 做题记录 </category>
          
          <category> UOJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lydsy 2653 middle</title>
      <link href="/2019/10/14/lydsy2653/"/>
      <url>/2019/10/14/lydsy2653/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出长度为$n$的整数序列$A$</p><p>多次询问所有左端点在$[a,b]$，右端点在$[c,d]$的连续子序列中，中位数最大是多少$(1\leq a&lt;b&lt;c\leq n)$</p><p>强制在线</p><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先离散化</p><p>对于一次询问$a,b,c,d$，考虑二分答案$w$</p><p>假设将数列中所有$\geq w$的数标为$+1$，所有$&lt;w$的数标为$-1$</p><p>那么只需要检验，所有左端点在$[a,b]$，右端点在$[c,d]$的连续子序列和，最大是否超过了$0$（此处有细节，可能是$-1$或$1$），以此来判断答案需要减小或增大</p><p>称此时的$\pm 1$序列为<strong>关于$w$</strong>的序列</p><p>为了得到最大的满足条件的子序列和，需要用线段树维护区间的最大前缀、最大后缀、区间和</p><p>为了得到所有<strong>关于$i$</strong>的序列的线段树，可以使用主席树预处理上述信息</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> V[<span class="number">30000</span>],tmp[<span class="number">30000</span>],tmptop,lstans,Q;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> premax,sufmax,sum;</span><br><span class="line">data()&#123;premax=sufmax=sum=<span class="number">0</span>;&#125;</span><br><span class="line">data(<span class="keyword">int</span> premax_,<span class="keyword">int</span> sufmax_,<span class="keyword">int</span> sum_)&#123;premax=premax_,sufmax=sufmax_,sum=sum_;&#125;</span><br><span class="line"><span class="keyword">inline</span> data <span class="keyword">operator</span> + (<span class="keyword">const</span> data &amp;T)&#123;<span class="keyword">return</span> data(<span class="built_in">std</span>::max(premax,sum+T.premax),<span class="built_in">std</span>::max(T.sufmax,T.sum+sufmax),sum+T.sum);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> L,R;</span><br><span class="line">data D;</span><br><span class="line">node()&#123;L=R=<span class="number">0</span>;&#125;</span><br><span class="line">&#125;T[<span class="number">10000000</span>];</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"></span><br><span class="line">SegmentTree()&#123;tot=<span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> o)</span></span>&#123;T[o].D=T[T[o].L].D+T[T[o].R].D;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> &amp;o,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> nxt=++tot;</span><br><span class="line">T[nxt]=T[o],o=nxt;</span><br><span class="line"><span class="keyword">if</span> (l==r)&#123;T[nxt].D=data(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">int</span> mdl=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">init(T[o].L,l,mdl),init(T[o].R,mdl+<span class="number">1</span>,r);</span><br><span class="line">update(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> &amp;o,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> nxt=++tot;</span><br><span class="line">T[nxt]=T[o],o=nxt;</span><br><span class="line"><span class="keyword">if</span> (l==r)&#123;T[nxt].D=data(<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">int</span> mdl=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (k&lt;=mdl) modify(T[o].L,l,mdl,k);</span><br><span class="line"><span class="keyword">else</span> modify(T[o].R,mdl+<span class="number">1</span>,r,k);</span><br><span class="line">update(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">data <span class="title">query</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L&lt;=l&amp;&amp;r&lt;=R) <span class="keyword">return</span> T[o].D;</span><br><span class="line"><span class="keyword">int</span> mdl=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (L&lt;=mdl&amp;&amp;mdl&lt;R) <span class="keyword">return</span> query(T[o].L,l,mdl,L,R)+query(T[o].R,mdl+<span class="number">1</span>,r,L,R);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (L&lt;=mdl) <span class="keyword">return</span> query(T[o].L,l,mdl,L,R);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> query(T[o].R,mdl+<span class="number">1</span>,r,L,R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l&gt;R||r&lt;L||L&gt;R) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (L&lt;=l&amp;&amp;r&lt;=R) <span class="keyword">return</span> T[o].D.sum;</span><br><span class="line"><span class="keyword">int</span> mdl=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> sum(T[o].L,l,mdl,L,R)+sum(T[o].R,mdl+<span class="number">1</span>,r,L,R);</span><br><span class="line">&#125;</span><br><span class="line">&#125;T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>],root[<span class="number">30000</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C[<span class="number">30000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;V[i]),tmp[i]=V[i];</span><br><span class="line"><span class="built_in">std</span>::sort(tmp+<span class="number">1</span>,tmp+n+<span class="number">1</span>);</span><br><span class="line">tmptop=<span class="built_in">std</span>::unique(tmp+<span class="number">1</span>,tmp+n+<span class="number">1</span>)-tmp<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) V[i]=<span class="built_in">std</span>::lower_bound(tmp+<span class="number">1</span>,tmp+tmptop+<span class="number">1</span>,V[i])-tmp,C[V[i]].push_back(i);</span><br><span class="line">T.init(root[<span class="number">1</span>],<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;tmptop;i++)&#123;</span><br><span class="line">root[i+<span class="number">1</span>]=root[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=C[i].begin();it!=C[i].end();++it) T.modify(root[i+<span class="number">1</span>],<span class="number">1</span>,n,*it);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Q);</span><br><span class="line"><span class="keyword">while</span> (Q--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;a[<span class="number">0</span>],&amp;a[<span class="number">1</span>],&amp;a[<span class="number">2</span>],&amp;a[<span class="number">3</span>]);</span><br><span class="line">a[<span class="number">0</span>]=(a[<span class="number">0</span>]+lstans)%n+<span class="number">1</span>,a[<span class="number">1</span>]=(a[<span class="number">1</span>]+lstans)%n+<span class="number">1</span>,a[<span class="number">2</span>]=(a[<span class="number">2</span>]+lstans)%n+<span class="number">1</span>,a[<span class="number">3</span>]=(a[<span class="number">3</span>]+lstans)%n+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">std</span>::sort(a,a+<span class="number">4</span>);</span><br><span class="line"><span class="keyword">int</span> L=<span class="number">1</span>,R=tmptop,mdl;</span><br><span class="line"><span class="keyword">while</span> (L&lt;R)&#123;</span><br><span class="line">mdl=(L+R+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">SegmentTree::data Ldata=T.query(root[mdl],<span class="number">1</span>,n,a[<span class="number">0</span>],a[<span class="number">1</span>]),Rdata=T.query(root[mdl],<span class="number">1</span>,n,a[<span class="number">2</span>],a[<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">int</span> Mdata=T.sum(root[mdl],<span class="number">1</span>,n,a[<span class="number">1</span>]+<span class="number">1</span>,a[<span class="number">2</span>]<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">int</span> mx=Ldata.sufmax+Mdata+Rdata.premax;</span><br><span class="line"><span class="keyword">if</span> (mx&lt;<span class="number">0</span>) R=mdl<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> L=mdl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,lstans=tmp[L]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 做题记录 </category>
          
          <category> lydsy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 二分答案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[HNOI2008]Cards</title>
      <link href="/2019/10/12/lydsy1004/"/>
      <url>/2019/10/12/lydsy1004/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个$m$阶置换群$G$（如果缺少幺元则自己补上）</p><p>要求用红绿蓝三种颜色染色，且三种颜色的元素个数要恰好分别为$S_r,S_g,S_b$</p><p>求在置换群作用下本质不同的染色方案数</p><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>直接使用 Pólya 定理的生成函数形式，令三种颜色的形式变元为$r,g,b$</p><p>$$ Ans=\frac{1}{m}\sum_{f\in G}|C_f| $$</p><p>其中$C_f$表示在$f$的作用下不动合法染色集合</p><p>现在考虑如何求$|C_f|$</p><p>假设$f$被循环分解为大小为$t_1,t_2,\cdots,t_k$的循环</p><p>那么$|C_f|=[r^{S_r}g^{S_g}b^{S_b}]\prod_{i=1}^{k}(r^{t_i}+g^{t_i}+b^{t_i})$</p><p>上面的式子可以用类似dp的方法求出（每次乘上$r^{t_i}+g^{t_i}+b^{t_i}$）</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Sr,Sb,Sg,m,P,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (;b;b&gt;&gt;=<span class="number">1</span>,a=a*a%P)</span><br><span class="line"><span class="keyword">if</span> (b&amp;<span class="number">1</span>) ret=ret*a%P;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> G[<span class="number">70</span>],ans;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">70</span>][<span class="number">70</span>][<span class="number">70</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">70</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> &amp;A,<span class="keyword">int</span> B)</span></span>&#123;A=(A+B)%P;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> have,havetmp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>,&amp;Sr,&amp;Sb,&amp;Sg,&amp;m,&amp;P),n=Sr+Sb+Sg;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">bool</span>)*(n+<span class="number">1</span>));</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">havetmp=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;G[j]),havetmp&amp;=(G[j]==j);</span><br><span class="line">have|=havetmp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[j]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> now=j;!vis[now];now=G[now]) len++,vis[now]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=sum;k++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;=sum-k;l++)&#123;</span><br><span class="line"><span class="keyword">int</span> p=(sum-k-l);</span><br><span class="line">up(dp[k+len][l][p],dp[k][l][p]);</span><br><span class="line">up(dp[k][l+len][p],dp[k][l][p]);</span><br><span class="line">up(dp[k][l][p+len],dp[k][l][p]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sum+=len;</span><br><span class="line">&#125;</span><br><span class="line">up(ans,dp[Sr][Sb][Sg]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!have)&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">bool</span>)*(n+<span class="number">1</span>));</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) G[j]=j;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[j]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> now=j;!vis[now];now=G[now]) len++,vis[now]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=sum;k++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;=sum-k;l++)&#123;</span><br><span class="line"><span class="keyword">int</span> p=(sum-k-l);</span><br><span class="line">up(dp[k+len][l][p],dp[k][l][p]);</span><br><span class="line">up(dp[k][l+len][p],dp[k][l][p]);</span><br><span class="line">up(dp[k][l][p+len],dp[k][l][p]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sum+=len;</span><br><span class="line">&#125;</span><br><span class="line">up(ans,dp[Sr][Sb][Sg]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans*<span class="built_in">pow</span>(m+<span class="number">1</span>,P<span class="number">-2</span>)%P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans*<span class="built_in">pow</span>(m,P<span class="number">-2</span>)%P);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 做题记录 </category>
          
          <category> lydsy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生成函数 </tag>
            
            <tag> Pólya 定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LOJ 6519 魔力环</title>
      <link href="/2019/10/11/loj6519/"/>
      <url>/2019/10/11/loj6519/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个项链被称为合法的，当且仅当：</p><ol><li><p>其包含$n$个珠子，恰好$m$个黑珠子$n-m$个白珠子</p></li><li><p>最长连续黑珠子段长度不超过$k$</p></li></ol><p>两个项链被认为相同当且仅当可以通过旋转使项链完全一致</p><p>求有多少种不同的合法项链</p><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>由于是旋转，考虑用 Burnside 引理，统计每一种旋转下的不动染色个数</p><p>枚举旋转量，如果旋转了$i$个单位，那么项链会以$\gcd(i,n)$为周期</p><p>对于每个周期，可以破环为链进行计算</p><p>令$F_{d,p,k}$表示长度为$d$的链中，有$p$个黑珠子，且最长连续段不超过$k$的方案数（但由于是周期，所以相当于首尾相接）</p><p>$$<br>\begin{aligned}<br>Ans&amp;=\sum_{i=1}^{n}[n|m\gcd(i,n)]F_{\gcd(i,n),m\gcd(i,n)/n,k} \\<br>&amp;=\sum_{g=1}^{n}[n|mg]F_{g,m*g/n,k}\sum_{i=1}^{n}[\gcd(i,n)=g] \\<br>&amp;=\sum_{g|n}[n|m*g]F_{g,mg/n,k}\varphi(\frac{n}{g})<br>\end{aligned}<br>$$</p><p>做到这步，接下来的重点放在求$F_{d,p,k}$</p><p>如果以所有$w=d-p$个白珠子为分割，连续黑珠子的长度记作$x$</p><p>那么满足以下条件</p><p>$$<br>\begin{cases}<br>x_0+x_1+\cdots+x_w=p \\<br>0\leq x_1,x_2,\cdots,x_{w-1}\leq k \\<br>0\leq x_0+x_w\leq k<br>\end{cases}<br>$$</p><p>注意到最后一个条件是由于周期收尾相接导致的</p><p>上述方程整数解与方案一一对应，因此只需要求上述方程的解数</p><p>对于$x_{1..w-1}$，构造生成函数</p><p>$$ G_k(x)=\sum_{i=0}^{k}x^i=\frac{1-x^{k+1}}{1-x} $$</p><p>对于$x_0+x_w$，构造生成函数</p><p>$$<br>\begin{aligned}<br>H_k(x)&amp;=\sum_{i=0}^{k}(i+1)x^i \\<br>&amp;=\frac{\mathrm{d}}{\mathrm{d}x}\sum_{i=0}^{k}x^{k+1} \\<br>&amp;=\frac{\mathrm{d}}{\mathrm{d}x}(\frac{x^{k+2}-1}{x-1}-1) \\<br>&amp;=\frac{(k+1)x^{k+2}-(k+2)x^{k+1}+1}{(1-x)^2}<br>\end{aligned}<br>$$</p><p>那么</p><p>$$<br>\begin{aligned}<br>F_{d,p,k}&amp;=[x^p]G_k^{w-1}(x)H_k(x) \\<br>&amp;=[x^p]\left(\frac{1-x^{k+1}}{1-x}\right)^{w-1}\frac{(k+1)x^{k+2}-(k+2)x^{k+1}+1}{(1-x)^2} \\<br>&amp;=[x^p]\left((k+1)x^{k+2}-(k+2)x^{k+1}+1\right)\frac{(1-x^{k+1})^{w-1}}{(1-x)^{w+1}}<br>\end{aligned}<br>$$</p><p>转化为求出右侧的$x^p,x^{p-k-1},x^{p-k-2}$次项</p><p>$$<br>\begin{aligned}<br>[x^a]\frac{(1-x^{k+1})^{w-1}}{(1-x)^{w+1}}&amp;=[x^a]\left(\sum_{i=0}^{\infty}\binom{w-1}{i}(-x^{k+1})^i\right)\cdot\left(\sum_{i=0}^{\infty}\binom{w+i}{i}x^i\right) \\<br>&amp;=\sum_{i=0}^{\lfloor\frac{a}{k+1}\rfloor}\binom{w-1}{a}(-1)^a\cdot \binom{w+a(k+1)-i}{a(k+1)-i}<br>\end{aligned}<br>$$</p><p>这个式子可以在$O(\frac{a}{k+1})$的时间计算</p><p>由一开始的推导，需要对所有$d|n$计算$F_{d,\cdots}$</p><p>计算量大约是$\sum_{d|n}\frac{d}{k+1}=O(\frac{\sigma(n)}{k+1})$，绰绰有余</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">chkinc</span><span class="params">(<span class="keyword">int</span> &amp;C)</span></span>&#123;C+=C&gt;&gt;<span class="number">31</span>&amp;mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (;b;b&gt;&gt;=<span class="number">1</span>,a=<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(a)*a%mod)</span><br><span class="line"><span class="keyword">if</span> (b&amp;<span class="number">1</span>) ret=<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(ret)*a%mod;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> primes[<span class="number">10</span>],pcnt[<span class="number">10</span>],ptop,tmp;</span><br><span class="line"><span class="keyword">int</span> val[<span class="number">1000</span>],vphi[<span class="number">1000</span>],vtop;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> v=<span class="number">1</span>,<span class="keyword">int</span> p=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (now&gt;ptop)&#123;</span><br><span class="line">val[++vtop]=v;</span><br><span class="line">vphi[vtop]=p;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">dfs(now+<span class="number">1</span>,v,p);</span><br><span class="line">dfs(now+<span class="number">1</span>,v*=primes[now],p*=primes[now]<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=pcnt[now];i++)</span><br><span class="line">dfs(now+<span class="number">1</span>,v*=primes[now],p*=primes[now]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fact[<span class="number">200050</span>],ifact[<span class="number">200050</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n&lt;m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(fact[n])*ifact[m]%mod*ifact[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calcpre</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> w,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> lim=p/(k+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=lim;i++)</span><br><span class="line">ret=(ret+((i&amp;<span class="number">1</span>)?mod<span class="number">-1L</span>L:<span class="number">1L</span>L)*C(w<span class="number">-1</span>,i)%mod*C(w+p-(k+<span class="number">1</span>)*i,p-(k+<span class="number">1</span>)*i))%mod;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> d,<span class="keyword">int</span> p,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret=calcpre(p,d-p,k);</span><br><span class="line"><span class="keyword">if</span> (p&gt;=k+<span class="number">2</span>) ret=(ret+(k+<span class="number">1L</span>L)*calcpre(p-k<span class="number">-2</span>,d-p,k))%mod;</span><br><span class="line"><span class="keyword">if</span> (p&gt;=k+<span class="number">1</span>) ret=(ret-(k+<span class="number">2L</span>L)*calcpre(p-k<span class="number">-1</span>,d-p,k)%mod+mod)%mod;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">fact[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+n;i++) fact[i]=<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(fact[i<span class="number">-1</span>])*i%mod;</span><br><span class="line">ifact[n+n]=<span class="built_in">pow</span>(fact[n+n],mod<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=n+n;i;i--) ifact[i<span class="number">-1</span>]=<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(ifact[i])*i%mod;</span><br><span class="line">tmp=n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (!(tmp%i)) primes[++ptop]=i;</span><br><span class="line"><span class="keyword">while</span> (!(tmp%i)) tmp/=i,pcnt[ptop]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tmp&gt;<span class="number">1</span>) primes[++ptop]=tmp,pcnt[ptop]=<span class="number">1</span>;</span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=vtop;i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(m)*val[i]%n) <span class="keyword">continue</span>;</span><br><span class="line">ans=(ans+<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(vphi[vtop-i+<span class="number">1</span>])*calc(val[i],m/val[vtop-i+<span class="number">1</span>],k))%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(ans)*<span class="built_in">pow</span>(n,mod<span class="number">-2</span>)%mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 做题记录 </category>
          
          <category> LOJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Burnside 引理 </tag>
            
            <tag> 生成函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>付公主的背包</title>
      <link href="/2019/10/10/luogu4389/"/>
      <url>/2019/10/10/luogu4389/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定每个物品的大小$v_i$，每种物品有无穷个</p><p>求大小恰好为$s$的方案数，对所有$1\leq s\leq m$输出</p><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>一个大小为$v_i$的物品，其生成函数为</p><p>$$ f_{v_i}(x)=\sum_{j=0}^{\infty} x^{jv_i}=\frac{1}{1-x^{v_i}} $$</p><p>答案就是</p><p>$$ A(x)=\prod_{i=1}^{n}f_{v_i}(x) $$</p><p>的$1\sim m$次项系数</p><p>$$ A(x)=\prod_{i=1}^{n}f_{v_i}(x)=\frac{1}{\prod_{i=1}^{n}(1-x^{v_i})} $$</p><p>接下来考虑求$G(x)=\prod_{i=1}^{n}(1-x^{v_i})$</p><p>$$ G(x)=\prod_{i=1}^{n}(1-x^{v_i})=\exp\left(\ln\left(\prod_{i=1}^{n}(1-x^{v_i})\right)\right)=\exp\left(\sum_{i=1}^{n}\ln(1-x^{v_i})\right) $$</p><p>由于</p><p>$$ \ln(1-x^k)=-\sum_{i=1}^{\infty}\frac{x^{ik}}{i} $$</p><p>对于不超过$m$次项只有$\lfloor \frac{m}{k}\rfloor$项是有值的</p><p>因此对于相同的$v_i$一起计算，一共只需计算$O(m\log m)$项（调和级数）</p><p>只要求得了$\sum_{i=1}^{n}\ln(1-x^{v_i})$，再$\exp$一下就做完了</p><p>时间复杂度$O(n+m\log m)$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> mod=::mod)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (;b;b&gt;&gt;=<span class="number">1</span>,a=<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(a)*a%mod)</span><br><span class="line"><span class="keyword">if</span> (b&amp;<span class="number">1</span>) ret=<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(ret)*a%mod;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">chkinc</span><span class="params">(<span class="keyword">int</span> &amp;C)</span></span>&#123;C+=C&gt;&gt;<span class="number">31</span>&amp;mod;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> polyspace&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; poly;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">400000</span>;</span><br><span class="line"><span class="keyword">int</span> wn[MAXN],w[MAXN],rev[MAXN],lims,lim,inv[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFTinit</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">wn[<span class="number">0</span>]=lim=<span class="number">1</span>,lims=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (lim&lt;n) lim&lt;&lt;=<span class="number">1</span>,lims++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;lim;i++) rev[i]=rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>|(i&amp;<span class="number">1</span>)&lt;&lt;lims;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,g=<span class="built_in">pow</span>(<span class="number">3</span>,mod/lim);i&lt;lim;i++) wn[i]=<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(wn[i<span class="number">-1</span>])*g%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">int</span> *V,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++) <span class="keyword">if</span> (rev[i]&gt;i) <span class="built_in">std</span>::swap(V[rev[i]],V[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;lim;i&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>,t=lim/i/<span class="number">2</span>;j&lt;i;j++) w[j]=wn[j*t];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;lim;j+=i+i)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;k++)&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> X=V[j+k],Y=<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(w[k])*V[i+j+k]%mod;</span><br><span class="line">chkinc(V[j+k]+=Y-mod),chkinc(V[i+j+k]=X-Y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!f)&#123;</span><br><span class="line"><span class="built_in">std</span>::reverse(V+<span class="number">1</span>,V+lim);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> invlim=<span class="built_in">pow</span>(lim,mod<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++) V[i]=<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(invlim)*V[i]%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">poly &amp; <span class="keyword">operator</span> += (poly &amp;A,<span class="keyword">const</span> poly &amp;B)&#123;</span><br><span class="line"><span class="keyword">if</span> (A.size()&lt;B.size()) A.resize(B.size());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;B.size();i++) chkinc(A[i]+=B[i]-mod);</span><br><span class="line"><span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line">poly &amp; <span class="keyword">operator</span> -= (poly &amp;A,<span class="keyword">const</span> poly &amp;B)&#123;</span><br><span class="line"><span class="keyword">if</span> (A.size()&lt;B.size()) A.resize(B.size());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;B.size();i++) chkinc(A[i]-=B[i]);</span><br><span class="line"><span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line">poly <span class="keyword">operator</span> + (poly A,<span class="keyword">const</span> poly &amp;B)&#123;<span class="keyword">return</span> A+=B;&#125;</span><br><span class="line">poly <span class="keyword">operator</span> - (poly A,<span class="keyword">const</span> poly &amp;B)&#123;<span class="keyword">return</span> A-=B;&#125;</span><br><span class="line"></span><br><span class="line">poly <span class="keyword">operator</span> * (poly A,poly B)&#123;</span><br><span class="line"><span class="keyword">int</span> N=A.size()+B.size()<span class="number">-1</span>;</span><br><span class="line">FFTinit(N);</span><br><span class="line">A.resize(lim),B.resize(lim);</span><br><span class="line">FFT(A.data(),<span class="number">1</span>),FFT(B.data(),<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++) A[i]=<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(A[i])*B[i]%mod;</span><br><span class="line">FFT(A.data(),<span class="number">0</span>);</span><br><span class="line">A.resize(N);</span><br><span class="line"><span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line">poly &amp; <span class="keyword">operator</span> *= (poly &amp;A,<span class="keyword">const</span> poly &amp;B)&#123;<span class="keyword">return</span> A=A*B;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">poly <span class="title">Inv</span><span class="params">(poly A,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">A.resize(n);</span><br><span class="line"><span class="keyword">if</span> (n==<span class="number">1</span>) <span class="keyword">return</span> poly&#123;<span class="built_in">pow</span>(A[<span class="number">0</span>],mod<span class="number">-2</span>)&#125;;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> nxt=(n+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">poly ret=Inv(A,nxt),tmp=ret;</span><br><span class="line">FFTinit(n*<span class="number">3</span>/<span class="number">2</span>);</span><br><span class="line">tmp.resize(lim);</span><br><span class="line">A.resize(lim);</span><br><span class="line">FFT(tmp.data(),<span class="number">1</span>),FFT(A.data(),<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++) chkinc(A[i]=-<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(A[i])*tmp[i]%mod*tmp[i]%mod);</span><br><span class="line">FFT(A.data(),<span class="number">0</span>);</span><br><span class="line">ret.insert(ret.end(),A.begin()+nxt,A.begin()+n);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">poly <span class="title">Int</span><span class="params">(poly A)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;A.size();i++) A[i<span class="number">-1</span>]=<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(A[i])*i%mod;</span><br><span class="line">A.pop_back();</span><br><span class="line"><span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">poly <span class="title">Der</span><span class="params">(poly A)</span></span>&#123;</span><br><span class="line">A.push_back(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=A.size()<span class="number">-1</span>;i;i--) A[i]=<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(A[i<span class="number">-1</span>])*inv[i]%mod;</span><br><span class="line">A[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __attribute__((constructor)) initfact()&#123;</span><br><span class="line">inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;MAXN;i++) inv[i]=(mod-mod/i)*<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(inv[mod%i])%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">poly <span class="title">Ln</span><span class="params">(poly A,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">poly ret=Der(Int(A)*Inv(A,n));</span><br><span class="line">ret.resize(n);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">poly <span class="title">Exp</span><span class="params">(poly A,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">A.resize(n);</span><br><span class="line"><span class="keyword">if</span> (n==<span class="number">1</span>) <span class="keyword">return</span> poly&#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> nxt=(n+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">poly ret=Exp(A,nxt);</span><br><span class="line">ret=ret*(A-Ln(ret,n)+poly&#123;<span class="number">1</span>&#125;);</span><br><span class="line">ret.resize(n);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> polyspace;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> V[MAXN],cnt[MAXN];</span><br><span class="line">poly cc,tmp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;V[i]),cnt[V[i]]++;</span><br><span class="line">cc.resize(m+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>,t=<span class="number">0</span>;j&lt;=m;j+=i,t++)</span><br><span class="line">cc[j]=(cc[j]+cnt[i]*<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(inv[t]))%mod;</span><br><span class="line">cc=Exp(cc,m+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cc[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 做题记录 </category>
          
          <category> 洛谷 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FFT 快速傅里叶变换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC031D A Sequence of Permutations</title>
      <link href="/2019/10/09/agc031d/"/>
      <url>/2019/10/09/agc031d/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定排列$a_1=p$和$a_2=q$</p><p>定义排列$u,v$的函数$f(u,v)$的结果是排列，满足$u_i$下标的数为$v_i$</p><p>规定$a_n=f(a_{n-1},a_{n-2})$</p><p>求$a_m$</p><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>如果把排列（permutation）看做置换（permutation）</p><p>那么可以发现$f(u,v)=v\circ u^{-1}$</p><p>观察前若干项：</p><p>$$<br>\begin{aligned}<br>a_1&amp;=p \\<br>a_2&amp;=q \\<br>a_3&amp;=q\circ p^{-1} \\<br>a_4&amp;=q\circ p^{-1}\circ q^{-1} \\<br>a_5&amp;=q\circ p^{-1}\circ q^{-1}\circ p\circ q^{-1} \\<br>a_6&amp;=q\circ p^{-1}\circ q^{-1}\circ p^2\circ q^{-1} \\<br>a_7&amp;=q\circ p^{-1}\circ q^{-1}\circ p\circ q\circ p\circ q^{-1} \\<br>a_8&amp;=q\circ p^{-1}\circ q^{-1}\circ p\circ q\circ p^{-1}\circ q\circ p\circ q^{-1}<br>\end{aligned}<br>$$</p><p>如果令$g=q\circ p^{-1}\circ q^{-1}\circ p$</p><p>可以发现$a_m=g\circ a_{m-6}\circ g^{-1}$</p><p>发现结论以后可以容易的归纳证明</p><p>如果$m=6a+b,1\leq b\leq 6$，那么$a_m=g^a\circ a_{b}\circ g^{-a}$</p><p>时间复杂度$O(n)$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> PermutationSpace&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> PermutationLen=<span class="number">100000</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Permutation</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> P[PermutationLen+<span class="number">1</span>];</span><br><span class="line">Permutation()&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=PermutationLen;i++) P[i]=i;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> &amp; <span class="keyword">operator</span> [] (<span class="keyword">const</span> <span class="keyword">int</span> &amp;index)&#123;<span class="keyword">return</span> P[index];&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Permutation <span class="keyword">operator</span> * (Permutation A,Permutation B)&#123;</span><br><span class="line">Permutation C;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=PermutationLen;i++) C[i]=A[B[i]];</span><br><span class="line"><span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Permutation <span class="title">Inv</span><span class="params">(Permutation C)</span></span>&#123;</span><br><span class="line">Permutation D;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=PermutationLen;i++) D[C[i]]=i;</span><br><span class="line"><span class="keyword">return</span> D;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Permutation <span class="title">Pow</span><span class="params">(Permutation D,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> vis[PermutationLen+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> stk[PermutationLen],top;</span><br><span class="line">Permutation E;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=PermutationLen;i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">top=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> now=i;!vis[now];now=D[now])</span><br><span class="line">stk[top++]=now,vis[now]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;top;j++) E[stk[j]]=stk[(j+p)%top];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> E;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> PermutationSpace;</span><br><span class="line"></span><br><span class="line">Permutation A[<span class="number">6</span>],G;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;A[<span class="number">1</span>][i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;A[<span class="number">2</span>][j]);</span><br><span class="line">A[<span class="number">0</span>]=Inv(A[<span class="number">2</span>])*A[<span class="number">1</span>];</span><br><span class="line">A[<span class="number">3</span>]=A[<span class="number">2</span>]*Inv(A[<span class="number">1</span>]);</span><br><span class="line">A[<span class="number">4</span>]=A[<span class="number">3</span>]*Inv(A[<span class="number">2</span>]);</span><br><span class="line">A[<span class="number">5</span>]=A[<span class="number">4</span>]*Inv(A[<span class="number">3</span>]);</span><br><span class="line">G=A[<span class="number">2</span>]*Inv(A[<span class="number">1</span>])*Inv(A[<span class="number">2</span>])*A[<span class="number">1</span>];</span><br><span class="line">G=Pow(G,m/<span class="number">6</span>)*A[m%<span class="number">6</span>]*Pow(Inv(G),m/<span class="number">6</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,G[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 做题记录 </category>
          
          <category> AtCoder </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SPOJ DIVCNT2 Counting Divisors (square)</title>
      <link href="/2019/10/07/spojdivcnt2/"/>
      <url>/2019/10/07/spojdivcnt2/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>求</p><p>$$ S_2(n)=\sum_{i=1}^{n}\sigma_0(i^2) $$</p><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先得到如下结论</p><p>$$ \sigma_0(n^2)=\sum_{d|n}2^{\omega(d)} $$</p><p>其中$\omega(n)$表示$n$的不同质因子个数</p><p>可以这么解释：</p><p>先从$n$的约数中选择一个$d$</p><p>然后对于$n=p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_k^{\alpha_k}$，每种质因数要么全部选择（$p_i^{\alpha_i}$），要么全部不选（$1$），乘到$d$上，可以产生所有$n^2$的约数</p><p>$$<br>\begin{aligned}<br>S_2(n)<br>&amp;=\sum_{i=1}^{n}\sum_{d|i}2^{\omega(d)} \\<br>&amp;=\sum_{d=1}^{n}2^{\omega(d)}\lfloor\frac{n}{d}\rfloor<br>\end{aligned}<br>$$</p><p>进一步，考虑$2^{\omega(n)}$的意义</p><p>可以表示$n$的无平方因子的约数个数</p><p>$$ 2^{\omega(n)}=\sum_{d|n}\mu^2(d) $$</p><p>于是，</p><p>$$<br>\begin{aligned}<br>\sum_{i=1}^{n}2^{\omega(i)}<br>&amp;=\sum_{i=1}^{n}\sum_{d|i}\mu^2(i) \\<br>&amp;=\sum_{d=1}^{n}\mu^2(i)\lfloor\frac{n}{d}\rfloor<br>\end{aligned}<br>$$</p><p>更进一步，考虑$\mu^2(n)$如何计算</p><p>令$F(n)$表示$n$的最大平方因子的平方根，则</p><p>$$<br>\begin{aligned}<br>\sum_{i=1}^{n} \mu^2(n)<br>&amp;=\sum_{i=1}^{n}[F(n)==1] \\<br>&amp;=\sum_{i=1}^{n}\sum_{d|F(n)}\mu(d) \\<br>&amp;=\sum_{i=1}^{n}\sum_{d^2|n}\mu(d) \\<br>&amp;=\sum_{d=1}^{\lfloor\sqrt{n}\rfloor}\mu(d)\lfloor\frac{n}{d^2}\rfloor<br>\end{aligned}<br>$$</p><p>至此，可以用$\mu$得到$\mu^2$的前缀和（直接根号）</p><p>用$\mu^2$得到$2^{\omega}$的前缀和（整除分块）</p><p>再用$2^{\omega}$得到答案（整除分块）</p><p>这三个根号算法套上杜教筛的思想和分析方法就是$O(n^{\frac{2}{3}})$</p><p>综上，时间复杂度为$O(Tn^{\frac{2}{3}})$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Array</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> mxsize=<span class="number">1000500</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> fulsize;</span><br><span class="line"><span class="keyword">int</span> div;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ArrL[mxsize],ArrR[mxsize];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> &amp; <span class="keyword">operator</span> [] (<span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> &amp;idx)&#123;<span class="keyword">return</span> idx&lt;div?ArrL[idx]:ArrR[fulsize/idx];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(ArrL,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>)*div);</span><br><span class="line"><span class="built_in">memset</span>(ArrR,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>)*div);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">assign</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span></span>&#123;fulsize=n,div=sqrtl(n)+<span class="number">1</span>+<span class="number">1e-9</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Array</span><span class="params">()</span></span>&#123;</span><br><span class="line">fulsize=div=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(ArrL,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*mxsize);</span><br><span class="line"><span class="built_in">memset</span>(ArrR,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*mxsize);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> numberspace&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">70000000</span>;</span><br><span class="line"><span class="keyword">int</span> mu[MAXN],mu2[MAXN],minp[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> poww[MAXN];</span><br><span class="line"><span class="keyword">int</span> prime[MAXN],tot;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> vallist[<span class="number">2500000</span>],valtot;</span><br><span class="line">Array Mu2,Poww;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initsieve</span><span class="params">(<span class="keyword">int</span> MAXN=numberspace::MAXN)</span></span>&#123;</span><br><span class="line">mu2[<span class="number">1</span>]=mu[<span class="number">1</span>]=poww[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;MAXN;i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (!minp[i]) prime[++tot]=i,mu2[i]=<span class="number">1</span>,mu[i]=<span class="number">-1</span>,poww[i]=<span class="number">2</span>,minp[i]=i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;i*prime[j]&lt;MAXN;j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (prime[j]==minp[i])&#123;</span><br><span class="line">minp[i*prime[j]]=minp[i];</span><br><span class="line">mu2[i*prime[j]]=<span class="number">0</span>;</span><br><span class="line">mu[i*prime[j]]=<span class="number">0</span>;</span><br><span class="line">poww[i*prime[j]]=poww[i];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">minp[i*prime[j]]=prime[j];</span><br><span class="line">mu2[i*prime[j]]=mu2[i];</span><br><span class="line">mu[i*prime[j]]=-mu[i];</span><br><span class="line">poww[i*prime[j]]=poww[i]*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;MAXN;i++) mu2[i]+=mu2[i<span class="number">-1</span>],poww[i]+=poww[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">duinit</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">valtot=<span class="number">0</span>;</span><br><span class="line">Mu2.clear(),Poww.clear();</span><br><span class="line">Mu2.assign(n),Poww.assign(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> div=n/l;</span><br><span class="line">r=n/div;</span><br><span class="line">vallist[++valtot]=r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=valtot;i++)&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> &amp;val=vallist[i];</span><br><span class="line"><span class="keyword">if</span> (val&lt;MAXN) Mu2[val]=mu2[val],Poww[val]=poww[val];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>,t;(t=i*i)&lt;=val;i++) Mu2[val]+=mu[i]*(val/t);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> l=<span class="number">1</span>,r;l&lt;=val;l=r+<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> div=val/l;</span><br><span class="line">r=val/div,Poww[val]+=(Mu2[r]-Mu2[l<span class="number">-1</span>])*div;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans,N[<span class="number">10000</span>],Nmax;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;T;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;N[i]),Nmax=<span class="built_in">std</span>::max(Nmax,N[i]);</span><br><span class="line">numberspace::initsieve(<span class="built_in">std</span>::min&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(Nmax+<span class="number">1</span>,numberspace::MAXN));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;T;i++)&#123;</span><br><span class="line">numberspace::duinit(N[i]);</span><br><span class="line">ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> l=<span class="number">1</span>,r;l&lt;=N[i];l=r+<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> div=N[i]/l;</span><br><span class="line">r=N[i]/div;</span><br><span class="line">ans+=(numberspace::Poww[r]-numberspace::Poww[l<span class="number">-1</span>])*div;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 做题记录 </category>
          
          <category> SPOJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杜教筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>THUWC 2017 在美妙的数学王国中畅游</title>
      <link href="/2019/10/06/loj2289/"/>
      <url>/2019/10/06/loj2289/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>维护一棵动态树，每个节点上有$\sin(ax+b),e^{ax+b},ax+b$中的一种函数</p><p>其中$a,b$是绑定在节点的属性</p><p>支持加边删边，单点修改函数类型和属性</p><p>询问路径上取$x_0$的函数值之和</p><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>在题面下方给出了函数的泰勒展开式：</p><p>$$ f(x)=f(x_0)+\frac{f’(x_0)(x-x_0)}{1!}+\frac{f’’(x_0)(x-x_0)^2}{2!}+ \cdots +\frac{f^{(n)}(\xi)(x-x_0)^n}{n!} $$</p><p>取$x_0=0$，可以得到</p><p>$$ \sin(ax+b)=\sin(b)+\frac{\cos(b)ax}{1!}-\frac{\sin(b)a^2x^2}{2!}-\frac{\cos(b)a^3x^3}{3!}+\frac{\sin(b)a^4x^4}{4!}+\cdots $$</p><p>$$ e^{ax+b}=e^b(1+\frac{ax}{1!}+\frac{a^2x^2}{2!}+\frac{a^3x^3}{3!}+\cdots) $$</p><p>而对于一次函数不作处理</p><p>大约只需要取次数不超过$12$的项就可以得到精度极高的近似值</p><p>剩下的只需要用LCT维护，链上泰勒展开后函数和，带入询问值即可</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi=acosl(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LCT</span>&#123;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100050</span>,funcmax=<span class="number">12</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> son[<span class="number">2</span>],fa;</span><br><span class="line"><span class="keyword">bool</span> flip;</span><br><span class="line"><span class="keyword">double</span> func[funcmax],funcsum[funcmax];</span><br><span class="line">node()&#123;</span><br><span class="line">son[<span class="number">0</span>]=son[<span class="number">1</span>]=fa=<span class="number">0</span>,flip=<span class="literal">false</span>;</span><br><span class="line"><span class="built_in">memset</span>(func,<span class="number">0</span>,<span class="keyword">sizeof</span>(func));</span><br><span class="line"><span class="built_in">memset</span>(funcsum,<span class="number">0</span>,<span class="keyword">sizeof</span>(funcsum));</span><br><span class="line">&#125;</span><br><span class="line">&#125;T[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> o)</span></span>&#123;<span class="keyword">return</span> T[T[o].fa].son[<span class="number">0</span>]!=o&amp;&amp;T[T[o].fa].son[<span class="number">1</span>]!=o;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">way</span><span class="params">(<span class="keyword">int</span> o)</span></span>&#123;<span class="keyword">return</span> T[T[o].fa].son[<span class="number">1</span>]==o;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">puttag</span><span class="params">(<span class="keyword">int</span> o)</span></span>&#123;<span class="built_in">std</span>::swap(T[o].son[<span class="number">0</span>],T[o].son[<span class="number">1</span>]),T[o].flip^=<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> o)</span></span>&#123;<span class="keyword">if</span> (T[o].flip) puttag(T[o].son[<span class="number">0</span>]),puttag(T[o].son[<span class="number">1</span>]),T[o].flip=<span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> o)</span></span>&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;funcmax;i++) T[o].funcsum[i]=T[T[o].son[<span class="number">0</span>]].funcsum[i]+T[T[o].son[<span class="number">1</span>]].funcsum[i]+T[o].func[i];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> o)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> F=T[o].fa,G=T[F].fa,w=way(o),S=T[o].son[!w];</span><br><span class="line"><span class="keyword">if</span> (!isroot(F)) T[G].son[way(F)]=o;</span><br><span class="line">T[o].son[!w]=F,T[F].son[w]=S;</span><br><span class="line">T[S].fa=F,T[F].fa=o,T[o].fa=G;</span><br><span class="line">update(F),update(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> o)</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> stk[MAXN],top=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> now=o;!isroot(stk[++top]=now);now=T[now].fa);</span><br><span class="line"><span class="keyword">while</span> (top) pushdown(stk[top--]);</span><br><span class="line"><span class="keyword">for</span> (;!isroot(o);rotate(o))</span><br><span class="line"><span class="keyword">if</span> (!isroot(T[o].fa))</span><br><span class="line">rotate(way(o)^way(T[o].fa)?o:T[o].fa);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> o)</span></span>&#123;<span class="keyword">for</span> (<span class="keyword">int</span> ls=<span class="number">0</span>;o;splay(o),T[o].son[<span class="number">1</span>]=ls,update(ls=o),o=T[o].fa);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> o)</span></span>&#123;access(o),splay(o),puttag(o);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;makeroot(x),access(y),splay(y);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">haveedge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> split(x,y),T[x].fa==y&amp;&amp;!T[x].son[<span class="number">1</span>];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">conn</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x==y||(split(x,y),T[x].fa);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">if</span> (!conn(x,y)) T[x].fa=y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">if</span> (haveedge(x,y)) T[x].fa=T[y].son[<span class="number">0</span>]=<span class="number">0</span>,update(y);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modifytype</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> tp,<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">access(o),splay(o);</span><br><span class="line"><span class="keyword">double</span> tmp=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (tp==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">double</span> sinlist[<span class="number">4</span>]=&#123;<span class="built_in">sin</span>(b),<span class="built_in">cos</span>(b)&#125;;</span><br><span class="line">sinlist[<span class="number">2</span>]=-sinlist[<span class="number">0</span>],sinlist[<span class="number">3</span>]=-sinlist[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;funcmax;i++)&#123;</span><br><span class="line">T[o].func[i]=sinlist[i%<span class="number">4</span>]*tmp;</span><br><span class="line">tmp*=a/(i+<span class="number">1.</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (tp==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> expval=expl(b);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;funcmax;i++)&#123;</span><br><span class="line">T[o].func[i]=expval*tmp;</span><br><span class="line">tmp*=a/(i+<span class="number">1.</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">T[o].func[<span class="number">0</span>]=b,T[o].func[<span class="number">1</span>]=a;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;funcmax;i++) T[o].func[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">update(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">double</span> val)</span></span>&#123;</span><br><span class="line">split(x,y);</span><br><span class="line"><span class="keyword">double</span> f=<span class="number">0</span>,v=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;funcmax;i++,v*=val) f+=v*T[y].funcsum[i];</span><br><span class="line"><span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">&#125;T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> opt[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> x,y,t;</span><br><span class="line"><span class="keyword">double</span> g,u,v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%*s"</span>,&amp;n,&amp;Q);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%lf%lf"</span>,&amp;t,&amp;u,&amp;v);</span><br><span class="line">T.modifytype(i,t,u,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (Q--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,opt);</span><br><span class="line"><span class="keyword">switch</span> (opt[<span class="number">0</span>])&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">T.link(x+<span class="number">1</span>,y+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">T.cut(x+<span class="number">1</span>,y+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'m'</span>:</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%lf%lf"</span>,&amp;x,&amp;y,&amp;u,&amp;v);</span><br><span class="line">T.modifytype(x+<span class="number">1</span>,y,u,v);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'t'</span>:</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%lf"</span>,&amp;x,&amp;y,&amp;g);</span><br><span class="line"><span class="keyword">if</span> (!T.conn(x+<span class="number">1</span>,y+<span class="number">1</span>)) <span class="built_in">puts</span>(<span class="string">"unreachable"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%.12le\n"</span>,T.query(x+<span class="number">1</span>,y+<span class="number">1</span>,g));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 做题记录 </category>
          
          <category> LOJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Link-cut Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UOJ 266 【清华集训2016】Alice和Bob又在玩游戏</title>
      <link href="/2019/09/28/uoj266/"/>
      <url>/2019/09/28/uoj266/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Alice 和 Bob 在玩游戏。</p><p>给定一个有根树森林，每次一方可以选择一个存在的节点$x$，将$x$到根路径上的节点全部删除。</p><p>问 Alice 是否必胜。</p><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>显然，每一棵树是独立的，考虑应用SG定理，计算每一棵树的SG值得到答案。</p><p>现在的问题是，一棵树的SG值如何求得。</p><p>对于一棵树，指定的节点可能是根，也可能在某个子树中：</p><ol><li><p>如果删去根，到达的状态SG值是所有子树SG值的异或和。</p></li><li><p>如果删去某个子树中的节点，所有能到达的状态SG值是 其他子树SG值异或和 异或 该子树能到达的状态的SG值。</p></li></ol><p>可以用Trie维护子树能到达状态的SG值</p><p>对于情况 1. 只需要在Trie中插入</p><p>对于情况 2. ，可以对所有子树的Trie先打上 异或其他子树SG值异或和 的标记，然后Trie合并</p><p>为了确定$mex$，就是找到当前Trie中最小的没有出现过的数</p><p>我的做法是再维护Trie上的$size$，如果某个节点$size$是满的就在兄弟节点中找</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T,n,m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> son[<span class="number">60000000</span>][<span class="number">2</span>],tag[<span class="number">60000000</span>],sz[<span class="number">60000000</span>],top;</span><br><span class="line"><span class="keyword">int</span> roots[<span class="number">100050</span>],rtop,SG[<span class="number">100050</span>],root[<span class="number">100050</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">100050</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> to,nxt;&#125;E[<span class="number">200050</span>];</span><br><span class="line"><span class="keyword">int</span> H[<span class="number">100050</span>],tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">E[++tot]=(edge)&#123;b,H[a]&#125;;H[a]=tot;</span><br><span class="line">E[++tot]=(edge)&#123;a,H[b]&#125;;H[b]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp=now;</span><br><span class="line">vis[now]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=H[now];i;i=E[i].nxt)</span><br><span class="line"><span class="keyword">if</span> (E[i].to!=fa) tmp=<span class="built_in">std</span>::min(tmp,dfs(E[i].to,now));</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tag[now]&gt;&gt;dep&amp;<span class="number">1</span>) <span class="built_in">std</span>::swap(son[now][<span class="number">0</span>],son[now][<span class="number">1</span>]);</span><br><span class="line">tag[son[now][<span class="number">0</span>]]^=tag[now],tag[son[now][<span class="number">1</span>]]^=tag[now];</span><br><span class="line">tag[now]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;sz[now]=sz[son[now][<span class="number">0</span>]]+sz[son[now][<span class="number">1</span>]];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> &amp;now,<span class="keyword">int</span> t,<span class="keyword">int</span> dep)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!now)&#123;now=t;<span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">if</span> (!t) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (dep&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">pushdown(now,dep);</span><br><span class="line">pushdown(t,dep);</span><br><span class="line">merge(son[now][<span class="number">0</span>],son[t][<span class="number">0</span>],dep<span class="number">-1</span>);</span><br><span class="line">merge(son[now][<span class="number">1</span>],son[t][<span class="number">1</span>],dep<span class="number">-1</span>);</span><br><span class="line">update(now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> dep,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!~dep) <span class="keyword">return</span> v;</span><br><span class="line">pushdown(now,dep);</span><br><span class="line"><span class="keyword">if</span> (sz[son[now][<span class="number">0</span>]]==<span class="number">1</span>&lt;&lt;dep) <span class="keyword">return</span> find(son[now][<span class="number">1</span>],dep<span class="number">-1</span>,v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> find(son[now][<span class="number">0</span>],dep<span class="number">-1</span>,v&lt;&lt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;now,<span class="keyword">int</span> dep,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!now) now=++top;</span><br><span class="line"><span class="keyword">if</span> (dep&lt;<span class="number">0</span>)&#123;sz[now]=<span class="number">1</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">pushdown(now,dep);</span><br><span class="line"><span class="keyword">if</span> (v&gt;&gt;dep&amp;<span class="number">1</span>) insert(son[now][<span class="number">1</span>],dep<span class="number">-1</span>,v);</span><br><span class="line"><span class="keyword">else</span> insert(son[now][<span class="number">0</span>],dep<span class="number">-1</span>,v);</span><br><span class="line">update(now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> sons=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=H[now];i;i=E[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span> (E[i].to!=fa)&#123;</span><br><span class="line">solve(E[i].to,now);</span><br><span class="line">SG[now]^=SG[E[i].to];</span><br><span class="line">sons=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">root[now]=++top;</span><br><span class="line"><span class="keyword">if</span> (!sons)&#123;</span><br><span class="line">insert(root[now],<span class="number">14</span>,<span class="number">0</span>);</span><br><span class="line">insert(root[now],<span class="number">14</span>,<span class="number">1</span>);</span><br><span class="line">SG[now]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=H[now];i;i=E[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span> (E[i].to!=fa)&#123;</span><br><span class="line">tag[root[E[i].to]]^=SG[now]^SG[E[i].to];</span><br><span class="line">merge(root[now],root[E[i].to],<span class="number">14</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">SG[now]=find(root[now],<span class="number">14</span>,<span class="number">0</span>);</span><br><span class="line">insert(root[now],<span class="number">14</span>,SG[now]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span> (T--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">Ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y),add_edge(x,y);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span> (!vis[i]) roots[++rtop]=dfs(i,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=rtop;i++) solve(roots[i],<span class="number">0</span>),Ans^=SG[roots[i]];</span><br><span class="line"><span class="built_in">puts</span>(Ans?<span class="string">"Alice"</span>:<span class="string">"Bob"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// clear</span></span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">bool</span>)*(n+<span class="number">1</span>));</span><br><span class="line"><span class="built_in">memset</span>(son,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">2</span>*(top+<span class="number">1</span>));</span><br><span class="line"><span class="built_in">memset</span>(tag,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(top+<span class="number">1</span>));</span><br><span class="line"><span class="built_in">memset</span>(sz,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(top+<span class="number">1</span>));</span><br><span class="line"><span class="built_in">memset</span>(root,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line"><span class="built_in">memset</span>(SG,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line"><span class="built_in">memset</span>(E,<span class="number">0</span>,<span class="keyword">sizeof</span>(edge)*(tot+<span class="number">1</span>));</span><br><span class="line"><span class="built_in">memset</span>(H,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">tot=top=rtop=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 做题记录 </category>
          
          <category> UOJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Trie </tag>
            
            <tag> 博弈论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UOJ 335 【清华集训2017】生成树计数</title>
      <link href="/2019/09/23/uoj335/"/>
      <url>/2019/09/23/uoj335/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个$s$个点的图中，存在$s−n$条边，使图中形成了$n$个连通块，第$i$个连通块中有$a_i$个点。</p><p>现在我们需要再连接$n−1$条边，使该图变成一棵树。对一种连边方案，设原图中第$i$个连通块连出了$d_i$条边，那么这棵树$T$的价值为：</p><p>$$ \mathrm{val}(T)=(\prod_{i=1}^{n}d_i^m)(\sum_{i=1}^{n}d_i^m) $$</p><p>你的任务是求出所有可能的生成树的价值之和，对$998244353$取模。</p><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>所求的答案：</p><p>$$<br>\begin{align}<br>Ans \nonumber<br>&amp;=\sum_{T}(\sum_{i=1}^{n}d_i^m)(\prod_{i=1}^{n}d_i^m)(\prod_{i=1}^{n}a_i^{d_i})<br>\end{align}<br>$$</p><p>换成枚举Prüfer序列，$s$为每个结点出现次数</p><p>由Prüfer序列的性质，$s_i+1$就是$i$号点的度数</p><p>$$<br>\begin{align}<br>Ans \nonumber<br>&amp;=\sum_{P}(\sum_{i=1}^{n}(s_i+1)^m)(\prod_{i=1}^{n}(s_i+1)^m)(\prod_{i=1}^{n}a_i^{s_i+1}) \\\nonumber<br>&amp;=\sum_{s}[\sum s=n-2]\frac{(n-2)!}{\prod s_i!}(\sum (s_i+1)^m)(\prod (s_i+1)^m)(\prod a_i^{s_i+1})<br>\end{align}<br>$$</p><p>令常数$C=(n-2)!\prod a_i$，</p><p>$$<br>\begin{align}<br>Ans \nonumber<br>&amp;=C\sum_{s}[\sum s=n-2](\sum (s_i+1)^m)(\prod\frac{1}{s_i!})(\prod (s_i+1)^m)(\prod a_i^{s_i}) \\\nonumber<br>&amp;=C\sum_{s}[\sum s=n-2](\sum (s_i+1)^m)(\prod\frac{(s_i+1)^m a_i^{s_i}}{s_i!})<br>\end{align}<br>$$</p><p>接下来是令人费解的转换，将$i=j$的项移到求和项考虑：</p><p>$$<br>\begin{align}<br>Ans \nonumber<br>&amp;=C\sum_{s}[\sum s=n-2](\sum_{i=1}^{n} \frac{(s_i+1)^{2m} a_i^{s_i}}{s_i!}\prod_{j\neq i}\frac{(s_j+1)^m a_j^{s_j}}{s_j!})<br>\end{align}<br>$$</p><p>定义生成函数$A$和$B$：</p><p>$$ A(x)=\sum_{k=0}^{\infty}{\frac{(k+1)^{2m}x^k}{k!}} $$</p><p>$$ B(x)=\sum_{k=0}^{\infty}{\frac{(k+1)^m x^k}{k!}} $$</p><p>可以得到：</p><p>$$<br>\begin{align}<br>Ans \nonumber<br>&amp;=C[x^{n-2}]\sum_{i=1}^{n}A(a_i x)\prod_{j\neq i}B(a_j x) \\\nonumber<br>&amp;=C[x^{n-2}](\sum_{i=1}^{n}\frac{A(a_i x)}{B(a_i x)})(\prod_{j=1}^{n}B(a_j x)) \\\nonumber<br>&amp;=C[x^{n-2}](\sum_{i=1}^{n}\frac{A(a_i x)}{B(a_i x)})\exp(\sum_{j=1}^{n}\ln B(a_j x))<br>\end{align}<br>$$</p><p>令$F(x)=\frac{A(x)}{B(x)},G(x)=\ln B(x)$</p><p>$$<br>\begin{align}<br>Ans \nonumber<br>&amp;=C[x^{n-2}](\sum_{i=1}^{n}F(a_i x))\exp(\sum_{i=1}^{n}G(a_i x)) \\\nonumber<br>&amp;=C[x^{n-2}](\sum_{k=0}^{\infty}F_k x^k\sum_{i=1}^{n}a_i^k)\exp(\sum_{k=0}^{\infty}G_k x^k\sum_{i=1}^{n}a_i^k)<br>\end{align}<br>$$</p><p>至此，只要对于所有的$k\in [0,n-2]$快速得到$\sum_{i=1}^{n}a_i^k$即可</p><p>令：</p><p>$$<br>\begin{align}<br>Z(x) \nonumber<br>&amp;=\sum_{k=0}^{\infty}\sum_{i=1}^{n}a_i^kx^k \\\nonumber<br>&amp;=\sum_{k=0}^{\infty}\sum_{i=1}^{n}(a_ix)^k \\\nonumber<br>&amp;=\sum_{i=1}^{n}\sum_{k=0}^{\infty}(a_ix)^k \\\nonumber<br>&amp;=\sum_{i=1}^{n}\frac{1}{1-a_ix}<br>\end{align}<br>$$</p><p>用此式进行分治FFT已经可以得到$Z$了，也可以进一步推导但复杂度不变：</p><p>令$D(x)=\prod_{i=1}^{n}(1-a_ix)$</p><p>可以发现$Z(x)=n-\frac{xD’(x)}{D(x)}$</p><p>这样的编程难度会小一些</p><p>总时间复杂度$O(n\log^2 n)$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,A[<span class="number">50000</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> mod=::mod)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (;b;b&gt;&gt;=<span class="number">1</span>,a=<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(a)*a%mod)</span><br><span class="line"><span class="keyword">if</span> (b&amp;<span class="number">1</span>) ret=<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(ret)*a%mod;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">chkinc</span><span class="params">(<span class="keyword">int</span> &amp;C)</span></span>&#123;C+=C&gt;&gt;<span class="number">31</span>&amp;mod;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> polyspace&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; poly;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">200000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> wn[MAXN],w[MAXN],lim,lims,rev[MAXN],inv[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFTinit</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">wn[<span class="number">0</span>]=lim=<span class="number">1</span>,lims=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (lim&lt;n) lim&lt;&lt;=<span class="number">1</span>,lims++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;lim;i++) rev[i]=rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>|(i&amp;<span class="number">1</span>)&lt;&lt;lims;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> g=<span class="built_in">pow</span>(<span class="number">3</span>,mod/lim),i=<span class="number">1</span>;i&lt;lim;i++) wn[i]=<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(wn[i<span class="number">-1</span>])*g%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">int</span> *V,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++) <span class="keyword">if</span> (rev[i]&gt;i) <span class="built_in">std</span>::swap(V[rev[i]],V[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;lim;i&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>,t=lim/<span class="number">2</span>/i;j&lt;i;j++) w[j]=wn[j*t];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;lim;j+=i+i)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;k++)&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> X=V[j+k],Y=<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(V[i+j+k])*w[k]%mod;</span><br><span class="line">chkinc(V[j+k]+=Y-mod),chkinc(V[i+j+k]=X-Y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!f)&#123;</span><br><span class="line"><span class="built_in">std</span>::reverse(V+<span class="number">1</span>,V+lim);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> invlim=<span class="built_in">pow</span>(lim,mod<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++) V[i]=<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(V[i])*invlim%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">poly &amp; <span class="keyword">operator</span> += (poly &amp;A,<span class="keyword">const</span> poly &amp;B)&#123;</span><br><span class="line"><span class="keyword">if</span> (A.size()&lt;B.size()) A.resize(B.size());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.size();i++) chkinc(A[i]+=B[i]-mod);</span><br><span class="line"><span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line">poly &amp; <span class="keyword">operator</span> -= (poly &amp;A,<span class="keyword">const</span> poly &amp;B)&#123;</span><br><span class="line"><span class="keyword">if</span> (A.size()&lt;B.size()) A.resize(B.size());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.size();i++) chkinc(A[i]-=B[i]);</span><br><span class="line"><span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line">poly <span class="keyword">operator</span> + (poly A,<span class="keyword">const</span> poly &amp;B)&#123;<span class="keyword">return</span> A+=B;&#125;</span><br><span class="line">poly <span class="keyword">operator</span> - (poly A,<span class="keyword">const</span> poly &amp;B)&#123;<span class="keyword">return</span> A-=B;&#125;</span><br><span class="line"></span><br><span class="line">poly <span class="keyword">operator</span> * (poly A,poly B)&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=A.size()+B.size()<span class="number">-1</span>;</span><br><span class="line">FFTinit(N);</span><br><span class="line">A.resize(lim),B.resize(lim);</span><br><span class="line">FFT(A.data(),<span class="number">1</span>),FFT(B.data(),<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++) A[i]=<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(A[i])*B[i]%mod;</span><br><span class="line">FFT(A.data(),<span class="number">0</span>);</span><br><span class="line">A.resize(N);</span><br><span class="line"><span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line">poly &amp; <span class="keyword">operator</span> *= (poly &amp;A,<span class="keyword">const</span> poly &amp;B)&#123;<span class="keyword">return</span> A=A*B;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">poly <span class="title">Inv</span><span class="params">(poly A,<span class="keyword">int</span> N)</span></span>&#123; <span class="comment">// N&gt;0</span></span><br><span class="line">A.resize(N);</span><br><span class="line"><span class="keyword">if</span> (N==<span class="number">1</span>) <span class="keyword">return</span> poly&#123;<span class="built_in">pow</span>(A[<span class="number">0</span>],mod<span class="number">-2</span>)&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> nxt=(N+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">poly ret=Inv(A,nxt),tmp=ret;</span><br><span class="line">FFTinit(N*<span class="number">3</span>/<span class="number">2</span>);</span><br><span class="line">A.resize(lim),ret.resize(N),tmp.resize(lim);</span><br><span class="line">FFT(A.data(),<span class="number">1</span>);</span><br><span class="line">FFT(tmp.data(),<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++) A[i]=<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(A[i])*tmp[i]%mod*tmp[i]%mod;</span><br><span class="line">FFT(A.data(),<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=nxt;i&lt;N;i++) chkinc(ret[i]=-A[i]);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">poly <span class="title">Der</span><span class="params">(poly A)</span></span>&#123; <span class="comment">// A.size()&gt;0</span></span><br><span class="line">poly B;</span><br><span class="line">B.resize(A.size()<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;B.size();i++) B[i]=(i+<span class="number">1L</span>L)*A[i+<span class="number">1</span>]%mod;</span><br><span class="line"><span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">poly <span class="title">Int</span><span class="params">(poly A)</span></span>&#123;</span><br><span class="line">poly B;</span><br><span class="line">B.resize(A.size()+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.size();i++) B[i+<span class="number">1</span>]=<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(A[i])*inv[i+<span class="number">1</span>]%mod;</span><br><span class="line"><span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">poly <span class="title">Ln</span><span class="params">(poly A,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">assert(A[<span class="number">0</span>]==<span class="number">1</span>);</span><br><span class="line">A.resize(N);</span><br><span class="line">poly ret=Int(Der(A)*Inv(A,N));</span><br><span class="line">ret.resize(N);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">poly <span class="title">Exp</span><span class="params">(poly A,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">assert(A[<span class="number">0</span>]==<span class="number">0</span>);</span><br><span class="line">A.resize(N);</span><br><span class="line"><span class="keyword">if</span> (N==<span class="number">1</span>) <span class="keyword">return</span> poly&#123;<span class="number">1</span>&#125;;</span><br><span class="line">poly ret=Exp(A,(N+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">ret*=(poly&#123;<span class="number">1</span>&#125;+A-Ln(ret,N));</span><br><span class="line">ret.resize(N);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((constructor)) <span class="function"><span class="keyword">void</span> <span class="title">polyinit</span><span class="params">()</span></span>&#123;</span><br><span class="line">inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;MAXN;i++) inv[i]=<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(mod-mod/i)*inv[mod%i]%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> polyspace;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fact[MAXN],ifact[MAXN];</span><br><span class="line">poly P,Q,R;</span><br><span class="line"></span><br><span class="line"><span class="function">poly <span class="title">solve</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L==R) <span class="keyword">return</span> poly&#123;<span class="number">1</span>,(mod-A[L])%mod&#125;;</span><br><span class="line"><span class="keyword">int</span> mdl=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> solve(L,mdl)*solve(mdl+<span class="number">1</span>,R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">poly <span class="title">shift</span><span class="params">(poly A)</span></span>&#123;</span><br><span class="line">A.resize(A.size()+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=A.size()<span class="number">-1</span>;i;i--) A[i]=A[i<span class="number">-1</span>];</span><br><span class="line">A[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;A[i]);</span><br><span class="line">R=solve(<span class="number">1</span>,n);</span><br><span class="line">fact[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fact[i]=<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(fact[i<span class="number">-1</span>])*i%mod;</span><br><span class="line">ifact[n]=<span class="built_in">pow</span>(fact[n],mod<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=n;i;i--) ifact[i<span class="number">-1</span>]=<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(ifact[i])*i%mod;</span><br><span class="line"></span><br><span class="line">poly X=shift(Der(R))*Inv(R,n);</span><br><span class="line">X.resize(n);</span><br><span class="line">X=poly&#123;n&#125;-X;</span><br><span class="line">P.resize(n<span class="number">-1</span>),Q.resize(n<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++) P[i]=<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(<span class="built_in">pow</span>(i+<span class="number">1</span>,<span class="number">2</span>*m))*ifact[i]%mod%mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++) Q[i]=<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(<span class="built_in">pow</span>(i+<span class="number">1</span>,m))*ifact[i]%mod;</span><br><span class="line">P*=Inv(Q,n<span class="number">-1</span>);</span><br><span class="line">P.resize(n<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++) P[i]=<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(P[i])*X[i]%mod;</span><br><span class="line">Q=Ln(Q,n<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++) Q[i]=<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(Q[i])*X[i]%mod;</span><br><span class="line">Q=Exp(Q,n<span class="number">-1</span>);</span><br><span class="line">P*=Q;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(P[n<span class="number">-2</span>])*fact[n<span class="number">-2</span>]%mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans=<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(ans)*A[i]%mod;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 做题记录 </category>
          
          <category> UOJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FFT 快速傅里叶变换 </tag>
            
            <tag> 生成函数 </tag>
            
            <tag> Prüfer序列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 280D k-Maximum Subsequence Sum</title>
      <link href="/2019/09/20/cf280d/"/>
      <url>/2019/09/20/cf280d/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>维护一个长度为$n$的整数序列$A$</p><p>支持单点修改，区间询问选出$k$个无交子区间的最大和</p><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>先考虑建出费用流模型</p><p>一共$n+1$个结点，$i$向$i+1$的费用是$A_i$</p><p>$S$连向所有结点，所有结点连向$T$，所有边流量为$1$</p><p>这样建模，一条增广路只有以下两种实际意义</p><ul><li>选择一段没选过元素的区间</li><li>删掉一段全部被选择的区间（边权取负）</li></ul><p>这样增广$k$次就选出了至多$k$个区间</p><p>在这基础上，每次找到费用最大的增广路，就是找到两种情况下和最大的区间</p><p>如果用$0,1$代表一个元素未选择和选择，可以用线段树维护同状态最大子段和，并且支持区间反转状态</p><p>维护的信息会很多，需要优秀的实现方法（在我的实现中，一个结点维护了$33$个信息）</p><p>注意需要撤销操作</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,A[<span class="number">200000</span>],Q;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> minv=<span class="number">0xcfcfcfcf</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> Ls,Rs,sum,mx,Lx,Rx,Lp,Rp;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">data</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">data</span><span class="params">(<span class="keyword">int</span> Ls_,<span class="keyword">int</span> Rs_,<span class="keyword">int</span> sum_,<span class="keyword">int</span> mx_,<span class="keyword">int</span> Lx_,<span class="keyword">int</span> Rx_,<span class="keyword">int</span> Lp_,<span class="keyword">int</span> Rp_)</span></span>&#123;Ls=Ls_,Rs=Rs_,sum=sum_,mx=mx_,Lx=Lx_,Rx=Rx_,Lp=Lp_,Rp=Rp_;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">friend</span> data <span class="keyword">operator</span> + (<span class="keyword">const</span> data &amp;A,<span class="keyword">const</span> data &amp;B)&#123;</span><br><span class="line">data C;</span><br><span class="line">C.sum=<span class="built_in">std</span>::max(A.sum+B.sum,minv);</span><br><span class="line"><span class="keyword">if</span> (A.Ls&lt;A.sum+B.Ls) C.Ls=A.sum+B.Ls,C.Lx=B.Lx;</span><br><span class="line"><span class="keyword">else</span> C.Ls=A.Ls,C.Lx=A.Lx;</span><br><span class="line"><span class="keyword">if</span> (B.Rs&lt;B.sum+A.Rs) C.Rs=B.sum+A.Rs,C.Rx=A.Rx;</span><br><span class="line"><span class="keyword">else</span> C.Rs=B.Rs,C.Rx=B.Rx;</span><br><span class="line"><span class="keyword">if</span> (A.Rs+B.Ls&gt;<span class="built_in">std</span>::max(A.mx,B.mx)) C.mx=A.Rs+B.Ls,C.Lp=A.Rx,C.Rp=B.Lx;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (A.mx&gt;B.mx) C.mx=A.mx,C.Lp=A.Lp,C.Rp=A.Rp;</span><br><span class="line"><span class="keyword">else</span> C.mx=B.mx,C.Lp=B.Lp,C.Rp=B.Rp;</span><br><span class="line"><span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">bool</span> flip;</span><br><span class="line">data D0,D1,E0,E1;</span><br><span class="line">&#125;T[<span class="number">800000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">puttag</span><span class="params">(<span class="keyword">int</span> o)</span></span>&#123;<span class="built_in">std</span>::swap(T[o].D0,T[o].E0),<span class="built_in">std</span>::swap(T[o].D1,T[o].E1),T[o].flip^=<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> o)</span></span>&#123;<span class="keyword">if</span> (T[o].flip) puttag(o&lt;&lt;<span class="number">1</span>),puttag(o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>),T[o].flip=<span class="literal">false</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> o)</span></span>&#123;</span><br><span class="line">T[o].D0=T[o&lt;&lt;<span class="number">1</span>].D0+T[o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].D0,T[o].D1=T[o&lt;&lt;<span class="number">1</span>].D1+T[o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].D1;</span><br><span class="line">T[o].E0=T[o&lt;&lt;<span class="number">1</span>].E0+T[o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].E0,T[o].E1=T[o&lt;&lt;<span class="number">1</span>].E1+T[o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].E1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>,node&gt; &gt; operations;</span><br><span class="line"><span class="keyword">bool</span> trace[<span class="number">800000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traceback</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>,node&gt; &gt;::reverse_iterator it=operations.rbegin();it!=operations.rend();++it) T[it-&gt;first]=it-&gt;second,trace[it-&gt;first]=<span class="literal">false</span>;</span><br><span class="line">operations.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addtrace</span><span class="params">(<span class="keyword">int</span> o)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (trace[o]) <span class="keyword">return</span>;</span><br><span class="line">trace[o]=<span class="literal">true</span>;</span><br><span class="line">operations.push_back(<span class="built_in">std</span>::make_pair(o,T[o]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::pair&lt;data,data&gt; query(<span class="keyword">int</span> o,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R)&#123;</span><br><span class="line">addtrace(o);</span><br><span class="line"><span class="keyword">if</span> (l&gt;R||r&lt;L) <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(data(minv,minv,minv,minv,L,L,L,L),data(minv,minv,minv,minv,L,L,L,L));</span><br><span class="line"><span class="keyword">if</span> (L&lt;=l&amp;&amp;r&lt;=R) <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(T[o].D0,T[o].D1);</span><br><span class="line">addtrace(o&lt;&lt;<span class="number">1</span>);</span><br><span class="line">addtrace(o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">pushdown(o);</span><br><span class="line"><span class="keyword">int</span> mdl=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">std</span>::pair&lt;data,data&gt; Ld=query(o&lt;&lt;<span class="number">1</span>,l,mdl,L,R);</span><br><span class="line"><span class="built_in">std</span>::pair&lt;data,data&gt; Rd=query(o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mdl+<span class="number">1</span>,r,L,R);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::make_pair(Ld.first+Rd.first,Ld.second+Rd.second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; query(<span class="keyword">int</span> L,<span class="keyword">int</span> R)&#123;</span><br><span class="line"><span class="built_in">std</span>::pair&lt;data,data&gt; Ds=query(<span class="number">1</span>,<span class="number">1</span>,n,L,R);</span><br><span class="line"><span class="keyword">if</span> (Ds.first.mx&gt;Ds.second.mx) <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(<span class="built_in">std</span>::make_pair(Ds.first.Lp,Ds.first.Rp),Ds.first.mx);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(<span class="built_in">std</span>::make_pair(Ds.second.Lp,Ds.second.Rp),Ds.second.mx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">addtrace(o);</span><br><span class="line"><span class="keyword">if</span> (l&gt;R||r&lt;L) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (L&lt;=l&amp;&amp;r&lt;=R)&#123;puttag(o);<span class="keyword">return</span>;&#125;</span><br><span class="line">addtrace(o&lt;&lt;<span class="number">1</span>);</span><br><span class="line">addtrace(o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">pushdown(o);</span><br><span class="line"><span class="keyword">int</span> mdl=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">modify(o&lt;&lt;<span class="number">1</span>,l,mdl,L,R);</span><br><span class="line">modify(o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mdl+<span class="number">1</span>,r,L,R);</span><br><span class="line">update(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify_single</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l==r)&#123;</span><br><span class="line">T[o].D0=data(v,v,v,v,l,l,l,l);</span><br><span class="line">T[o].D1=data(minv,minv,minv,minv,l,l,l,l);</span><br><span class="line">T[o].E0=data(minv,minv,minv,minv,l,l,l,l);</span><br><span class="line">T[o].E1=data(-v,-v,-v,-v,l,l,l,l);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">pushdown(o);</span><br><span class="line"><span class="keyword">int</span> mdl=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (k&lt;=mdl) modify_single(o&lt;&lt;<span class="number">1</span>,l,mdl,k,v);</span><br><span class="line"><span class="keyword">else</span> modify_single(o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mdl+<span class="number">1</span>,r,k,v);</span><br><span class="line">update(o);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> o,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l==r)&#123;</span><br><span class="line">T[o].D0=data(A[l],A[l],A[l],A[l],l,l,l,l);</span><br><span class="line">T[o].D1=data(minv,minv,minv,minv,l,l,l,l);</span><br><span class="line">T[o].E0=data(minv,minv,minv,minv,l,l,l,l);</span><br><span class="line">T[o].E1=data(-A[l],-A[l],-A[l],-A[l],l,l,l,l);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mdl=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">init(o&lt;&lt;<span class="number">1</span>,l,mdl);</span><br><span class="line">init(o&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mdl+<span class="number">1</span>,r);</span><br><span class="line">update(o);</span><br><span class="line">&#125;</span><br><span class="line">&#125;T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> opt,L,R,v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;A[i]);</span><br><span class="line">T.init(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Q);</span><br><span class="line"><span class="keyword">while</span> (Q--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;opt);</span><br><span class="line"><span class="keyword">if</span> (opt==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;L,&amp;v);</span><br><span class="line">T.modify_single(<span class="number">1</span>,<span class="number">1</span>,n,L,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;L,&amp;R,&amp;v);</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;v;k++)&#123;</span><br><span class="line"><span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; S=T.query(L,R);</span><br><span class="line"><span class="keyword">if</span> (S.second&lt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">ans+=S.second;</span><br><span class="line">T.modify(<span class="number">1</span>,<span class="number">1</span>,n,S.first.first,S.first.second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">T.traceback();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 做题记录 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 模拟费用流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 6584 Meteor</title>
      <link href="/2019/09/15/hdu6584/"/>
      <url>/2019/09/15/hdu6584/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>求所有$1\leq p,q\leq n$的最简分数$\frac{p}{q}$中第$k$小的</p><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先二分答案区间$[L,R]$</p><p>可以发现这些最简分数两两之差一定大于$\frac{1}{n^2}$</p><p>因此只要$R-L&lt;=\frac{1}{n^2}$，这个区间中至多只有一个数</p><p>如果可以计算出$\leq mid$的最简分数个数，就可以确定答案在$mid$左侧或右侧</p><p>考虑计算$\leq k$的最简分数个数</p><p>$$<br>\begin{align}<br>\sum_{i=1}^{n}\sum_{j=1}^{\lfloor ki\rfloor}[\gcd(i,j)=1]&amp;=\sum_{i=1}^{n}\sum_{j=1}^{\lfloor ki\rfloor}\sum_{d|i\\d|j}\mu(d) \\<br>&amp;=\sum_{d=1}^{n}\mu(d)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\lfloor ki\rfloor<br>\end{align}<br>$$</p><p>这个式子可以用整除分块+类欧几里得算法在$O(\sqrt{n}\log{n})$的时间内计算</p><p>加上外层的二分，复杂度是$O(\sqrt{n}\log^2{n})$</p><p>得到了答案所在的区间，最后可以在Stern-Brocot Tree上遍历寻找大于等于左端点的最小值</p><p>树上遍历的复杂度是$O(n)$的，在答案为$\frac{1}{n}$时取到</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> x,y,b,co,n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">calc</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b,<span class="keyword">long</span> <span class="keyword">long</span> c,<span class="keyword">long</span> <span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// \sum_&#123;i=0&#125;^&#123;n&#125;\lfloor\frac&#123;ai+b&#125;&#123;c&#125;\rfloor</span></span><br><span class="line">    <span class="keyword">if</span> (!a) <span class="keyword">return</span> b/c*(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a&gt;=c||b&gt;=c) <span class="keyword">return</span> a/c*n*(n+<span class="number">1</span>)/<span class="number">2</span>+b/c*(n+<span class="number">1</span>)+calc(a%c,b%c,c,n);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> m=a*n/c+b/c+(a*n%c+b%c&gt;=c);</span><br><span class="line">    <span class="keyword">return</span> n*m-calc(c,c-b<span class="number">-1</span>,a,m<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">calc2</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b,<span class="keyword">long</span> <span class="keyword">long</span> c,<span class="keyword">long</span> <span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) ret+=(a*i+b)/c;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mu[<span class="number">1000005</span>],prime[<span class="number">300000</span>],tot;</span><br><span class="line"><span class="keyword">bool</span> isnprime[<span class="number">1000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>]=<span class="number">1</span>,isnprime[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">1000000</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isnprime[i]) prime[++tot]=i,mu[i]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;i*prime[j]&lt;=<span class="number">1000000</span>;j++)&#123;</span><br><span class="line">            isnprime[i*prime[j]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!(i%prime[j]))&#123;</span><br><span class="line">                mu[i*prime[j]]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[i*prime[j]]=-mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">1000000</span>;i++) mu[i]+=mu[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">frac</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x,y;</span><br><span class="line">    frac()&#123;x=y=<span class="number">0</span>;&#125;</span><br><span class="line">    frac(<span class="keyword">long</span> <span class="keyword">long</span> x_,<span class="keyword">long</span> <span class="keyword">long</span> y_)&#123;x=x_,y=y_;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> frac <span class="title">combine</span><span class="params">(<span class="keyword">const</span> frac &amp;A,<span class="keyword">const</span> frac &amp;B)</span></span>&#123;<span class="keyword">return</span> frac(A.x+B.x,A.y+B.y);&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;= (<span class="keyword">const</span> frac &amp;A,<span class="keyword">const</span> frac &amp;B)&#123;<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;__int128&gt;(A.y)*B.x-<span class="keyword">static_cast</span>&lt;__int128&gt;(A.x)*B.y&gt;=<span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sieve();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">        co=n*n;</span><br><span class="line">        b=<span class="number">1</span>,x=<span class="number">0</span>,y=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (b&lt;=co)&#123;</span><br><span class="line">            x&lt;&lt;=<span class="number">1</span>,y&lt;&lt;=<span class="number">1</span>,b&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> mdl=(x+y)&gt;&gt;<span class="number">1</span>,sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> dd=n/l;</span><br><span class="line">                r=n/dd;</span><br><span class="line">                sum+=(mu[r]-mu[l<span class="number">-1</span>])*calc(mdl,<span class="number">0</span>,b,dd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum&gt;=m) y=mdl;</span><br><span class="line">            <span class="keyword">else</span> x=mdl;</span><br><span class="line">        &#125;</span><br><span class="line">        frac L(0,1),now(1,1),R(1,0),ans(1,1),g(x,b);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (g&lt;=now&amp;&amp;now&lt;=g)&#123;ans=now;<span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span> (g&lt;=now)&#123;</span><br><span class="line">                <span class="keyword">if</span> (now&lt;=ans) ans=now;</span><br><span class="line">                frac Lval=combine(L,now);</span><br><span class="line">                <span class="keyword">if</span> (Lval.y&gt;n) <span class="keyword">break</span>;</span><br><span class="line">                R=now,now=Lval;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                frac Rval=combine(now,R);</span><br><span class="line">                <span class="keyword">if</span> (Rval.y&gt;n) <span class="keyword">break</span>;</span><br><span class="line">                L=now,now=Rval;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld/%lld\n"</span>,ans.x,ans.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 做题记录 </category>
          
          <category> HDU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> 类欧几里得算法 </tag>
            
            <tag> Stern-Brocot Tree </tag>
            
            <tag> 莫比乌斯反演 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 6599 I Love Palindrome String</title>
      <link href="/2019/09/06/hdu6599/"/>
      <url>/2019/09/06/hdu6599/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定字符串$S$，对于每个长度$i$求这样的子串个数，满足：</p><ul><li>其本身是回文串</li><li>其前一半是回文串</li></ul><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先用Manacher预处理每个点为中点最长的回文子串</p><p>对给定串构建回文树</p><p>构建的同时处理出每个结点代表的回文串是否满足题目要求的性质</p><p>用到了Manacher预处理出的信息判断一个子串是否是回文串</p><p>还要在回文树上处理出每个回文串的出现次数，最后统计即可</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> S[<span class="number">700000</span>],T[<span class="number">700000</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> pal[<span class="number">700000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manacher</span><span class="params">()</span></span>&#123;</span><br><span class="line">pal[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> id=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n+n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (i&lt;=id+pal[id]) pal[i]=<span class="built_in">std</span>::min(pal[id+id-i],id+pal[id]-i);</span><br><span class="line"><span class="keyword">while</span> (T[i+pal[i]+<span class="number">1</span>]==T[i-pal[i]<span class="number">-1</span>]) pal[i]++;</span><br><span class="line"><span class="keyword">if</span> (i+pal[i]&gt;id+pal[id]) id=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ispalindrome</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;<span class="keyword">return</span> pal[L+R+<span class="number">2</span>]&gt;=R-L;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PAM</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> son[<span class="number">26</span>],link,len,sum;</span><br><span class="line"><span class="keyword">bool</span> isp;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;<span class="built_in">memset</span>(son,<span class="number">0</span>,<span class="keyword">sizeof</span>(son)),link=len=sum=<span class="number">0</span>,isp=<span class="literal">false</span>;&#125;</span><br><span class="line">node()&#123;clear();&#125;</span><br><span class="line">&#125;T[<span class="number">400000</span>];</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *S)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> L=<span class="built_in">strlen</span>(S),now=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;L;i++)&#123;</span><br><span class="line"><span class="keyword">while</span> (S[i]!=S[i-T[now].len<span class="number">-1</span>]) now=T[now].link;</span><br><span class="line"><span class="keyword">if</span> (!T[now].son[S[i]-<span class="string">'a'</span>])&#123;</span><br><span class="line">tot++;</span><br><span class="line">T[tot].len=T[now].len+<span class="number">2</span>;</span><br><span class="line">T[tot].link=T[now].link;</span><br><span class="line"><span class="keyword">while</span> (S[i]!=S[i-T[T[tot].link].len<span class="number">-1</span>]) T[tot].link=T[T[tot].link].link;</span><br><span class="line">T[tot].link=T[T[tot].link].son[S[i]-<span class="string">'a'</span>];</span><br><span class="line">now=T[now].son[S[i]-<span class="string">'a'</span>]=tot;</span><br><span class="line">T[now].isp=ispalindrome(((<span class="number">2</span>*i-T[now].len)&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> now=T[now].son[S[i]-<span class="string">'a'</span>];</span><br><span class="line">T[now].sum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span>&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i=tot;i;i--) T[T[i].link].sum+=T[i].sum;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=tot;i++) T[i].clear();</span><br><span class="line">tot=<span class="number">1</span>,T[<span class="number">0</span>].link=<span class="number">1</span>,T[<span class="number">1</span>].len=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">PAM()&#123;tot=<span class="number">1</span>,T[<span class="number">0</span>].link=<span class="number">1</span>,T[<span class="number">1</span>].len=<span class="number">-1</span>;&#125;</span><br><span class="line">&#125;P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">500000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%s"</span>,S+<span class="number">1</span>))&#123;</span><br><span class="line">n=<span class="built_in">strlen</span>(S+<span class="number">1</span>);</span><br><span class="line">T[<span class="number">0</span>]=<span class="string">'$'</span>;</span><br><span class="line">T[<span class="number">1</span>]=<span class="string">'#'</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(T+<span class="number">1</span>,S+<span class="number">1</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*(n+<span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=n;i;i--) T[i+i+<span class="number">1</span>]=<span class="string">'#'</span>,T[i+i]=S[i];</span><br><span class="line">Manacher();</span><br><span class="line">P.insert(S+<span class="number">1</span>);</span><br><span class="line">P.prepare();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=P.tot;i++) <span class="keyword">if</span> (P.T[i].isp) ans[P.T[i].len]+=P.T[i].sum;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d%c"</span>,ans[i],<span class="string">" \n"</span>[i==n]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// clear</span></span><br><span class="line">P.clear();</span><br><span class="line"><span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line"><span class="built_in">memset</span>(pal,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+n+<span class="number">5</span>));</span><br><span class="line"><span class="built_in">memset</span>(T,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*(n+n+<span class="number">5</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 做题记录 </category>
          
          <category> HDU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回文树 </tag>
            
            <tag> Manacher </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 6607 Easy Math Problem</title>
      <link href="/2019/08/30/hdu6607/"/>
      <url>/2019/08/30/hdu6607/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>求</p><p>$$ \sum_{i=1}^{n}\sum_{j=1}^{n}\gcd(i,j)^k\textrm{lcm}(i,j)[\gcd(i,j)\in\mathbb{P}] $$</p><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>推式子</p><p>$$<br>\begin{align}<br>Ans\nonumber<br>&amp;=\sum_{i=1}^{n}\sum_{j=1}^{n}\gcd(i,j)^k\textrm{lcm}(i,j)[\gcd(i,j)\in\mathbb{P}] \\\nonumber<br>&amp;=\sum_{i=1}^{n}\sum_{j=1}^{n}ij\gcd(i,j)^{k-1}[\gcd(i,j)\in\mathbb{P}] \\\nonumber<br>&amp;=\sum_{p\in\mathbb{P}}\sum_{i=1}^{n}\sum_{j=1}^{n}ijp^{k-1}[\gcd(i,j)=p] \\\nonumber<br>&amp;=\sum_{p\in\mathbb{P}}p^{k-1}\sum_{i=1}^{\lfloor\frac{n}{p}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{p}\rfloor}ip\cdot jp[\gcd(i,j)=1] \\\nonumber<br>&amp;=\sum_{p\in\mathbb{P}}p^{k+1}\sum_{i=1}^{\lfloor\frac{n}{p}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{p}\rfloor}ij[\gcd(i,j)=1] \\\nonumber<br>&amp;=\sum_{p\in\mathbb{P}}p^{k+1}\sum_{i=1}^{\lfloor\frac{n}{p}\rfloor}i^2\varphi(i) \\\nonumber<br>&amp;=\sum_{i=1}^{n}i^2\varphi(i)\sum_{\begin{array}{c}p\in\mathbb{P} \\ p\leq\lfloor\frac{n}{i}\rfloor\end{array}}p^{k+1} \nonumber<br>\end{align}<br>$$</p><p>到此为止，就可以用杜教筛处理$i^2\varphi(i)$的前缀和，以及素数处点值的那套理论处理$p^{k+1}$的部分和</p><p>关于杜教筛处理，令$F(n)=n^2\varphi(n),G(n)=n^2$，则有$F*G(n)=n^3$</p><p>最后套一个整除分块就做完了</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sqrtn,T,k;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,V[<span class="number">300000</span>];</span><br><span class="line"><span class="keyword">int</span> vtot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1000000007</span>,inv6=<span class="number">166666668</span>,inv4=<span class="number">250000002</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">5000000</span>],ptot,foo[<span class="number">5000000</span>];</span><br><span class="line"><span class="keyword">bool</span> isnprime[<span class="number">5000000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span></span>&#123;</span><br><span class="line">isnprime[<span class="number">1</span>]=<span class="literal">true</span>,foo[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">4900000</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (!isnprime[i]) prime[++ptot]=i,foo[i]=i<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;i*prime[j]&lt;=<span class="number">4900000</span>;j++)&#123;</span><br><span class="line">isnprime[i*prime[j]]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (!(i%prime[j]))&#123;</span><br><span class="line">foo[i*prime[j]]=foo[i]*prime[j];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo[i*prime[j]]=foo[i]*(prime[j]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">4900000</span>;i++) foo[i]=(foo[i<span class="number">-1</span>]+i*<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(i)%mod*foo[i])%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Array</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> S[<span class="number">200000</span>],T[<span class="number">200000</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> &amp; <span class="keyword">operator</span> [] (<span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> idx)&#123;<span class="keyword">return</span> idx&lt;=sqrtn?S[idx]:T[n/idx];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> cl)</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(S,cl,<span class="keyword">sizeof</span>(S));</span><br><span class="line"><span class="built_in">memset</span>(T,cl,<span class="keyword">sizeof</span>(T));</span><br><span class="line">&#125;</span><br><span class="line">Array()&#123;clear(<span class="number">0x00</span>);&#125;</span><br><span class="line">&#125;G,F;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sig2</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span></span>&#123;<span class="keyword">return</span> n%=mod,n*(n+<span class="number">1L</span>L)%mod*(<span class="number">2L</span>L*n+<span class="number">1L</span>L)%mod*inv6%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sig3</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span></span>&#123;<span class="keyword">return</span> n%=mod,n*(n+<span class="number">1L</span>L)%mod*n%mod*(n+<span class="number">1L</span>L)%mod*inv4%mod;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line">a%=mod;</span><br><span class="line"><span class="keyword">for</span> (;b;b&gt;&gt;=<span class="number">1</span>,a=a*<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(a)%mod) <span class="keyword">if</span> (b&amp;<span class="number">1</span>) ret=ret*<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(a)%mod;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Lagrange</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> *B,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> F[n+<span class="number">2</span>],tmp[n+<span class="number">2</span>];</span><br><span class="line"><span class="built_in">memset</span>(F,<span class="number">0</span>,<span class="keyword">sizeof</span>(F));</span><br><span class="line">F[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=i;~j;j--) F[j+<span class="number">1</span>]=F[j];</span><br><span class="line">F[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++) F[j]=(F[j]-i*<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(F[j+<span class="number">1</span>])%mod+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(B,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> mul=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (i==j) <span class="keyword">continue</span>;</span><br><span class="line">mul=mul*<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(i-j+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line">mul=<span class="built_in">pow</span>(mul,mod<span class="number">-2</span>);</span><br><span class="line">mul=mul*<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(A[i])%mod;</span><br><span class="line"><span class="built_in">memcpy</span>(tmp,F,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=n;~j;j--)&#123;</span><br><span class="line">B[j]=(B[j]+<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(tmp[j+<span class="number">1</span>])*mul)%mod;</span><br><span class="line">tmp[j]=(tmp[j]+<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(tmp[j+<span class="number">1</span>])*i)%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> X[<span class="number">200</span>],Y[<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// min-25</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;prime[i]*<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(prime[i])&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=vtot;j&amp;&amp;prime[i]*<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(prime[i])&lt;=V[j];j--)</span><br><span class="line">F[V[j]]=(F[V[j]]-<span class="built_in">pow</span>(prime[i],k+<span class="number">1</span>)*<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(F[V[j]/prime[i]]-F[prime[i]<span class="number">-1</span>]+mod)%mod+mod)%mod;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dujiao</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> part=<span class="built_in">pow</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(n),<span class="number">2.</span>/<span class="number">3</span>);</span><br><span class="line"><span class="keyword">int</span> it;</span><br><span class="line"><span class="keyword">for</span> (it=<span class="number">1</span>;V[it]&lt;=part;it++) G[V[it]]=foo[V[it]];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=it;i&lt;=vtot;i++)&#123;</span><br><span class="line">G[V[i]]=sig3(V[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> l=<span class="number">2</span>,r;l&lt;=V[i];l=r+<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> divd=V[i]/l;</span><br><span class="line">r=V[i]/divd;</span><br><span class="line">G[V[i]]=(G[V[i]]-(sig2(r)-sig2(l<span class="number">-1</span>)+mod)*<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(G[divd])%mod+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">sieve();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span> (T--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%d"</span>,&amp;n,&amp;k);</span><br><span class="line">sqrtn=sqrtl(n)+<span class="number">1e-10</span>;</span><br><span class="line">vtot=<span class="number">0</span>,G.clear(<span class="number">0x00</span>),F.clear(<span class="number">0x00</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> l=<span class="number">1</span>;l&lt;=n;l=(n/(n/l))+<span class="number">1</span>) V[++vtot]=n/l;</span><br><span class="line"><span class="built_in">std</span>::reverse(V+<span class="number">1</span>,V+vtot+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k+<span class="number">2</span>;i++) X[i]=(X[i<span class="number">-1</span>]+<span class="built_in">pow</span>(i,k+<span class="number">1</span>))%mod;</span><br><span class="line">Lagrange(X,Y,k+<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=vtot;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> dv=V[i]%mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=k+<span class="number">2</span>;~j;j--) F[V[i]]=(F[V[i]]*<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(dv)%mod+Y[j])%mod;</span><br><span class="line">F[V[i]]=(F[V[i]]<span class="number">-1</span>+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line">init();</span><br><span class="line">ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> divd=n/l;</span><br><span class="line">r=n/divd;</span><br><span class="line">ans=(ans+F[divd]*<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(G[r]-G[l<span class="number">-1</span>]+mod))%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 做题记录 </category>
          
          <category> HDU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杜教筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 6694 Play Games with Rounddog</title>
      <link href="/2019/08/30/hdu6694/"/>
      <url>/2019/08/30/hdu6694/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定串$S$，和正整数数组$W$</p><p>每次询问$S$的一个子串$S[L:R]$，在所有以$S[L:R]$为后缀的不同子串中，选出若干作为${T_i}$，使得$W_{T_i的出现次数}$线性无关且和最大</p><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>以$S[L:R]$为后缀，就是在反串的后缀树上$S_R[L:R]$对应的结点的子树</p><p>后缀树上一个结点代表的一些字符串出现次数相同，也就是$endpos$集合的大小，可以用后缀自动机处理</p><p>对于和最大的线性无关组，可以参考<a href="https://www.luogu.org/problem/P4301" target="_blank" rel="noopener">[CQOI2013]新Nim游戏</a>的做法（线性基+贪心）</p><p>用后缀自动机建出后缀树后，在后缀树上预处理出子树中所有$W_{|endpos|}$的和最大的线性基，可以使用线性基合并</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T,n,m;</span><br><span class="line"><span class="keyword">char</span> S[<span class="number">105000</span>];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> W[<span class="number">105000</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SAM</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> son[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">int</span> len,link,sz;</span><br><span class="line">node()&#123;</span><br><span class="line"><span class="built_in">memset</span>(son,<span class="number">0xff</span>,<span class="keyword">sizeof</span>(son));</span><br><span class="line">len=link=sz=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;T[<span class="number">200500</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lst,tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> C)</span></span>&#123;</span><br><span class="line">C-=<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">int</span> q=++tot,p=lst;</span><br><span class="line">lst=q,T[q].len=T[p].len+<span class="number">1</span>,T[q].sz=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (~p&amp;&amp;!~T[p].son[C]) T[p].son[C]=q,p=T[p].link;</span><br><span class="line"><span class="keyword">if</span> (!~p) <span class="keyword">return</span> q;</span><br><span class="line"><span class="keyword">int</span> np=T[p].son[C];</span><br><span class="line"><span class="keyword">if</span> (T[p].len+<span class="number">1</span>==T[np].len) T[q].link=np;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> nq=++tot;</span><br><span class="line"><span class="built_in">memcpy</span>(T[nq].son,T[np].son,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">26</span>);</span><br><span class="line">T[nq].len=T[p].len+<span class="number">1</span>;</span><br><span class="line">T[nq].link=T[np].link;</span><br><span class="line">T[q].link=T[np].link=nq;</span><br><span class="line"><span class="keyword">while</span> (~p&amp;&amp;T[p].son[C]==np) T[p].son[C]=nq,p=T[p].link;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=tot;i++) T[i]=node();</span><br><span class="line">T[<span class="number">0</span>].link=<span class="number">-1</span>;</span><br><span class="line">lst=tot=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">SAM()&#123;</span><br><span class="line">lst=tot=<span class="number">0</span>;</span><br><span class="line">T[<span class="number">0</span>].link=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;G;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> id[<span class="number">105000</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> to,nxt;&#125;E[<span class="number">200500</span>];</span><br><span class="line"><span class="keyword">int</span> H[<span class="number">200500</span>],tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;E[++tot]=(edge)&#123;b,H[a]&#125;,H[a]=tot;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Basis</span>&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> B[<span class="number">58</span>],origin[<span class="number">58</span>],sum;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> W)</span></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> tmp=W;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">57</span>;~i;i--)&#123;</span><br><span class="line"><span class="keyword">if</span> (W&gt;&gt;i&amp;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (!B[i])&#123;B[i]=W,origin[i]=tmp,sum+=tmp;<span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">else</span> W^=B[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(B,<span class="number">0</span>,<span class="keyword">sizeof</span>(B));</span><br><span class="line"><span class="built_in">memset</span>(origin,<span class="number">0</span>,<span class="keyword">sizeof</span>(origin));</span><br><span class="line">sum=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Basis()&#123;clear();&#125;</span><br><span class="line">&#125;D[<span class="number">200500</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">Basis <span class="title">merge</span><span class="params">(<span class="keyword">const</span> Basis &amp;A,<span class="keyword">const</span> Basis &amp;B)</span></span>&#123;</span><br><span class="line">Basis ret;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> tmp[<span class="number">116</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(tmp,A.origin,<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)*<span class="number">58</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(tmp+<span class="number">58</span>,B.origin,<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)*<span class="number">58</span>);</span><br><span class="line"><span class="built_in">std</span>::sort(tmp,tmp+<span class="number">116</span>,<span class="built_in">std</span>::greater&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">116</span>;i++) ret.insert(tmp[i]);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> jmp[<span class="number">200500</span>][<span class="number">19</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prework1</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">jmp[now][<span class="number">0</span>]=G.T[now].link;</span><br><span class="line"><span class="keyword">if</span> (!now) jmp[now][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">18</span>;i++) jmp[now][i]=jmp[jmp[now][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=H[now];i;i=E[i].nxt)&#123;</span><br><span class="line">prework1(E[i].to);</span><br><span class="line">G.T[now].sz+=G.T[E[i].to].sz;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prework2</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=H[now];i;i=E[i].nxt)</span><br><span class="line">prework2(E[i].to),D[now]=merge(D[now],D[E[i].to]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">18</span>;~i;i--) <span class="keyword">if</span> (G.T[jmp[now][i]].len&gt;=len) now=jmp[now][i];</span><br><span class="line"><span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span> (T--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,S+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%llu"</span>,&amp;W[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) id[i]=G.insert(S[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=G.tot;i++) add_edge(G.T[i].link,i);</span><br><span class="line">prework1(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=G.tot;i++) D[i].insert(W[G.T[i].sz]);</span><br><span class="line">prework2(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,L,R;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;L,&amp;R);</span><br><span class="line"><span class="keyword">int</span> J=jump(id[R],R-L+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%llu\n"</span>,D[J].sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// clearing</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=G.tot;i++) D[i].clear();</span><br><span class="line"><span class="built_in">memset</span>(E,<span class="number">0</span>,<span class="keyword">sizeof</span>(edge)*(tot+<span class="number">1</span>));</span><br><span class="line"><span class="built_in">memset</span>(H,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(G.tot+<span class="number">1</span>));</span><br><span class="line">tot=<span class="number">0</span>;</span><br><span class="line">G.clear();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 做题记录 </category>
          
          <category> HDU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性基 </tag>
            
            <tag> 后缀自动机 </tag>
            
            <tag> 后缀树 </tag>
            
            <tag> 倍增 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 53E Dead Ends</title>
      <link href="/2019/08/03/cf53e/"/>
      <url>/2019/08/03/cf53e/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出$n$个点的无向图，求恰好$k$个叶子的生成树个数</p><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先提一句，Codeforces Tutorial给出了一种状态数是$2^n*2^n$的一种dp，复杂度较劣</p><p>这里考虑使用容斥</p><p>令$F_S$表示钦定$S$集合中的点是叶子节点（没被钦定到的点可能有叶子节点）的生成树个数</p><p>令$G_S$表示只有$S$集合中的点是叶子节点的生成树个数</p><p>答案就是$\sum_{|S|=k}{G_S}$</p><p>可以得到$F$和$G$的关系</p><p>$$ F_S=\sum_{T\supseteq S}{G_T} $$</p><p>如果用$\overline{S}$表示$S$的补集，那么</p><p>$$ F_\overline{S}=\sum_{\overline{T}\subseteq \overline{S}}{G_\overline{T}} $$</p><p>这就是莫比乌斯变换的形式，如果可以得到$F$，就可以进行莫比乌斯反演得到$G$</p><p>$$ G_\overline{S}=\sum_{\overline{T}\subseteq \overline{S}}{(-1)^{|\overline{S}|-|\overline{T}|}F_\overline{T}} $$</p><p>为了得到$F_S$，可以先用矩阵树定理求$\overline{S}$的导出子图的生成树个数，再乘把每个被钦定的叶子接到生成树上的方案</p><p>总时间复杂度$O(2^n*n^3)$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> E[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> M[<span class="number">10</span>][<span class="number">10</span>],ful,id[<span class="number">10</span>],di[<span class="number">10</span>],top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (;b;b&gt;&gt;=<span class="number">1</span>,a=a*<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(a)%mod) <span class="keyword">if</span> (b&amp;<span class="number">1</span>) ret=ret*<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(a)%mod;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Gauss</span><span class="params">(<span class="keyword">int</span> B)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> H=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;B;i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (!M[i][i])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=i;j&lt;B;j++)</span><br><span class="line"><span class="keyword">if</span> (M[j][i]) <span class="built_in">std</span>::swap(M[i],M[j]),H=mod-H;</span><br><span class="line">H=H*<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(M[i][i])%mod;</span><br><span class="line"><span class="keyword">int</span> inv=<span class="built_in">pow</span>(M[i][i],mod<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=i;j&lt;B;j++) M[i][j]=M[i][j]*<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(inv)%mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;B;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> G=M[j][i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=i;k&lt;B;k++)</span><br><span class="line">M[j][k]=(M[j][k]-M[i][k]*<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(G)%mod+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;B;i++) H=H*<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(M[i][i])%mod;</span><br><span class="line"><span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> S)</span></span>&#123;</span><br><span class="line">top=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span> (S&gt;&gt;i&amp;<span class="number">1</span>) di[id[i]=top++]=i;</span><br><span class="line"><span class="built_in">memset</span>(M,<span class="number">0</span>,<span class="keyword">sizeof</span>(M));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;top;i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;top;j++)</span><br><span class="line"><span class="keyword">if</span> (E[di[i]][di[j]]) M[i][i]++,M[i][j]=mod<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> G=Gauss(top<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (!(S&gt;&gt;i&amp;<span class="number">1</span>))&#123;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;top;j++) cnt+=E[i][di[j]];</span><br><span class="line">G=G*<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(cnt)%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> G;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> V[<span class="number">1</span>&lt;&lt;<span class="number">10</span>],ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FMT</span><span class="params">(<span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;L;i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;L);j++)</span><br><span class="line"><span class="keyword">if</span> (j&gt;&gt;i&amp;<span class="number">1</span>) V[j]=(V[j]-V[j^(<span class="number">1</span>&lt;&lt;i)]+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">ful=(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y),x--,y--,E[x][y]=E[y][x]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++) V[i]=calc(i);</span><br><span class="line">FMT(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++) <span class="keyword">if</span> (__builtin_popcount(i)==n-k) ans=(ans+V[i])%mod;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 做题记录 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容斥 </tag>
            
            <tag> 快速莫比乌斯变换（反演） </tag>
            
            <tag> 矩阵树定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 700E Cool Slogans</title>
      <link href="/2019/08/02/cf700e/"/>
      <url>/2019/08/02/cf700e/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定母串$S$</p><p>要求一个字符串列表$T$，满足$T$中元素都是$S$的子串，且$T_i$在$T_{i+1}$中出现至少$2$次</p><p>问列表最长长度</p><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>对母串建出后缀自动机</p><p>每次选择列表的下一个元素，一定可以在parent树上对应结点的子树中选择</p><p>因为parent树的子树对应的字符串都以该串为后缀</p><p>可以写成dp的形式，令$F_i$表示$i$号结点代表的字符串前最多可以接多少字符串</p><p>最终要求的就是dp的最大值</p><p>接下来考虑，如何判断$x$的某个祖先$y$对应的字符串是否在$x$对应的字符串中出现至少两次</p><p>由于在parent树上，所以一定作为后缀出现了一次</p><p>另外一次只要利用$endpos_y$判断是否作为$x$对应字符串的非后缀子串即可</p><p>endpos可以用线段树合并预处理，dp时注意转移点的处理</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> S[<span class="number">300000</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> to,nxt;&#125;E[<span class="number">500000</span>];</span><br><span class="line"><span class="keyword">int</span> H[<span class="number">500000</span>],tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;E[++tot]=(edge)&#123;b,H[a]&#125;,H[a]=tot;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">node *L,*R;</span><br><span class="line">node()&#123;L=R=<span class="literal">NULL</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">node *root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node *&amp;now,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!now) now=<span class="keyword">new</span> node;</span><br><span class="line"><span class="keyword">if</span> (l==r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mdl=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (k&lt;=mdl) insert(now-&gt;L,l,mdl,k);</span><br><span class="line"><span class="keyword">else</span> insert(now-&gt;R,mdl+<span class="number">1</span>,r,k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">query</span><span class="params">(node *now,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l&gt;R||r&lt;L||!now) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (L&lt;=l&amp;&amp;r&lt;=R) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> mdl=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> query(now-&gt;L,l,mdl,L,R)|query(now-&gt;R,mdl+<span class="number">1</span>,r,L,R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SegmentTree()&#123;root=<span class="literal">NULL</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SegmentTree::<span class="function">node * <span class="title">merge</span><span class="params">(SegmentTree::node *&amp;A,SegmentTree::node *&amp;B)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!(A&amp;&amp;B)) <span class="keyword">return</span> A?A:B;</span><br><span class="line">SegmentTree::node *nw=<span class="keyword">new</span> SegmentTree::node;</span><br><span class="line">nw-&gt;L=merge(A-&gt;L,B-&gt;L),nw-&gt;R=merge(A-&gt;R,B-&gt;R);</span><br><span class="line"><span class="keyword">return</span> nw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SAM</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> son[<span class="number">26</span>],len,link,R;</span><br><span class="line">SegmentTree S;</span><br><span class="line">node()&#123;</span><br><span class="line"><span class="built_in">memset</span>(son,<span class="number">0xff</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">26</span>);</span><br><span class="line">len=link=R=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;T[<span class="number">500000</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot,lst;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> C)</span></span>&#123;</span><br><span class="line">C-=<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">int</span> q=++tot,p=lst;</span><br><span class="line">T[q].len=T[p].len+<span class="number">1</span>,T[q].S.insert(T[q].S.root,<span class="number">1</span>,n,T[q].R=T[q].len);</span><br><span class="line">lst=q;</span><br><span class="line"><span class="keyword">while</span> (~p&amp;&amp;!~T[p].son[C]) T[p].son[C]=q,p=T[p].link;</span><br><span class="line"><span class="keyword">if</span> (!~p) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> np=T[p].son[C];</span><br><span class="line"><span class="keyword">if</span> (T[p].len+<span class="number">1</span>==T[np].len) T[q].link=np;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> nq=++tot;</span><br><span class="line"><span class="built_in">memcpy</span>(T[nq].son,T[np].son,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">26</span>);</span><br><span class="line">T[nq].link=T[np].link;</span><br><span class="line">T[nq].len=T[p].len+<span class="number">1</span>;</span><br><span class="line">T[np].link=T[q].link=nq;</span><br><span class="line"><span class="keyword">while</span> (~p&amp;&amp;T[p].son[C]==np) T[p].son[C]=nq,p=T[p].link;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SAM()&#123;tot=lst=<span class="number">0</span>,T[<span class="number">0</span>].link=<span class="number">-1</span>;&#125;</span><br><span class="line">&#125;G;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=H[now];i;i=E[i].nxt)&#123;</span><br><span class="line">pre(E[i].to);</span><br><span class="line">G.T[now].R=<span class="built_in">std</span>::max(G.T[now].R,G.T[E[i].to].R);</span><br><span class="line">G.T[now].S.root=merge(G.T[now].S.root,G.T[E[i].to].S.root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> ans,<span class="keyword">int</span> top)</span></span>&#123;</span><br><span class="line">Ans=<span class="built_in">std</span>::max(Ans,ans);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=H[now];i;i=E[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span> (G.T[top].S.query(G.T[top].S.root,<span class="number">1</span>,n,G.T[E[i].to].R-G.T[E[i].to].len+G.T[top].len,G.T[E[i].to].R<span class="number">-1</span>)) solve(E[i].to,ans+<span class="number">1</span>,E[i].to);</span><br><span class="line"><span class="keyword">else</span> solve(E[i].to,ans,top);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%s"</span>,&amp;n,S+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (n==<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"1"</span>),<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) G.insert(S[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=G.tot;i++) add_edge(G.T[i].link,i);</span><br><span class="line">pre(<span class="number">0</span>),solve(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 做题记录 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后缀自动机 </tag>
            
            <tag> 线段树合并 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[HEOI2016/TJOI2016]字符串</title>
      <link href="/2019/08/01/luogu4094/"/>
      <url>/2019/08/01/luogu4094/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定字符串$S$，多次询问$S[a:b]$的子串和$S[c:d]$的最长公共前缀的最大值</p><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>后缀自动机不方便处理前缀，首先反转$S$，转化为询问后缀</p><p>一个容易发现的事实是，如果最长公共前缀长度为$L$，那么一定存在$0\sim L-1$的每一种答案</p><p>由于后缀自动机上每个结点的$endpos$集合是$parent$树上儿子$endpos$的并，可以用线段树合并预处理出来</p><p>每次询问，因为反转了串，先转换读入的区间</p><p>二分答案$Ans$，转化为$S[d-Ans+1:d]$是否是$S[a:b]$的子串，判定性问题</p><p>令转换后的询问为$a,b,c,d$，在前缀串$S[1:d]$所在结点到根的链上，利用维护的$len$值倍增找到$S[d-Ans+1:d]$所在的结点（$Ans=0$即为$\varnothing$串）</p><p>如果$S[a:b]$中存在串$S[d-Ans+1:d]$，则意味着所在结点的$endpos$集合中存在$(a+Ans,b]$中的某个值</p><p>如果不存在则减小二分的答案</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> S[<span class="number">300000</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> to,nxt;&#125;E[<span class="number">300000</span>];</span><br><span class="line"><span class="keyword">int</span> H[<span class="number">300000</span>],tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;E[++tot]=(edge)&#123;b,H[a]&#125;,H[a]=tot;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">node *L,*R;</span><br><span class="line">node()&#123;L=R=<span class="literal">NULL</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">node *root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node *&amp;now,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!now) now=<span class="keyword">new</span> node;</span><br><span class="line"><span class="keyword">if</span> (l==r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mdl=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (v&lt;=mdl) insert(now-&gt;L,l,mdl,v);</span><br><span class="line"><span class="keyword">else</span> insert(now-&gt;R,mdl+<span class="number">1</span>,r,v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">query</span><span class="params">(node *now,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l&gt;R||r&lt;L||!now) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (L&lt;=l&amp;&amp;r&lt;=R) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> mdl=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> query(now-&gt;L,l,mdl,L,R)|query(now-&gt;R,mdl+<span class="number">1</span>,r,L,R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SegmentTree()&#123;root=<span class="literal">NULL</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SegmentTree::<span class="function">node * <span class="title">merge</span><span class="params">(SegmentTree::node *&amp;A,SegmentTree::node *&amp;B)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!(A&amp;&amp;B)) <span class="keyword">return</span> A?A:B;</span><br><span class="line">SegmentTree::node *nw=<span class="keyword">new</span> SegmentTree::node;</span><br><span class="line">nw-&gt;L=merge(A-&gt;L,B-&gt;L);</span><br><span class="line">nw-&gt;R=merge(A-&gt;R,B-&gt;R);</span><br><span class="line"><span class="keyword">return</span> nw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SAM</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> son[<span class="number">26</span>],len,link;</span><br><span class="line">SegmentTree S;</span><br><span class="line">node()&#123;</span><br><span class="line"><span class="built_in">memset</span>(son,<span class="number">0xff</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">26</span>);</span><br><span class="line">len=link=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;T[<span class="number">300000</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot,lst,f;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> C)</span></span>&#123;</span><br><span class="line">C-=<span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">int</span> q=++tot,p=lst;</span><br><span class="line">lst=q,f++;</span><br><span class="line">T[q].S.insert(T[q].S.root,<span class="number">1</span>,n,f);</span><br><span class="line">T[q].len=T[p].len+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (~p&amp;&amp;!~T[p].son[C]) T[p].son[C]=q,p=T[p].link;</span><br><span class="line"><span class="keyword">if</span> (!~p) <span class="keyword">return</span> q;</span><br><span class="line"><span class="keyword">int</span> np=T[p].son[C];</span><br><span class="line"><span class="keyword">if</span> (T[p].len+<span class="number">1</span>==T[np].len) T[q].link=np;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> nq=++tot;</span><br><span class="line"><span class="built_in">memcpy</span>(T[nq].son,T[np].son,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">26</span>);</span><br><span class="line">T[nq].len=T[p].len+<span class="number">1</span>;</span><br><span class="line">T[nq].link=T[np].link;</span><br><span class="line">T[q].link=T[np].link=nq;</span><br><span class="line"><span class="keyword">while</span> (~p&amp;&amp;T[p].son[C]==np) T[p].son[C]=nq,p=T[p].link;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SAM()&#123;tot=lst=<span class="number">0</span>,T[<span class="number">0</span>].link=<span class="number">-1</span>;&#125;</span><br><span class="line">&#125;G;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Fa[<span class="number">300000</span>][<span class="number">19</span>],B[<span class="number">300000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=H[now];i;i=E[i].nxt)&#123;</span><br><span class="line">Fa[E[i].to][<span class="number">0</span>]=now;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;<span class="number">19</span>;j++) Fa[E[i].to][j]=Fa[Fa[E[i].to][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">pre(E[i].to);</span><br><span class="line">G.T[now].S.root=merge(G.T[now].S.root,G.T[E[i].to].S.root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">18</span>;~i;i--) <span class="keyword">if</span> (G.T[Fa[now][i]].len&gt;=len) now=Fa[now][i];</span><br><span class="line"><span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a,b,c,d;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,S);</span><br><span class="line"><span class="built_in">std</span>::reverse(S,S+n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) B[i+<span class="number">1</span>]=G.insert(S[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=G.tot;i++) add_edge(G.T[i].link,i);</span><br><span class="line">pre(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span> (m--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;b,&amp;a,&amp;d,&amp;c);</span><br><span class="line">a=n-a+<span class="number">1</span>,b=n-b+<span class="number">1</span>,c=n-c+<span class="number">1</span>,d=n-d+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> L=<span class="number">0</span>,R=<span class="built_in">std</span>::min(d-c+<span class="number">1</span>,b-a+<span class="number">1</span>),mdl;</span><br><span class="line"><span class="keyword">while</span> (L&lt;R)&#123;</span><br><span class="line">mdl=(L+R+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> id=jump(B[d],mdl);</span><br><span class="line"><span class="keyword">if</span> (G.T[id].S.query(G.T[id].S.root,<span class="number">1</span>,n,a+mdl<span class="number">-1</span>,b)) L=mdl;</span><br><span class="line"><span class="keyword">else</span> R=mdl<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,L);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 做题记录 </category>
          
          <category> 洛谷 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后缀自动机 </tag>
            
            <tag> 线段树合并 </tag>
            
            <tag> 倍增 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hihoCoder 1193 树堆</title>
      <link href="/2019/07/25/hiho1193/"/>
      <url>/2019/07/25/hiho1193/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定$n$个结点的带权有根树</p><p>可以进行多次操作，每次删去一个结点，并把它的所有孩子直接接到它的父亲上</p><p>要求若干次操作后形成的有根树是一个树堆</p><p>对每个结点询问它的子树最大能形成多大的树堆</p><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>先考虑一个朴素的dp</p><p>令$F_{i,v}$表示在$i$号结点所在的子树中，所有点的点权均不大于$v$，最大能形成多大的树堆（或者说是树堆森林，可以在最顶端接一个点将森林连成树）</p><p>有一个显然的事实是，$F_{i,v}$是随$v$增加单调不降的，因为限制的点权越大，限制越松</p><p>设当前点权为$w_i$</p><p>当$v&lt;w_i$时，当前点不能被选择，只能直接转移</p><p>$$ F_{i,v}=\sum_{u\in i.son}{F_{u,v}} $$</p><p>当$v\geq w_i$时，可以选择当前点（同时也将森林连成了树）</p><p>$$ F_{i,v}=\sum_{u\in i.son}{\max(F_{u,v},F_{i,w_i}+1)} $$</p><p>事实上，这个转移可以被看做先全部当成第一个转移，再将下标大于$w_i$的对$F_{i,w_i}+1$取$\max$</p><p>当成第一种转移合并的时候可以考虑用线段树合并解决</p><p>但是线段树合并不太支持维护区间对某个数取$\max$</p><p>因此利用$F$的单调性优化</p><p>因为每次只对$F_{i,w_i}+1$取$\max$，所以影响到的只会是值等于$F_{i,w_i}$的那一段</p><p>在线段树上二分找到最右的值等于$F_{i,w_i}$的位置</p><p>然后给这段区间$+1$即可，把区间取$\max$转化为了区间加，就可以用线段树合并维护了</p><p>时间复杂度$O(n\log n)$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">node *L,*R;</span><br><span class="line"><span class="keyword">int</span> tag,rst;</span><br><span class="line">node()&#123;L=R=<span class="literal">NULL</span>,tag=rst=<span class="number">0</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">puttag</span><span class="params">(node *now,<span class="keyword">int</span> v)</span></span>&#123;now-&gt;tag+=v,now-&gt;rst+=v;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(node *now)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!now-&gt;L) now-&gt;L=<span class="keyword">new</span> node;</span><br><span class="line"><span class="keyword">if</span> (!now-&gt;R) now-&gt;R=<span class="keyword">new</span> node;</span><br><span class="line">puttag(now-&gt;L,now-&gt;tag),puttag(now-&gt;R,now-&gt;tag);</span><br><span class="line">now-&gt;tag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(node *now)</span></span>&#123;now-&gt;rst=now-&gt;R-&gt;rst;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span>&#123;</span></span><br><span class="line">node *root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(node *&amp;o,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l&gt;R||r&lt;L) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (!o) o=<span class="keyword">new</span> node;</span><br><span class="line"><span class="keyword">if</span> (L&lt;=l&amp;&amp;r&lt;=R) puttag(o,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">pushdown(o);</span><br><span class="line"><span class="keyword">int</span> mdl=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">modify(o-&gt;L,l,mdl,L,R),modify(o-&gt;R,mdl+<span class="number">1</span>,r,L,R);</span><br><span class="line">update(o);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(node *o,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l==r) <span class="keyword">return</span> o-&gt;rst;</span><br><span class="line">pushdown(o);</span><br><span class="line"><span class="keyword">int</span> mdl=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (k&lt;=mdl) <span class="keyword">return</span> query(o-&gt;L,l,mdl,k);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> query(o-&gt;R,mdl+<span class="number">1</span>,r,k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findrpos</span><span class="params">(node *o,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l==r)&#123;</span><br><span class="line"><span class="keyword">if</span> (o-&gt;rst&gt;k) <span class="keyword">return</span> l<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line">pushdown(o);</span><br><span class="line"><span class="keyword">int</span> mdl=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (o-&gt;L-&gt;rst&lt;=k) <span class="keyword">return</span> findrpos(o-&gt;R,mdl+<span class="number">1</span>,r,k);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> findrpos(o-&gt;L,l,mdl,k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SegmentTree()&#123;root=<span class="keyword">new</span> node;&#125;</span><br><span class="line">&#125;S[<span class="number">200000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">node * <span class="title">merge</span><span class="params">(node *L,node *R)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!L||!R) <span class="keyword">return</span> L?L:R;</span><br><span class="line">L-&gt;L=merge(L-&gt;L,R-&gt;L),L-&gt;R=merge(L-&gt;R,R-&gt;R);</span><br><span class="line">L-&gt;rst+=R-&gt;rst,L-&gt;tag+=R-&gt;tag;</span><br><span class="line"><span class="keyword">delete</span> R;</span><br><span class="line"><span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> val[<span class="number">200000</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> to,nxt;&#125;E[<span class="number">500000</span>];</span><br><span class="line"><span class="keyword">int</span> H[<span class="number">200000</span>],tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">E[++tot]=(edge)&#123;b,H[a]&#125;;H[a]=tot;</span><br><span class="line">E[++tot]=(edge)&#123;a,H[b]&#125;;H[b]=tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">200000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=H[now];i;i=E[i].nxt)&#123;</span><br><span class="line"><span class="keyword">if</span> (E[i].to==fa) <span class="keyword">continue</span>;</span><br><span class="line">solve(E[i].to,now);</span><br><span class="line">merge(S[now].root,S[E[i].to].root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> v=S[now].query(S[now].root,<span class="number">0</span>,<span class="number">1000000000</span>,val[now]);</span><br><span class="line"><span class="keyword">int</span> rp=S[now].findrpos(S[now].root,<span class="number">0</span>,<span class="number">1000000000</span>,v);</span><br><span class="line">S[now].modify(S[now].root,<span class="number">0</span>,<span class="number">1000000000</span>,val[now],rp);</span><br><span class="line">ans[now]=v+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;val[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y),add_edge(x+<span class="number">1</span>,y+<span class="number">1</span>);</span><br><span class="line">solve(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 做题记录 </category>
          
          <category> hihoCoder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树合并 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
